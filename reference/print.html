<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GameLisp Reference Manual</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded affix "><a href="introduction-for-rust-programmers.html">Introduction for Rust Programmers</a></li><li class="chapter-item expanded affix "><a href="introduction-for-lisp-programmers.html">Introduction for Lisp Programmers</a></li><li class="chapter-item expanded "><a href="the-language.html"><strong aria-hidden="true">1.</strong> The Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax-and-types.html"><strong aria-hidden="true">1.1.</strong> Syntax and Types</a></li><li class="chapter-item expanded "><a href="evaluation.html"><strong aria-hidden="true">1.2.</strong> Evaluation</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">1.3.</strong> Macros</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="built-in-macros.html"><strong aria-hidden="true">1.3.1.</strong> Built-in Macros</a></li></ol></li><li class="chapter-item expanded "><a href="numbers.html"><strong aria-hidden="true">1.4.</strong> Numbers</a></li><li class="chapter-item expanded "><a href="arrays.html"><strong aria-hidden="true">1.5.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="strings-and-text.html"><strong aria-hidden="true">1.6.</strong> Strings and Text</a></li><li class="chapter-item expanded "><a href="tables.html"><strong aria-hidden="true">1.7.</strong> Tables</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">1.8.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="coroutines.html"><strong aria-hidden="true">1.9.</strong> Coroutines</a></li><li class="chapter-item expanded "><a href="patterns.html"><strong aria-hidden="true">1.10.</strong> Patterns</a></li><li class="chapter-item expanded "><a href="object-oriented-programming.html"><strong aria-hidden="true">1.11.</strong> Object-Oriented Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="state-machines.html"><strong aria-hidden="true">1.11.1.</strong> State Machines</a></li><li class="chapter-item expanded "><a href="code-reuse.html"><strong aria-hidden="true">1.11.2.</strong> Code Reuse</a></li><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">1.11.3.</strong> Structs</a></li></ol></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">1.12.</strong> Errors</a></li><li class="chapter-item expanded "><a href="miscellaneous.html"><strong aria-hidden="true">1.13.</strong> Miscellaneous</a></li></ol></li><li class="chapter-item expanded "><a href="the-rust-api.html"><strong aria-hidden="true">2.</strong> The Rust API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="the-glsp-crate.html"><strong aria-hidden="true">2.1.</strong> The glsp Crate</a></li><li class="chapter-item expanded "><a href="collection-types.html"><strong aria-hidden="true">2.2.</strong> Collection Types</a></li><li class="chapter-item expanded "><a href="rust-bindings.html"><strong aria-hidden="true">2.3.</strong> Rust Bindings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rfn.html"><strong aria-hidden="true">2.3.1.</strong> RFn</a></li><li class="chapter-item expanded "><a href="rdata.html"><strong aria-hidden="true">2.3.2.</strong> RData</a></li><li class="chapter-item expanded "><a href="rclass.html"><strong aria-hidden="true">2.3.3.</strong> RClass</a></li><li class="chapter-item expanded "><a href="rglobal.html"><strong aria-hidden="true">2.3.4.</strong> RGlobal</a></li></ol></li><li class="chapter-item expanded "><a href="garbage-collection.html"><strong aria-hidden="true">2.4.</strong> Garbage Collection</a></li><li class="chapter-item expanded "><a href="procedural-macros.html"><strong aria-hidden="true">2.5.</strong> Procedural Macros</a></li><li class="chapter-item expanded "><a href="compilation.html"><strong aria-hidden="true">2.6.</strong> Compilation</a></li><li class="chapter-item expanded "><a href="feature-flags.html"><strong aria-hidden="true">2.7.</strong> Feature Flags</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="performance-figures.html">Appendix A: Performance Figures</a></li><li class="chapter-item expanded affix "><a href="naming-conventions.html">Appendix B: Naming Conventions</a></li><li class="chapter-item expanded affix "><a href="implementation-limits.html">Appendix C: Implementation Limits</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">GameLisp Reference Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#overview" id="overview">Overview</a></h1>
<p><a href="..">GameLisp</a>'s documentation is split into three parts:</p>
<ul>
<li>
<p>The Reference Manual, which you're currently reading, is a rough overview of the language. 
It's written in an accessible style, so it doubles as a tutorial when read from beginning to end.</p>
</li>
<li>
<p>The <a href="../std/">standard library documentation</a> describes all of the special forms, functions and 
macros which are built into the language itself. It covers most of the same material as 
<a href="the-language.html">Section 1</a> of the Reference Manual, but it's more formal, comprehensive 
and precise.</p>
</li>
<li>
<p>The <a href="https://docs.rs/glsp/"><code>glsp</code> crate documentation</a> describes how to embed GameLisp
into a Rust program. <a href="the-rust-api.html">Section 2</a> of the Reference Manual will walk you 
through the basics.</p>
</li>
</ul>
<h2><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h2>
<p>If you haven't already, take a look at the 
<a href="introduction-for-rust-programmers.html">Introduction for Rust Programmers</a> 
and/or the 
<a href="introduction-for-lisp-programmers.html">Introduction for Lisp Programmers</a>.</p>
<p>You can get a feel for the language by examining the source code for a few small games on 
the <a href="../playground/">interactive playground</a>.</p>
<p>To start setting up a GameLisp project of your own, check that you're running the latest version
of nightly Rust, and then add this line to your <code>Cargo.toml</code>:</p>
<pre><code>[dependencies]
glsp = &quot;0.2&quot;
</code></pre>
<p>The following boilerplate code will load and run a single GameLisp source file named <code>main.glsp</code> in
the working directory, printing a stack trace if any errors occur. (The working directory is 
usually the same directory which contains your project's <code>Cargo.toml</code> file.)</p>
<pre><pre class="playpen"><code class="language-rust">use glsp::prelude::*;

fn main() {
	let runtime = Runtime::new();
	runtime.run(|| {
		glsp::load(&quot;main.glsp&quot;)?;
		Ok(())
	});
}
</code></pre></pre>
<p>Once that's up and running, I'd recommend working your way through the Reference Manual from start
to finish. It's not too long - it can be completed in three hours or so. As you progress, you can 
use your skeleton project to experiment with the language, the standard library, and the Rust API.</p>
<p>Syntax-highlighting schemes for Visual Studio Code and Sublime Text 3 can be downloaded from the
<a href="https://github.com/fleabitdev/glsp/tree/master/syntax-highlighting/">GitHub repository</a>.</p>
<p>If you've never worked with Lisp before, you might find some parts of GameLisp difficult to 
understand. If you're struggling, consider looking through some beginner-level material for another 
Lisp dialect, such as the excellent <a href="http://www.gigamonkeys.com/book/">Practical Common Lisp</a> by 
Peter Seibel.</p>
<h2><a class="header" href="#-stability-warning-" id="-stability-warning-">⚠️ Stability Warning ⚠️</a></h2>
<p>Because GameLisp is brand new, it currently provides <strong>no stability guarantees</strong>. The language, 
standard library and Rust API can and will change without notice. It's also immature enough that 
you may come across the occasional bug - if so, a <a href="https://github.com/fleabitdev/glsp/issues/">bug report</a> would be appreciated.</p>
<p>GameLisp can still be used for serious game projects (I'm using it for <a href="../tcof/">one</a> myself!), 
but you'll need to be prepared to refactor your codebase from time to time.</p>
<h1><a class="header" href="#introduction-for-rust-programmers" id="introduction-for-rust-programmers">Introduction for Rust Programmers</a></h1>
<p>Rust is my favourite programming language. It has impeccable performance, an expressive and
powerful type system, and a great community.</p>
<p>However, when it comes to game development, Rust has a few well-known problems. Compile times are
painfully slow, and the type system can sometimes feel rigid or bureaucratic. When adding a new
feature to a game, you'll often need to write code in a messy, fast, exploratory fashion - and in 
those cases, Rust can be a hindrance rather than a help.</p>
<p>GameLisp is a scripting language for Rust game development, designed while creating <a href="../tcof/">The Castle 
on Fire</a>. It complements Rust by being very different from it: the Yin to Rust's Yang. 
Unlike Rust, it's an interpreted, dynamically-typed language, comparable to Lua, Python or Ruby. 
When using GameLisp, your project can be rebuilt in milliseconds rather than minutes, and there's 
no static type-checker to step on your toes.</p>
<p>Of course, you could already get those benefits by binding an existing scripting language to your
Rust game project, using a crate like <a href="https://crates.io/crates/rlua">rlua</a> for Lua or 
<a href="https://crates.io/crates/pyo3">pyo3</a> for Python - so why add a new language into the mix? 
GameLisp has a few features which I think make it a better choice:</p>
<ul>
<li>
<p>GameLisp is a &quot;Rust-first&quot; scripting language. Integration of GameLisp code into a Rust project 
is low-friction, high-performance, and completely memory-safe. Installation and distribution 
are trivial (it's just a crate!). Language features like <code>match</code>, <code>for</code> and <code>struct</code> are
designed to closely resemble their Rust counterparts.</p>
</li>
<li>
<p>Garbage-collection pauses lead to dropped frames, and dropped frames lead to unhappy players. 
GameLisp has an <a href="garbage-collection.html">unusual garbage collector</a> which is designed to be 
called once per frame, every frame, spreading out the workload so that it takes up a consistent 
amount of runtime. In a <a href="performance-figures.html#specimen-project">real-world game codebase</a>, 
GameLisp's garbage collector only takes up 0.1 milliseconds of frametime (that is, only 0.6% of 
the available time budget).</p>
<ul>
<li>More generally, <a href="performance-figures.html#benchmarks">microbenchmarks</a> suggest that GameLisp's
performance currently hovers somewhere between interpreted Lua and interpreted Python.</li>
</ul>
</li>
<li>
<p>As a Lisp dialect, GameLisp is extremely customizable. Its macro system allows you to define
new syntax which is indistinguishable from the built-in syntax; create domain-specific
languages; or even customize fundamental language features like <code>class</code> and <code>=</code>.</p>
<ul>
<li>If you've used Lisp before and found that it wasn't to your taste, note that GameLisp 
avoids <a href="introduction-for-lisp-programmers.html">a few common pain points</a> from other Lisp 
dialects.</li>
</ul>
</li>
<li>
<p>GameLisp follows the <a href="http://www.paulgraham.com/arcll1.html">Arc philosophy</a> of being concise, 
easy to type and easy to edit. The most common types and functions tend to be only a few
characters in length: <code>str</code>, <code>obj?</code>, <code>=</code>, <code>defn</code>, <code>rev</code>. It includes several language features 
intended to reduce boilerplate, such as iterators, coroutines, pattern-matching, and (of course) 
macros. You could expect a thirty-line function in a Lua project to be a fraction of that length 
in a GameLisp project.</p>
</li>
<li>
<p>GameLisp has a novel object system, inspired by <a href="https://all-things-andy-gavin.com/2011/03/12/making-crash-bandicoot-gool-part-9/">Andy Gavin's writings on GOOL</a>, which is uniquely
well-suited for game development. All objects are state machines: in the same way that your
Rust codebase might use an <code>enum</code> or an <code>Option</code> to statically guarantee that its data
model is never invalid, GameLisp code can use a <a href="state-machines.html"><code>state</code> form</a> to explicitly 
model the life cycle of its in-game entities. GameLisp's object model avoids inheritance (OOP's 
biggest mistake!); instead, it encourages composition via 
<a href="object-oriented-programming.html#classmacros">classmacros</a> and <a href="code-reuse.html#mixins">mixins</a>.</p>
</li>
</ul>
<p>If any of the above has whet your appetite, take a look at 
<a href="overview.html#getting-started">Getting Started</a> for more information.</p>
<p>If you have previous experience with Lisp, you might be interested in the <a href="introduction-for-lisp-programmers.html">Introduction for
Lisp Programmers</a>.</p>
<h1><a class="header" href="#introduction-for-lisp-programmers" id="introduction-for-lisp-programmers">Introduction for Lisp Programmers</a></h1>
<p>Veteran Lisp programmers will find some parts of GameLisp's design surprising. I've done my best 
to preserve Lisp's strengths, but I haven't hesitated to remove or modify features which are 
standard in other Lisp dialects.</p>
<p>The most Lispy features of GameLisp are its homoiconicity, its Common‑Lisp‑style macro system, and 
the powerful metaprogramming which that implies. The parser, printer, symbols, and data‑as‑code 
should feel familiar to any Lisp programmer.</p>
<p>The <em>least</em> Lispy feature of GameLisp is the fact that it's not a functional language. Game code 
tends to be object-oriented and imperative, so GameLisp is an object-oriented, imperative
language. Like Rust, it sprinkles in a little bit of functional flavour here and there (such as 
its Rust-style <a href="iterators.html">iterator adapters</a> and <a href="patterns.html">pattern-matching</a>) - but unlike 
Rust, most data is mutable-by-default and there are no restrictions on shared ownership.</p>
<p>Because it's not a functional language, GameLisp doesn't use lists. The singly-linked-list 
data structure loses many of its advantages when coding in a non-functional style, while still having
many disadvantages (<code>caddar</code>, poor big-O complexity for many operations, extra pressure on the 
allocator...), so I've completely removed cons cells from the language. Instead, <code>(a b c)</code> 
represents a double-ended contiguous array 
(specifically, a <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>VecDeque</code></a>). 
I've found that for representing syntax, and as a general-purpose sequential data structure, 
double-ended arrays are significantly more versatile and convenient than lists. The slightly 
increased cost of <code>(rest x)</code> hasn't been a problem in practice.</p>
<p>(I'm aware that Lisp is an acronym for <em>Lis</em>t <em>P</em>rocessing, and I do appreciate the irony...)</p>
<p>Finally, I've made GameLisp's syntax and keywords as &quot;Rust-like&quot; as possible, to minimize the
mental friction when switching between the Rust and GameLisp parts of your codebase. I've also 
changed a handful of names to make them more concise or more descriptive. Notable changes:</p>
<ul>
<li>
<p><code>lambda</code> has been renamed to <code>fn</code>.</p>
</li>
<li>
<p><code>set!</code>/<code>setf</code> has been renamed to <code>=</code>.</p>
<ul>
<li>The numeric-equality test <code>=</code> has been renamed to <code>==</code>.</li>
<li>The naming convention for assignment, <code>set-something!</code>, is now <code>something=</code>.</li>
<li>I've retained the <code>!</code> suffix for other mutating functions, like <code>push!</code> and <code>inc!</code>, and the 
<code>?</code> suffix for predicates, like <code>int?</code>.</li>
</ul>
</li>
<li>
<p><code>progn</code>/<code>begin</code> has been renamed to <code>do</code>.</p>
</li>
<li>
<p>The special values for true, false and nil are written as <code>#t</code>, <code>#f</code> and <code>#n</code>. Nil, false, and
the empty sequence <code>()</code> are all distinct from one another.</p>
</li>
<li>
<p><code>let</code> no longer defines a block: it introduces a new binding which is scoped to the end of its 
enclosing block, similar to <code>define</code> in Scheme or <code>let</code> in Rust.</p>
</li>
<li>
<p>Conditionals follow the conventions from 
<a href="https://docs.racket-lang.org/style/Choosing_the_Right_Construct.html">Racket</a>: prefer <code>cond</code>
or <code>match</code> rather than <code>if</code>, unless it's a very brief conditional which fits into a single line.</p>
</li>
<li>
<p>Sequence-processing primitives have been renamed to match their Rust equivalents: <code>len</code> 
rather than <code>length</code>, <code>rev</code> rather than <code>reverse</code>, and so on.</p>
</li>
<li>
<p>A small number of new abbreviations (all of which have a <a href="syntax-and-types.html#abbreviations">straightforward 
representation</a>): </p>
<ul>
<li><code>[a b]</code> to access the field <code>b</code> in the collection <code>a</code>.</li>
<li><code>@name</code> to access the field <code>name</code> on a method's self-object.</li>
<li><code>(.met-name a b c)</code> to invoke the method <code>met-name</code> on the object <code>a</code>.</li>
<li><code>(callee ..args x)</code> to splay the contents of the <code>args</code> collection into individual 
function arguments. This is similar to <code>(apply)</code>, but more powerful and versatile.</li>
</ul>
</li>
<li>
<p>The quasiquote syntax resembles Clojure. Forms are unquoted with <code>~</code> rather than <code>,</code>, and symbols 
can be auto-gensymed with a <code>#</code> suffix, as in <code>name#</code>. We parse commas as whitespace so that 
function or macro arguments can be visually grouped together, like <code>(let a b, c d)</code>.</p>
</li>
</ul>
<p>Early on in GameLisp's development, its syntax and keywords were much more Scheme-like. These
changes aren't arbitrary - each of them came from battle-testing GameLisp while developing The 
Castle on Fire. They each represent something which has caused me enough frustration that I 
thought it would be worth refactoring a dense, 15,000-line codebase to change it.</p>
<p>That being said, GameLisp is still in its infancy. If you're interested in shaping the growth of
a new Lisp - specifically, if you've spent a little time working with GameLisp and you have a 
suggestion for its syntax, naming conventions or style conventions - please feel free to
<a href="https://github.com/fleabitdev/glsp/issues/">get in touch on GitHub</a>. Some changes which are possible now might be impossible in twelve 
months' time, so don't hesitate!</p>
<h1><a class="header" href="#the-language" id="the-language">The Language</a></h1>
<p>This section begins with three in-depth chapters describing...</p>
<ul>
<li>The <a href="syntax-and-types.html">parser</a>, which converts GameLisp source text into data.</li>
<li>The <a href="macros.html">expander</a>, which takes GameLisp data and performs transformations on it.</li>
<li>The <a href="evaluation.html">evaluator</a>, which takes expanded GameLisp data and executes it as a program.</li>
</ul>
<p>The rest of this section then takes a more casual tour through the GameLisp Standard Library, 
introducing the most important built-in functions, macros and special forms.</p>
<p>After finishing this section, you should feel confident writing basic GameLisp code, referring 
back to the first three chapters and the <a href="../std/">standard library documentaton</a> when necessary.</p>
<h1><a class="header" href="#syntax-and-types" id="syntax-and-types">Syntax and Types</a></h1>
<p>Here is a toy GameLisp program which calculates the first thirty Fibonacci numbers:</p>
<pre><code>(let fibs (arr 0 1))

(while (&lt; (len fibs) 31)
  (push! fibs (+ [fibs -1] [fibs -2])))

(prn [fibs -1]) ; prints 832040
</code></pre>
<p>In this chapter, we will describe GameLisp's syntax in full; explain why it's so different from 
the syntax of languages like Rust; and start to think about the unique advantages which come from 
those differences.</p>
<h2><a class="header" href="#homoiconicity" id="homoiconicity">Homoiconicity</a></h2>
<p>All programming languages have something called an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> (AST): a data
representation of a program's source code. The AST is usually hidden inside the compiler, where 
the programmer can't interact with it directly.</p>
<p>For example, this fragment of Rust source code...</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>foo.bar(1)
<span class="boring">}
</span></code></pre></pre>
<p>...could be represented by this (imaginary) AST data structure:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Expression::MethodCall {
	callee: Identifier(&quot;foo&quot;),
	method_name: Identifier(&quot;bar&quot;),
	arguments: vec![
		Expression::Literal(Literal::Int(1))
	]
}
<span class="boring">}
</span></code></pre></pre>
<p>You've probably also encountered text-based data interchange formats, like <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> or <a href="https://en.wikipedia.org/wiki/TOML">TOML</a>. They 
provide a way for us to store common data structures, like arrays, hash tables, booleans and
strings, in a human-readable file format which is easy to edit.</p>
<p>For example, this fragment of JSON describes an array which contains each of the integers
from 0 to 4 inclusive:</p>
<pre><code class="language-json">[0, 1, 2, 3, 4]
</code></pre>
<p>GameLisp, like all Lisp languages, is <a href="https://en.wikipedia.org/wiki/Homoiconicity">homoiconic</a>. This means that its AST is made out of simple, 
primitive data types like arrays and booleans - the same data types which you might encounter in
a JSON file. Let's look more closely at the first line of our Fibonacci program:</p>
<pre><code>(let fibs (arr 0 1))
</code></pre>
<p>This is just the text representation of an array with these three elements:</p>
<ul>
<li>The symbol <code>let</code></li>
<li>The symbol <code>fibs</code></li>
<li>A nested array, with these three elements:
<ul>
<li>The symbol <code>arr</code></li>
<li>The integer <code>0</code></li>
<li>The integer <code>1</code></li>
</ul>
</li>
</ul>
<p>A comparable JSON fragment would be:</p>
<pre><code class="language-json">[&quot;let&quot;, &quot;fibs&quot;, [&quot;arr&quot;, 0, 1]]
</code></pre>
<p>In other words, in GameLisp, <strong>code is data and data is code</strong>. A GameLisp program is <em>not</em>
defined by a block of text - instead, it's defined by a tree of simple data-types. That tree
could have been read from a text file, but it could just as well have been generated from nothing 
by a GameLisp program, or deserialized from a binary file using <a href="https://serde.rs">Serde</a>, or any 
number of other possibilities.</p>
<p><img src="ast-generation.svg" alt="A flowchart showing the generation of ASTs in Rust and GameLisp" /></p>
<h2><a class="header" href="#expansion" id="expansion">Expansion</a></h2>
<p>There's no sense in denying it: building programs out of array literals causes them to have a 
relatively ugly syntax. Why is GameLisp designed this way?</p>
<p>The big advantage is that, when code is data, it becomes much easier to write code which creates 
or modifies other code on your behalf. There's no need to mess around with an AST or manipulate 
the raw text of your program - it's all just arrays!</p>
<p>For example, here's a GameLisp program which reads in a GameLisp source file, performs
<code>gettext</code>‑style localization on it (replacing English string literals with French 
string literals based on a one-to-one mapping listed in a file), and then runs the program:</p>
<pre><code>(let replacements (parse-1 (read-file &quot;en-to-fr.glsp&quot;)))
(let source (parse-all (read-file &quot;source.glsp&quot;)))

(let-fn recursively-translate (val)
  (match val
    (coll : (or arr? tab?)
      (map-syntax recursively-translate coll))
    (st : str?
      (or [replacements (? st)] st))
    (val
      val)))

(eval-multi (recursively-translate source))
</code></pre>
<p>To make this kind of code-generation more convenient, all GameLisp code is automatically put through 
an &quot;expansion pass&quot; just before being run. The expansion pass inspects each array in the program; 
checks whether that array's first element is the name of a macro (a function which transforms 
GameLisp source code into different GameLisp source code); and if so, uses that macro to 
transform the array into something else. </p>
<p>Unlike Rust macros, GameLisp macros are indistinguishable from the language's built-in syntax.
This gives you the ability to profoundly customise the language - we'll explore some of the
possibilities in the <a href="macros.html">Macros</a> chapter. </p>
<h2><a class="header" href="#representable-types" id="representable-types">Representable Types</a></h2>
<p>GameLisp is a dynamically-typed language. Memory locations like global variables, table fields
and function arguments always store a single generic &quot;value&quot;, which can belong to any of 
sixteen different primitive types. The full set of types is <a href="syntax-and-types.html#type-summary">summarized below</a>.</p>
<p>Of these sixteen types, nine of them can be losslessly converted into text and
then read back in by the parser. We say that they are &quot;representable&quot;, because they have an exact
text representation. Valid GameLisp source code is entirely made out of these representable types.</p>
<h3><a class="header" href="#nil" id="nil"><code>nil</code></a></h3>
<p><code>nil</code> is the type of a value which is absent, uninitialized or undefined. In Rust terms, it
takes on the roles of both <code>None</code> and <code>()</code>.</p>
<p>It only has one value, which is represented as <code>#n</code>.</p>
<h3><a class="header" href="#bool" id="bool"><code>bool</code></a></h3>
<p><code>bool</code> is the type of a boolean value: either true (represented as <code>#t</code>) or false (represented
as <code>#f</code>).</p>
<p>When testing whether or not a value is true (for example, when deciding how an <code>if</code> expression
should branch), we consider <code>#f</code> and <code>#n</code> to be &quot;falsy&quot; values, and all other values to be 
&quot;truthy&quot;.</p>
<h3><a class="header" href="#int-flo" id="int-flo"><code>int</code>, <code>flo</code></a></h3>
<p>The <code>int</code> type is a 32-bit signed integer number: an <code>i32</code>.</p>
<p>The <code>flo</code> type is a 32-bit floating-point number: an <code>f32</code>.</p>
<p>The text representation for numbers is almost identical to <a href="https://doc.rust-lang.org/reference/tokens.html#number-literals">their representation in Rust</a>. You can
embed underscores in numbers, and integers can be prefixed with <code>0b</code>, <code>0o</code> or <code>0x</code> to change their
base.</p>
<p>There are only a few small changes compared to Rust's syntax:</p>
<ul>
<li>Type suffixes, like <code>_i8</code> or <code>_f32</code>, are forbidden.</li>
<li>Infinities are represented as <code>+inf.0</code> and <code>-inf.0</code>.</li>
<li>&quot;Not a number&quot; is represented as <code>nan.0</code>.</li>
</ul>
<p>We'll discuss these types in more detail in the <a href="numbers.html">Numbers</a> chapter.</p>
<h3><a class="header" href="#sym" id="sym"><code>sym</code></a></h3>
<p>The <code>sym</code> type is a symbol, also known as an <a href="https://en.wikipedia.org/wiki/String_interning">interned string</a>.</p>
<p>GameLisp uses symbols to represent identifiers and keywords in an efficient way. In the declaration 
<code>(let var-name 0)</code>, both <code>let</code> and <code>var-name</code> are symbols. Representing them as symbols rather 
than strings makes several basic operations much faster: comparing one identifier to another,
looking up a global variable, parsing a keyword from a file, and so on.</p>
<p>A symbol's name is a sequence of one or more of the following characters: <code>a</code> to <code>z</code>, <code>A</code> to <code>Z</code>, 
<code>0</code> to <code>9</code>, <code>!</code>, <code>$</code>, <code>%</code>, <code>&amp;</code>, <code>*</code>, <code>+</code>, <code>-</code>, <code>.</code>, <code>/</code>, <code>:</code>, <code>&lt;</code>, <code>=</code>, <code>&gt;</code>, <code>?</code>, <code>^</code>, <code>~</code> or <code>_</code>.
A symbol can optionally be suffixed with a single <code>#</code>.</p>
<p>This opens up a much richer selection of identifiers, compared to Rust. Any of the following 
symbols would be valid names for a variable:</p>
<pre><code>push!
int?
name=
foo:bar
-
//
1+
&amp;$+%~#
</code></pre>
<p>When the parser encounters a sequence of characters which could represent a symbol, or could
represent a number or <a href="syntax-and-types.html#abbreviations">abbreviation</a>, then the number or abbreviation will take
priority. This means that not all symbols are representable. The symbol <code>-10</code> can exist, but if 
you write it to a file, it will be read back in as a number instead.</p>
<h3><a class="header" href="#char" id="char"><code>char</code></a></h3>
<p>The <code>char</code> type is a character. Its storage is identical to a <a href="https://doc.rust-lang.org/reference/types/textual.html">Rust <code>char</code></a>.</p>
<p>Characters are represented by a backslash followed by the character itself - for example, 
<code>\a</code>, <code>\(</code>, or <code>\🦀</code>.</p>
<p>Certain whitespace characters are represented by a backslash followed by their name: <code>\space</code>,
<code>\tab</code>, <code>\newline</code>, <code>\return</code>, and <code>\nul</code>.</p>
<p>You can represent an arbitrary unicode character as either... </p>
<ul>
<li><code>\xNN</code>, where <code>NN</code> is a hexadecimal value from <code>00</code> to <code>7f</code> inclusive.</li>
<li><code>\u{NN}</code>, where the curly braces may enclose anywhere from one to six hexadecimal digits.</li>
</ul>
<h3><a class="header" href="#str" id="str"><code>str</code></a></h3>
<p>The <code>str</code> type is a text string.</p>
<p>The representation of strings is identical to a <a href="https://doc.rust-lang.org/reference/tokens.html#string-literals">Rust string literal</a>, including all of the same 
escape sequences. Raw strings, like <code>r##&quot;text&quot;##</code>, are supported.</p>
<p>Strings, characters and symbols are all discussed together in the <a href="strings-and-text.html">Strings and 
Text</a> chapter.</p>
<h3><a class="header" href="#arr" id="arr"><code>arr</code></a></h3>
<p>The <code>arr</code> type is an array of arbitrary values. More specifically, it's a double-ended 
queue, similar to <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>VecDeque</code></a> in Rust.</p>
<p>An array is represented by the open-parenthesis <code>(</code>, followed by the representation of zero
or more values, followed by the close-parenthesis <code>)</code>.</p>
<p>For example, an array containing squares of the first five positive integers would be represented 
as <code>(1 4 9 16 25)</code>. An empty array would be represented as <code>()</code>.</p>
<p>The <a href="arrays.html">Arrays</a> chapter has more details.</p>
<h3><a class="header" href="#tab" id="tab"><code>tab</code></a></h3>
<p>The <code>tab</code> type is a table (specifically, a <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>) which maps values to values.</p>
<p>A table is represented by <code>#(</code>, followed by zero or more key-value pairs, each with the same 
representation as an array of length two, followed by the close-parenthesis <code>)</code>.</p>
<p>For example, <code>#((a b) (100 200))</code> represents a table which contains the value <code>b</code> bound to the key 
<code>a</code>, and the value <code>200</code> bound to the key <code>100</code>.</p>
<p>See the <a href="tables.html">Tables</a> chapter for more.</p>
<h2><a class="header" href="#whitespace" id="whitespace">Whitespace</a></h2>
<p>The parser ignores whitespace, except for marking the boundary between one token and the next.
All comments are parsed as whitespace.</p>
<p>A line comment is introduced with a single <code>;</code> and continues until the next newline.</p>
<p>A block comment begins with <code>#|</code> and ends with <code>|#</code>. Block comments can be nested. An unterminated
block comment is a syntax error.</p>
<p>Prefixing a value with <code>#;</code> will turn that entire value into a comment. This can be a convenient 
way to comment out code:</p>
<pre><code>(when (&lt; a 100)
  (new-handler (+ a 1))
  #;(when handler-enabled?
    (old-handler)))
</code></pre>
<p>The comma <code>,</code> is a whitespace character - this can be helpful for visually breaking up long
sequences into smaller groups.</p>
<pre><code>(let a b, c d, e f) ; easier to read
(let a b c d e f)   ; harder to read
</code></pre>
<h2><a class="header" href="#abbreviations" id="abbreviations">Abbreviations</a></h2>
<p>Some patterns appear so frequently in GameLisp programs that they've been given dedicated
syntax. All of these abbreviations represent an array. For example, if you try to print the 
two-element array <code>(splay val)</code>, it will be printed as <code>..val</code>.</p>
<p>The abbreviations are:</p>
<table><thead><tr><th>Abbreviation</th><th>Represents</th></tr></thead><tbody>
<tr><td><code>'val</code></td><td><a href="../std/quote"><code>(quote val)</code></a></td></tr>
<tr><td><code> `val</code></td><td><a href="../std/backquote"><code>(backquote val)</code></a></td></tr>
<tr><td><code>~val</code></td><td><a href="../std/unquote"><code>(unquote val)</code></a></td></tr>
<tr><td><code>[x y]</code></td><td><a href="../std/access"><code>(access x y)</code></a></td></tr>
<tr><td><code>..val</code></td><td><a href="../std/splay"><code>(splay val)</code></a></td></tr>
<tr><td><code>@val</code></td><td><a href="../std/atsign"><code>(atsign val)</code></a></td></tr>
<tr><td><code>.val</code></td><td><a href="../std/met-name"><code>(met-name val)</code></a></td></tr>
</tbody></table>
<p>In addition, we use curly braces for string interpolation. When a string contains curly braces, 
it actually represents an array rather than a string. These two lines are exactly equivalent:</p>
<pre><code>&quot;text {a}{b} {c d}&quot;
(template-str &quot;text &quot; a &quot;&quot; b &quot; &quot; c d)
</code></pre>
<p>Curly-brace characters in a string can be escaped by doubling them, as in <code>{{</code> or <code>}}</code>. Raw
strings cannot be interpolated.</p>
<h2><a class="header" href="#type-summary" id="type-summary">Type Summary</a></h2>
<p>The seven non-representable primitive types are each discussed in future chapters. For now, a 
quick summary of all of <code>val</code>'s possible types:</p>
<table><thead><tr><th>Name</th><th>Meaning</th><th align="center">Truthy?</th><th align="center">Reference?</th></tr></thead><tbody>
<tr><td><code>nil</code></td><td>Absent or undefined value</td><td align="center">No</td><td align="center">No</td></tr>
<tr><td><code>bool</code></td><td>Boolean</td><td align="center">Varies</td><td align="center">No</td></tr>
<tr><td><code>int</code></td><td>32-bit signed integer</td><td align="center">Yes</td><td align="center">No</td></tr>
<tr><td><code>flo</code></td><td>32-bit floating-point number</td><td align="center">Yes</td><td align="center">No</td></tr>
<tr><td><code>char</code></td><td>Character</td><td align="center">Yes</td><td align="center">No</td></tr>
<tr><td><code>sym</code></td><td>Symbol</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>arr</code></td><td>Array</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>str</code></td><td>String</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>tab</code></td><td>Table</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>iter</code></td><td>Iterator</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>obj</code></td><td>Object</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>class</code></td><td>Class</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>fn</code></td><td>Function</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>coro</code></td><td>Coroutine</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>rfn</code></td><td>Rust function</td><td align="center">Yes</td><td align="center">Yes</td></tr>
<tr><td><code>rdata</code></td><td>Rust data</td><td align="center">Yes</td><td align="center">Yes</td></tr>
</tbody></table>
<h3><a class="header" href="#abstract-types" id="abstract-types">Abstract Types</a></h3>
<p>Abstract types group together multiple primitive types which share a common API.</p>
<table><thead><tr><th>Abstract Type</th><th>API</th><th>Concrete Types</th></tr></thead><tbody>
<tr><td><code>num</code></td><td>Number</td><td><code>int</code>, <code>flo</code></td></tr>
<tr><td><code>deque</code></td><td>Double-ended queue</td><td><code>arr</code>, <code>str</code></td></tr>
<tr><td><code>callable</code></td><td>Function-call receiver</td><td><code>fn</code>, <code>rfn</code>, <code>class</code></td></tr>
<tr><td><code>expander</code></td><td>Macro expander</td><td><code>fn</code>, <code>rfn</code></td></tr>
<tr><td><code>iterable</code></td><td>Iterable</td><td><code>arr</code>, <code>str</code>, <code>tab</code>, <code>coro</code>, <code>iter</code></td></tr>
</tbody></table>
<h1><a class="header" href="#evaluation" id="evaluation">Evaluation</a></h1>
<p>In the <a href="syntax-and-types.html">previous chapter</a>, we introduced the fact that GameLisp code is
made out of a tree of simple values. Those values are sometimes parsed directly from a text file, 
but they can also be generated dynamically.</p>
<p>Unlike Rust, GameLisp code does not need to be compiled into a binary before it can be run.
You just pass your code to GameLisp, and it's executed straight away.</p>
<p>This chapter will describe precisely what happens when GameLisp is asked to run a particular 
value as a piece of code.</p>
<h2><a class="header" href="#basic-evaluation" id="basic-evaluation">Basic Evaluation</a></h2>
<p>&quot;Evaluating&quot; a value means executing it as a piece of code. When we're talking about evaluation,
we tend to say &quot;form&quot; rather than &quot;value&quot;, but they're just two different names for the same 
thing. When a form is evaluated, it either returns another value or triggers an error.</p>
<p>Values of type <code>nil</code>, <code>bool</code>, <code>int</code>, <code>flo</code>, <code>char</code>, <code>str</code> or <code>tab</code> are self-evaluating. If you 
evaluate a form of one of these types, no code is executed; the &quot;evaluation&quot; simply returns the 
form itself.</p>
<p>Symbols evaluate to the current value of the variable which they name. Local variable bindings 
take precedence over global bindings. If there are no local or global bindings for the symbol
which is being evaluated, it's an error.</p>
<p>Arrays are a little more complicated:</p>
<ul>
<li>
<p>Empty arrays are self-evaluating.</p>
</li>
<li>
<p>When the array's first element is a symbol which names a <a href="evaluation.html#special-forms">special form</a>, such 
as <code>quote</code>, <code>if</code> or <code>do</code>, then that form's special evaluation rules are applied.</p>
</li>
<li>
<p>Otherwise, the array is evaluated as a function call. All of its elements are evaluated in 
order, from left to right. The result of evaluating the leftmost form becomes the
&quot;callee&quot;, the function which is being called. The results of evaluating all of the other 
forms (if any) are passed to the call as its arguments. The function call's return value
becomes the result of the evaluation.</p>
</li>
</ul>
<p>Attempting to evaluate a form of any 
<a href="syntax-and-types.html#representable-types">non-representable type</a> is an error.</p>
<p>A callee is usually a <a href="evaluation.html#functions">function</a>. Functions can be defined either in GameLisp or 
in Rust. GameLisp comes with a <a href="../std/">very large number of built-in functions</a> in its
standard library.</p>
<p>For now, the main built-in functions you need to know are:</p>
<ul>
<li>
<p><a href="../std/prn-fn"><code>prn</code></a> takes any number of arguments and prints their text representation to 
stdout, separated by spaces and followed by a newline. <a href="../std/pr"><code>pr</code></a> does the same thing 
without the newline. Both functions return <code>#n</code>.</p>
</li>
<li>
<p><a href="../std/int-p"><code>int?</code></a>, <a href="../std/tab-p"><code>tab?</code></a> and <a href="../std/types">similar functions</a> accept a 
single argument. They return <code>#t</code> if the argument belongs to the specified type, or <code>#f</code> 
otherwise.</p>
</li>
<li>
<p><a href="../std/lt"><code>&lt;</code></a>, <a href="../std/num-eq"><code>==</code></a>, <a href="../std/gte"><code>&gt;=</code></a> and so on perform numeric 
comparisons. <a href="../std/add"><code>+</code></a>, <a href="../std/sub"><code>-</code></a>, <a href="../std/rem"><code>%</code></a> and so on perform basic
arithmetic on numbers. It's an error to pass a non-number argument to any of these functions.</p>
<ul>
<li>Note that GameLisp's arithmetic and comparisons use prefix notation rather than the
more familiar <a href="https://en.wikipedia.org/wiki/Infix_notation">infix notation</a>. Rather than writing <code>1 + 2 + 3</code>, write <code>(+ 1 2 3)</code>; and
rather than writing <code>i &lt; len</code>, write <code>(&lt; i len)</code>.</li>
</ul>
</li>
<li>
<p><a href="../std/arr"><code>arr</code></a> constructs a new array which contains all of its arguments. For example, 
<code>(arr)</code> will return a new empty array, and <code>(arr 1 2 3)</code> will return a new array which contains
those three numbers.</p>
<ul>
<li>You can &quot;splay&quot; the contents of one array into another with the abbreviation <code>..</code>; for
example, <code>(arr 10 ..src)</code> will create a new array which contains the integer <code>10</code>,
followed by all of the elements from the array <code>src</code>.</li>
</ul>
</li>
</ul>
<p>A few examples of nested function calls:</p>
<pre><code>(prn (&gt; (+ 1 1 1) 2)) ; prints #t
(prn (pr &quot;a &quot;) (pr &quot;b &quot;)) ; prints a b #n #n
(prn (nil? #n) (int? 10) (bool? (int? &quot;hello&quot;))) ; prints #t #t #t
(prn (nil? 1 2)) ; error: too many arguments
</code></pre>
<h2><a class="header" href="#special-forms" id="special-forms">Special Forms</a></h2>
<p>&quot;Special forms&quot; are those which don't follow the basic evaluation rules described above. Because 
GameLisp's macro facilities are so powerful, it has a relatively small number of special forms,
compared to languages like Rust.</p>
<p><a href="../std/do"><code>do</code></a> has the same effect as a block <code>{ }</code> in Rust. <code>(do a b c)</code> evaluates <code>a</code>, then
evaluates <code>b</code>, then finally evaluates <code>c</code>, returning its value. <code>(do)</code>, with no arguments, 
evaluates to <code>#n</code>.</p>
<p>Many other forms establish an &quot;implicit <code>do</code>&quot;. They contain zero or more child forms which are
evaluated one after the other, and they return the result of evaluating their last child form.</p>
<p><a href="../std/quote"><code>quote</code></a> suppresses evaluation: <code>(quote a)</code> returns the value of <code>a</code> without 
evaluating it. Remember that <code>quote</code> is usually <a href="syntax-and-types.html#abbreviations">abbreviated</a> 
as <code>'</code>, so we would write <code>(quote val)</code> as <code>'val</code>. Quote is most often used either to stop a 
symbol from being evaluated as a variable, or to stop an array from being evaluated as a function
call:</p>
<pre><code>; without the quotes, this would be evaluated as printing the values of 
; variables named &quot;hello&quot; and &quot;world&quot;. with the quotes, it prints two
; symbols instead.
(prn 'hello 'world)

; without the quote, this would be evaluated as a call to the function 
; named &quot;alice&quot;, passing in the values of the variables &quot;betty&quot; 
; and &quot;carlo&quot; as arguments, and then printing the call's return value. 
; with the quote, it prints a literal array instead.
(prn '(alice betty carlo))
</code></pre>
<p><a href="../std/if"><code>if</code></a> performs conditional evaluation. It must always receive three forms: a 
&quot;condition&quot; form, a &quot;then&quot; form, and an &quot;else&quot; form. First, the &quot;condition&quot; form is evaluated. 
If its result is <a href="syntax-and-types.html#bool">truthy</a>, the &quot;then&quot; form is evaluated and returned; 
otherwise, the &quot;else&quot; form is evaluated and returned. </p>
<pre><code>; prints 5, but doesn't print 4
(prn (if (&gt; 2 1) 
  5 
  (prn 4)))
</code></pre>
<h2><a class="header" href="#local-variables" id="local-variables">Local Variables</a></h2>
<p>GameLisp's local variables are lexically scoped and always mutable. They can be declared either
at the toplevel of a source file, or within an <a href="evaluation.html#special-forms">implicit <code>do</code></a>.</p>
<p>Just like Rust, you declare a new local variable by using the <a href="../std/let"><code>let</code> special form</a>.
Its first argument should be a symbol, and its optional second argument is a form which will be
evaluated to initialize the variable. When the second argument is absent, the variable's initial 
value will be <code>#n</code>.</p>
<pre><code>(let a 20)
(let b (* 20 a))
(prn b) ; prints 400
</code></pre>
<p>When <code>let</code> has three or more arguments, it's equivalent to multiple consecutive <code>let</code> forms
with one or two arguments each. We could rewrite the above as:</p>
<pre><code>(let a 20, b (* 20 a))
(prn b) ; prints 400
</code></pre>
<p><code>let</code>'s first argument can be an arbitrary pattern rather than a symbol, but we'll discuss that 
in a <a href="patterns.html">later chapter</a>.</p>
<h2><a class="header" href="#global-variables" id="global-variables">Global Variables</a></h2>
<p>When evaluating a symbol which isn't bound to a local variable, it's assumed to refer to a
global variable instead. The symbol <code>a-name</code> will evaluate to the current value of the
global variable binding for the symbol <code>a-name</code>, or it will trigger an error if there's no 
such binding.</p>
<p>GameLisp's global variables use <a href="https://en.wikipedia.org/wiki/Late_binding#Late_binding_in_Lisp">late binding</a>. This means that every time a global variable
is accessed or mutated, that variable's binding is looked up at the last possible moment. If
you're trying to access a global variable which doesn't exist, you won't find out when the code 
is loaded - the error is delayed until you actually try to access it. On the other hand, 
late binding means that there's no need to declare your variables in advance, so you won't
have to struggle with order-of-declaration problems or circular dependencies.</p>
<p>Global bindings can be dynamically created, destroyed, accessed or mutated by calling the built-in 
functions <a href="../std/bind-global-mut"><code>bind-global!</code></a>, <a href="../std/del-global-mut"><code>del-global!</code></a>, 
<a href="../std/global"><code>global</code></a> and <a href="../std/set-global"><code>global=</code></a>.</p>
<p>Built-in function calls like <code>(prn 'hello)</code> make use of global variables. When the GameLisp runtime
starts up, the symbol <code>prn</code> is bound to a global variable. The initial value of that global
variable is set to a Rust function which prints its arguments.</p>
<p>A local variable &quot;shadows&quot; a global variable which is bound to the same name:</p>
<pre><code>(prn 'hello) ; prints hello
(let prn 10)
(prn 'world) ; error: callee is an int
</code></pre>
<p>Late binding enables some useful tricks. For example, if you're creating a 2D game and you find it
inconvenient to look up your sprites in a hash table, you could arrange for them to be
automatically bound to global variables instead:</p>
<pre><code>(draw spr:zombie-head (- x 10) (- y 10))
(draw spr:zombie-body (- x 10) y)
</code></pre>
<h2><a class="header" href="#functions" id="functions">Functions</a></h2>
<p>Functions in GameLisp are like closures in Rust, in that they can be stored as the value of a 
variable. Functions defined in GameLisp have the type <code>fn</code>, while functions defined in Rust
have the type <code>rfn</code>.</p>
<p>The <code>fn</code> special form defines a new function, which can then be called just like one of the
built-in functions:</p>
<pre><code>(let triple (fn (n)
  (let doubled (+ n n))
  (+ n doubled)))

(prn (triple 70)) ; prints 210
</code></pre>
<p>The body of a function establishes an &quot;implicit <code>do</code>&quot;, like the <code>do</code> special form. Each of
its body forms are evaluated one after the other, and the value of the final form is returned as 
the result of the function call. You can return early using the <a href="../std/return"><code>return</code> special 
form</a>.</p>
<p>By default, a function only accepts a fixed number of arguments:</p>
<pre><code>(prn (triple)) ; error: too few arguments
(prn (triple 1 2)) ; error: too many arguments
</code></pre>
<p>However, a fn's parameter list is a <a href="patterns.html#functions">pattern</a>. Among other things, this
allows you to describe an optional parameter with the special syntax <code>(? name default-val)</code>, or
capture zero or more arguments with the special syntax <code>..name</code>.</p>
<pre><code>(let sum-and-triple (fn (..nums)
  (* 3 (+ ..nums))))

(prn (sum-and-triple 10 20 30)) ; prints 180

(let print-multi (fn (item (? times 1))
  (forn (_ times)
    (pr item &quot; &quot;))
  (prn)))

(print-multi 'badgers) ; prints badgers 
(print-multi 'badgers 3) ; prints badgers badgers badgers 
</code></pre>
<p>Functions capture the <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scoping">lexical environment</a> at their definition site. This means that you don't
need to worry about local variables going out of scope:</p>
<pre><code>(let f (do
  (let captured 10)
  (fn ()
    captured)))

(prn (f)) ; prints 10, even though `captured` is out-of-scope
</code></pre>
<h1><a class="header" href="#macros" id="macros">Macros</a></h1>
<p>We've now described <a href="syntax-and-types.html">how GameLisp's parser converts text into data</a>, and 
<a href="evaluation.html">how GameLisp's evaluator executes data as code</a>.</p>
<p>To complete the picture, there's one more step that we need to discuss. Just before evaluating any
code, GameLisp's expander performs transformations on the code tree.</p>
<p>It's easy to hook in your own functions to customize the behaviour of the expander. These 
functions, which transform GameLisp data/code into different GameLisp data/code, are known as 
macros.</p>
<h2><a class="header" href="#the-expansion-algorithm" id="the-expansion-algorithm">The Expansion Algorithm</a></h2>
<p>This is the basic algorithm which GameLisp uses to expand a form in place:</p>
<ol>
<li>
<p>If the form is not an array, or if it's an empty array, then no expansion is performed.</p>
</li>
<li>
<p>Expand the array's first element in place.</p>
</li>
<li>
<p>If the array's first element is now a symbol, and that symbol is currently bound to a macro 
function, then invoke that macro function, passing in all of the array's elements as arguments. 
<strong>Replace the array with the result of the macro invocation</strong>, then restart from step 1.</p>
</li>
<li>
<p>If the array doesn't start with <a href="../std/quote"><code>quote</code></a>, expand each of its arguments in place, 
from left to right (starting with the array's second element, then moving on to its third 
element, and so on.)</p>
</li>
</ol>
<p>In simple terms, this algorithm traverses the entire source tree, looking for arrays which
resemble function calls. When the array's &quot;callee&quot; is a symbol which is bound to a macro,
that macro is called like a function, and then the entire array is replaced with the result of 
the call.</p>
<pre><code>; if the symbol `name` is bound to a macro, the expander will 
; invoke ((macro 'name) a b c), and then replace the (name a b c) 
; form with the result of that call.
(name a b c)
</code></pre>
<p>The <code>(splice)</code> macro is a special case: it's replaced by each of its argument forms, inserted 
next to one another in-place.</p>
<pre><code>(some-function (splice a) b (splice c d) (splice) e)

; after macro-expansion...
(some-function a b c d e)
</code></pre>
<h2><a class="header" href="#binding-macros" id="binding-macros">Binding Macros</a></h2>
<p>A macro is just a normal GameLisp function, of type <code>fn</code> or <code>rfn</code>. It takes zero or more
forms as its input, and produces one form as its output.</p>
<p>Like variables, macros can be bound globally or locally. To manipulate a symbol's global macro
binding, use the builtin functions <a href="../std/bind-macro-mut"><code>bind-macro!</code></a>, 
<a href="../std/del-macro-mut"><code>del-macro!</code></a>, <a href="../std/macro"><code>macro</code></a> and <a href="../std/set-macro"><code>macro=</code></a>.</p>
<p>To introduce a local macro binding, you can use the <a href="../std/let-macro"><code>let-macro</code> special form</a> 
wherever you would use <code>let</code>.</p>
<pre><code>; these two forms are similar, but the first form binds its
; fn to a local variable, and the second form binds its fn
; to a local macro.

(let add (fn (a b)
  (+ a b)))

(let-macro add (a b)
  (+ a b))
</code></pre>
<h2><a class="header" href="#example-when-and-unless" id="example-when-and-unless">Example: <code>when</code> and <code>unless</code></a></h2>
<p>Recall the syntax for the <code>if</code> special form: <code>(if condition then else)</code>.</p>
<p>This syntax is easy to understand when working with very small forms which fit onto a single line,
but when working with complicated multi-line forms, it's not always ideal.</p>
<pre><code>; at a glance, you might mistakenly think that this form will 
; print both lines when i is less than 100
(if (&lt; i 100)
  (prn &quot;first line&quot;)
  (prn &quot;second line&quot;))

; the do and #n forms here add a lot of visual noise
(if drawing-suppressed?
  #n
  (do
    (draw-rect x y w h)
    (draw-circle center-x center-y radius)))
</code></pre>
<p>This is exactly the type of problem which can be solved using macros: we have a small bit
of awkward, repetitive or confusing syntax, and we'd like to make it more clear.</p>
<p>The <code>when</code> macro is shorthand for &quot;if the condition is true, evaluate a <code>do</code> form; otherwise,
evaluate <code>#n</code>&quot;.</p>
<pre><code>(bind-macro! 'when (fn (condition-form ..do-forms)
  `(if ~condition-form
    (do
      ~..do-forms)
    #n)))

(when (&lt; i 100)
  (prn &quot;first line&quot;)
  (prn &quot;second line&quot;))
</code></pre>
<p>The <code>unless</code> macro is similar, but it evaluates the <code>do</code> form when its condition is false.</p>
<pre><code>(bind-macro! 'unless (fn (condition-form ..do-forms)
  `(if ~condition-form
    #n
    (do
      ~..do-forms))))

(unless drawing-suppressed?
  (draw-rect x y w h)
  (draw-circle center-x center-y radius))
</code></pre>
<h2><a class="header" href="#quasi-quotation" id="quasi-quotation">Quasi-quotation</a></h2>
<p>Our <code>when</code> and <code>unless</code> macro definitions introduced several <a href="syntax-and-types.html#abbreviations">unfamiliar pieces of 
syntax</a>: </p>
<ul>
<li><code>`x</code> is an abbreviation for <a href="../std/backquote"><code>(backquote x)</code></a></li>
<li><code>~x</code> is an abbreviation for <a href="../std/unquote"><code>(unquote x)</code></a></li>
<li><code>~..x</code> is an abbreviation for <a href="../std/splay"><code>(unquote (splay x))</code></a></li>
</ul>
<p>Recall that the <a href="../std/quote"><code>quote</code> special form</a>, abbreviated <code>'</code>, suppresses evaluation. 
If you want to produce a tree of nested arrays, then rather than constructing them 
element-by-element, it's much simpler to just write them down as text and <code>quote</code> them so that 
they're returned verbatim.</p>
<pre><code>; these two forms produce equivalent results

'((one eins) (two zwei) (three drei))

(arr (arr 'one 'eins) (arr 'two 'zwei) (arr 'three 'drei))
</code></pre>
<p><code>backquote</code> is like <code>quote</code>, but more powerful. </p>
<p>Firstly, <code>backquote</code> always allocates an entirely new, mutable array (whereas <code>quote</code> returns a 
shared, immutable array - this is usually more efficient, but it's not always what you want). It's
like a shorthand for the <a href="../std/arr"><code>(arr ...)</code> constructor</a>.</p>
<p>Secondly, <code>backquote</code> allows evaluated forms and quoted forms to be mixed with one another.
This is called &quot;quasi-quotation&quot;, because only part of the form is quoted. If you want some forms
within a backquote to be evaluated while building the array, prefix them with <code>~</code>. All other forms 
will be quoted.</p>
<pre><code>(let one-de 'eins)
(let two-de (fn () 'zwei))

; the following three forms all produce equivalent results

'((one eins) (two zwei) (three drei))

`((one ~one-de) (two ~(two-de)) (three ~(sym &quot;drei&quot;)))

(arr (arr 'one one-de) (arr 'two (two-de)) (arr 'three (sym &quot;drei&quot;)))
</code></pre>
<p>We briefly mentioned in the previous chapter that prefixing one of <code>arr</code>'s arguments with <code>..</code>
will cause the full contents of that argument to be &quot;splayed&quot; into the resulting arr. This is
particularly useful when working with <code>backquote</code> and <code>unquote</code>, as we demonstrated with
<code>when</code> and <code>unless</code> <a href="macros.html#example-when-and-unless">above</a>.</p>
<h2><a class="header" href="#macro-no-op" id="macro-no-op"><code>macro-no-op</code></a></h2>
<p>Within a macro, you can call the built-in function <code>(macro-no-op)</code>. This immediately cancels
execution of the macro, and it suppresses step 3 in the <a href="macros.html#the-expansion-algorithm">algorithm</a>. 
The current form is left as it is, and the algorithm proceeds to step 4, expanding the form's 
children as normal.</p>
<p>This enables the same name to be simultaneously bound both to a macro, and to a function or special
form. Without <code>(macro-no-op)</code>, it would be impossible for a macro to expand to a function call
which shares the same name, because it would trigger an endless loop: <code>(the-fn a b)</code> would expand 
to <code>(the-fn a b)</code> which would expand to <code>(the-fn a b)</code>... but <code>(macro-no-op)</code> breaks that cycle.</p>
<p>We've previously mentioned that the <code>let</code> special form can accept an arbitrary number of
arguments: with three or more arguments, it behaves like multiple consecutive calls to <code>let</code>.
This is actually achieved using a macro which is globally bound to the <code>let</code> symbol:</p>
<pre><code>; this form...
(let a b, c d)

; ...expands to this one:
(splice
  (let a b)
  (let c d))

; the `splice` macro can expand into multiple forms, so it becomes:
(let a b)
(let c d)

; each of those (let) forms also invokes the (let) macro, but when that
; macro is invoked with two or fewer arguments, it just calls (macro-no-op)
</code></pre>
<p>More generally, macros and variables occupy entirely different namespaces. A particular symbol
can be bound to a global variable, a macro, both, or neither. A local variable binding will not
shadow a local or global macro, and <code>let-macro</code> will not shadow a local or global variable.</p>
<h2><a class="header" href="#order-of-expansion" id="order-of-expansion">Order of Expansion</a></h2>
<p>There's a small problem with our expansion algorithm: if global macros are defined dynamically 
during evaluation, and if code is expanded before being evaluated, how is it that a global macro 
defined early in a source file can be used to expand code later on in that same source file?</p>
<pre><code>(bind-macro! 'fizz (fn ()
  `(prn &quot;fizz&quot;)))

; why can we use the 'fizz macro to expand this form?
(fizz)
</code></pre>
<p>It wouldn't be possible for us to interleave expansion with evaluation, because that would be
much too slow: we would need to re-expand every form every single time that it's evaluated. 
This would force GameLisp to be an <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)#Abstract_syntax_tree_interpreters">AST-walking interpreter</a>, making it many times slower 
than it is today. It's essential that we have a separate expansion step before evaluation.</p>
<p>We could set up the expander so that it's capable of detecting <code>bind-macro!</code> calls and evaluating
them during expansion, but that would mean that <code>bind-macro!</code> is no longer truly dynamic. Patterns
like this would stop working:</p>
<pre><code>(unless file-access-disabled?
  (bind-macro! 'write-file (fn (file content)
    `(stream-to-file ~file ~content))))
</code></pre>
<p>The solution is a simple compromise. When working their way through the forms in a GameLisp
source file, the expander and evaluator &quot;take turns&quot;. The first form is expanded; then the first 
form is evaluated; then the second form is expanded; then the second form is evaluated... and so 
on.</p>
<p>This means that a global macro binding can be used later on in the same source file, but it can't 
be used later on in the same toplevel form. If you want to define a macro to be used locally,
you should use <code>let-macro</code> instead.</p>
<pre><code>(do
  (bind-macro! 'fizz (fn ()
    `(prn &quot;fizz&quot;)))

  (fizz)) ; this doesn't work...

(fizz) ; ...but this does

(do
  (let-macro fizz ()
    `(prn &quot;fizz&quot;))

  (fizz)) ; ...and this does
</code></pre>
<h2><a class="header" href="#toplevel-scopes" id="toplevel-scopes">Toplevel Scopes</a></h2>
<p>Although evaluation and expansion do only process one toplevel form at a time, that's not the
whole story. If each toplevel form were completely separate from the next, it would be impossible
to use forms like <code>let</code> or <code>let-macro</code> at the toplevel.</p>
<p>We say that under some circumstances, a group of forms is processed in a &quot;toplevel scope&quot;. For
example, when loading a GameLisp source file, the toplevel scope continues until the end of 
that file. This means that a toplevel <code>let</code> form works exactly as you would expect.</p>
<h3><a class="header" href="#evaluation-apis" id="evaluation-apis">Evaluation APIs</a></h3>
<p>The function for running a GameLisp source file is called <a href="../std/load"><code>load</code></a>. It opens a source 
file, reads it into a string, parses that string into a series of forms, and expands and evaluates 
each form in the same toplevel scope.</p>
<p>GameLisp projects are likely to end up with a modular, branching tree of files: the source file 
<code>main.glsp</code> calls <code>(load &quot;engine.glsp&quot;)</code>, which calls <code>(load &quot;engine-drawing.glsp&quot;)</code>, and so on. 
In order to prevent the same source file from accidentally being loaded twice, we provide the 
function <a href="../std/require"><code>require</code></a>. If the current GameLisp runtime has already received a 
<code>require</code> call for the specified file, it silently does nothing. Otherwise, <code>require</code> is exactly 
the same as <code>load</code>.</p>
<p><a href="../std/eval"><code>eval</code></a> and <a href="../std/eval-multi"><code>eval-multi</code></a> are like <code>load</code>, but they receive 
their forms as arguments rather than parsing them from a string. <code>eval-multi</code> accepts an array of
forms, expanding and evaluating those forms one after the other, all in the same toplevel scope. 
<code>eval</code> is the same, but its argument is a single form rather than an array of forms.</p>
<h2><a class="header" href="#hygiene" id="hygiene">Hygiene</a></h2>
<p>If you've worked with Rust's <code>macro_rules!</code> macros, you'll know that they're <a href="https://en.wikipedia.org/wiki/Hygienic_macro">hygienic</a>: it's not 
possible for a macro to name a local variable from outside its own lexical scope, unless that 
name was passed in as one of the macro's arguments.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>macro_rules! unhygienic_macro {
	() =&gt; (println!(&quot;{}&quot;, local_name));
};

fn scope() {
	let local_name = 42;

	macro_rules! hygienic_macro {
		() =&gt; (println!(&quot;{}&quot;, local_name));
	};

	hygienic_macro!(); //prints 42
	unhygienic_macro!(); //error: cannot find value `local_name` in this scope
}
<span class="boring">}
</span></code></pre></pre>
<p>This is good for program correctness, but it can also be inconvenient. Because GameLisp values 
convenience very highly, GameLisp's macros are unhygienic.</p>
<p>The main risks when working with unhygienic macros are that you may unintentionally refer 
to a local variable when you mean to refer to a global one, or you may &quot;leak&quot; a local variable 
which is supposed to be private to the macro's implementation.</p>
<pre><code>; this macro checks that adding 1 to 2 produces 3 before executing a
; block of code. defensive programming!
(bind-macro! 'with-add-assertion (fn (..body)
  `(do
    (let tmp 1)
    (unless (== (+ tmp 2) 3) 
      (bail &quot;addition is broken!&quot;))
    ~..body)))

; prints 1 rather than 5: addition is broken, but we don't detect it 
; because `bail` is also broken!
(do
  (let + -)
  (let bail (fn (ignored) #n))
  (with-add-assertion
  	(let x 3)
    (prn (+ x 2))))

; the macro shadows `tmp`, printing 1 rather than the expected 7
(let tmp 7)
(with-add-assertion
  (prn tmp)) 
</code></pre>
<p>You can solve the first problem by explicitly accessing the global rather than local version
of a name. (However, this should rarely be necessary - it's unusual for a global name to be
shadowed by a local one, and when it does happen, it's something that the overrider probably
wants to affect <em>all</em> nested code, including code generated by macros.)</p>
<pre><code>(bind-macro! 'with-add-assertion (fn (..body)
  `(do
    (let tmp 1)
    (unless (== (+ tmp 2) 3) 
      ((global 'bail) &quot;addition is broken!&quot;))
    ~..body)))
</code></pre>
<p>The second problem is more insidious and important: macros often need to define temporary 
variables, and needing to come up with a unique name for each of them would be painful. This
is how the C preprocessor ended up with silly names like <code>__FILE__</code> and <code>__STDC_VERSION__</code>.</p>
<p>We solve this problem using <a href="../std/gensym"><code>gensym</code></a>, a built-in function which returns a unique 
symbol. If you use a fresh <code>gensym</code> for each local binding generated by a macro, you don't need 
to worry about accidentally shadowing the user's own variables:</p>
<pre><code>(bind-macro! 'with-add-assertion (fn (..body)
  (let temp-sym (gensym))

  `(do
    (let ~tmp-sym 1)
    (unless (== (+ ~tmp-sym 2) 3) 
      (bail &quot;addition is broken!&quot;))
    ~..body)))
</code></pre>
<p>This is such a common pattern that we have special syntax for it: when <code>backquote</code> detects
a quoted symbol which ends with <code>#</code>, it replaces each occurence of that symbol with the result
of a <code>(gensym)</code>.</p>
<pre><code>(prn `(foo# foo# bar#)) ; prints #&lt;gs:foo:0&gt; #&lt;gs:foo:0&gt; #&lt;gs:bar:1&gt; 

(bind-macro! 'with-add-assertion (fn (..body)
  `(do
    (let tmp# 1)
    (unless (== (+ tmp# 2) 3) 
      (bail &quot;addition is broken!&quot;))
    ~..body)))
</code></pre>
<h2><a class="header" href="#manual-expansion" id="manual-expansion">Manual Expansion</a></h2>
<p>You'll sometimes want to expand a form without immediately evaluating it. For example, when 
writing a macro, you might want to perform some processing on the expanded version of its
arguments, rather than the unexpanded version.</p>
<p>The built-in function <a href="../std/expand"><code>expand</code></a> takes a single value as its argument, recursively 
expands it according to the <a href="macros.html#the-expansion-algorithm">usual algorithm</a>, and then returns the 
expanded result.</p>
<p>On the other hand, <a href="../std/expand-1"><code>expand-1</code></a> gives you finer control over the expansion 
process by performing a single &quot;step&quot; of the expansion algorithm at a time. It also allows you 
to override the expansion function, and to detect when <a href="../std/macro-no-op"><code>macro-no-op</code></a>
is called.</p>
<h1><a class="header" href="#built-in-macros" id="built-in-macros">Built-in Macros</a></h1>
<p>In this chapter, we'll explore a few of the macros built in to GameLisp's standard library.</p>
<p>While reading through, bear in mind that none of these macros are doing anything which requires
special support from the runtime - if they didn't exist, it would be possible for you to implement
all of them yourself, using the information you learned in the <a href="macros.html">previous chapter</a>.</p>
<h2><a class="header" href="#control-flow" id="control-flow">Control Flow</a></h2>
<p>The <a href="macros.html#example-when-and-unless"><code>when</code> and <code>unless</code> macros</a> were introduced previously.</p>
<h3><a class="header" href="#while-loop-until" id="while-loop-until"><code>while</code>, <code>loop</code>, <code>until</code></a></h3>
<p><a href="../std/while"><code>while</code></a> and <a href="../std/loop"><code>loop</code></a> are similar to their Rust counterparts:</p>
<pre><code>(let i 0)
(while (&lt; i 5)
  (inc! i)
  (pr i &quot; &quot;)) ; prints 1 2 3 4 

(loop
  (prn &quot;around and around we go&quot;))
</code></pre>
<p><a href="../std/until"><code>until</code></a> is like <code>while</code>, but it terminates the loop when its condition is 
<a href="syntax-and-types.html#bool">&quot;truthy&quot;</a>, rather than stopping when it's 
<a href="syntax-and-types.html#bool">&quot;falsy&quot;</a>. We could rewrite the above <code>while</code> loop as:</p>
<pre><code>(let i 0)
(until (&gt;= i 5)
  (inc! i)
  (pr i &quot; &quot;)) ; prints 1 2 3 4 
</code></pre>
<p>The <a href="../std/break"><code>break</code></a> and <a href="../std/continue"><code>continue</code></a> macros work as they do in Rust. 
By default, all looping constructs return <code>#n</code>, but break-with-value is supported:</p>
<pre><code>(prn (loop
  (break 10))) ; prints 10
</code></pre>
<h3><a class="header" href="#and-or" id="and-or"><code>and</code>, <code>or</code></a></h3>
<p>The <a href="../std/and"><code>and</code></a> and <a href="../std/or"><code>or</code></a> macros provide lazy boolean evaluation, just like 
Rust's <code>&amp;&amp;</code> and <code>||</code> operators. </p>
<p><code>and</code> evaluates each of its arguments from left to right. If one of them returns a
<a href="syntax-and-types.html#bool">&quot;falsy&quot;</a> value, the <code>and</code> form returns that value and does not 
evaluate any more arguments. Otherwise, it returns the result of evaluating its rightmost 
argument.</p>
<p>Similarly, <code>or</code> evaluates each of its arguments from left to right, stopping as soon as it 
produces a <a href="syntax-and-types.html#bool">&quot;truthy&quot;</a> value.</p>
<h3><a class="header" href="#cond" id="cond"><code>cond</code></a></h3>
<p>The <a href="../std/cond"><code>cond</code></a> macro is reminiscent of Rust's <code>match</code>, but it's simpler. (GameLisp does
also have a full fledged <code>match</code> macro, which we'll discuss in a <a href="patterns.html">future 
chapter</a>.)</p>
<p><code>cond</code> receives a series of clauses, where the first form in each clause is a 
condition. It checks each condition in turn, evaluating the body of the first clause whose
condition is <a href="syntax-and-types.html#bool">&quot;truthy&quot;</a>, and returning the evaluation result of the
last form in that body.</p>
<pre><code>(cond
  (condition-0   ; if this condition is truthy...
    then-0)        ; this form is evaluated and returned
  (condition-1   ; otherwise, if this condition is truthy...
    then-1a        ; this form is evaluated, then...
    then-1b)       ; this form is evaluated and returned
  (condition-2)  ; otherwise, if this condition is truthy, it's returned
  (else          ; otherwise...
    then-e))       ; this form is evaluated and returned
</code></pre>
<p>The final clause's condition can be the symbol <code>else</code>, in which case the condition always
passes. If there is no <code>else</code> clause and none of the conditions are 
<a href="syntax-and-types.html#bool">&quot;truthy&quot;</a>, the <code>cond</code> form returns <code>#n</code>.</p>
<p>If a clause only contains a condition, without any other forms, then that clause's return
value is the result of evaluating the condition itself.</p>
<p>When a branching expression is long enough that it needs to be split across multiple lines,
and it has both a &quot;then&quot; branch and an &quot;else&quot; branch, it's good practice to use <code>cond</code> 
rather than <code>if</code>:</p>
<pre><code>; can be confusing
(if (eq? emotion 'angry)
  (draw 0 0 w h 'crimson)
  (draw 3 3 (- w 3) (- h 3) 'cerulean))

; more verbose, but easier to edit and less confusing
(cond
  ((eq? emotion 'angry)
    (draw 0 0 w h 'crimson))
  (else
    (draw 3 3 (- w 3) (- h 3) 'cerulean)))
</code></pre>
<h2><a class="header" href="#defining-globals" id="defining-globals">Defining Globals</a></h2>
<p>We introduced <code>bind-global!</code> in the <a href="evaluation.html#global-variables">Evaluation</a> chapter.
<code>bind-global!</code> is such a common operation that we provide a macro shorthand for it, 
<a href="../std/def"><code>def</code></a>.</p>
<pre><code>(def clip:door-open (load-clip &quot;door-open.mp3&quot;))

; ...is equivalent to...

(bind-global! 'clip:door-open (load-clip &quot;door-open.mp3&quot;))
</code></pre>
<p>Bear in mind that <code>bind-global!</code> will trigger an error if its global is already bound, so you
can't necessarily use <code>def</code> where you would use <code>let</code>. It's generally only used at the toplevel.</p>
<p><code>def</code>'s syntax is otherwise identical to <code>let</code>: it can accept three or more arguments
(equivalent to multiple consecutive <code>def</code> forms), and it performs <a href="patterns.html">destructuring</a> 
on its left-hand side.</p>
<p><a href="../std/defn"><code>defn</code></a> is a similar shorthand for defining global functions:</p>
<pre><code>(defn brew (cauldron)
  (push! cauldron 'eye-of-newt))

; ...is equivalent to...

(bind-global! 'brew (fn &amp;name brew (cauldron)
  (push! cauldron 'eye-of-newt)))
</code></pre>
<p>And we have <a href="../std/defmacro"><code>defmacro</code></a> for global macros:</p>
<pre><code>(defmacro with-pointy-hat (..body)
  `(do
    (put-on-hat)
    ~..body
    (remove-hat)))

; ...is equivalent to...

(bind-macro! 'with-pointy-hat (fn &amp;name with-pointy-hat (..body)
  `(do
    (put-on-hat)
    ~..body
    (remove-hat))))
</code></pre>
<p>In both cases, a <code>&amp;name</code> clause is used to assign a symbol as the function's name for debugging 
purposes. This means that <code>defn</code> and <code>defmacro</code> generally lead to a nicer debugging experience, 
compared to using <code>bind-global!</code> and <code>bind-macro!</code> directly.</p>
<h2><a class="header" href="#recursive-local-functions" id="recursive-local-functions">Recursive Local Functions</a></h2>
<p>Defining a local function which calls itself recursively can be awkward:</p>
<pre><code>(let recurse (fn (n)
  (cond 
    ((&gt; n 5)
      (recurse (- n 1)))
    (else
      (prn n)))))

(recurse 10.5) ; error: unbound symbol 'recurse'
</code></pre>
<p>The outer call to <code>recurse</code> works as expected, but the <code>let</code> binding is not in scope for the
recursive call, so it attempts to access a global variable named <code>recurse</code> instead.</p>
<p>The <a href="../std/let-fn"><code>let-fn</code> macro</a> solves this problem:</p>
<pre><code>(let-fn recurse (n)
  (cond 
    ((&gt; n 5)
      (recurse (- n 1)))
    (else
      (prn n))))

(recurse 10.5) ; prints 4.5
</code></pre>
<p>This works by initializing the local variable to <code>#n</code> first, and then immediately assigning the
function to it, so that the local binding is in scope throughout the function's body. It's 
equivalent to:</p>
<pre><code>(let recurse)
(= recurse (fn (n) ...))
</code></pre>
<h2><a class="header" href="#assignment" id="assignment">Assignment</a></h2>
<p>In GameLisp, all variables and collections are mutable by default.</p>
<p>The <a href="../std/set"><code>=</code> macro</a> can be used to assign a new value to a <strong>place</strong>. A place might be a 
global or local variable, an array element, a table value, or any number of other things.</p>
<p>Simple use of <code>=</code> looks like this:</p>
<pre><code>(let a 10, b 20, c 30)

(= a 40)
(= b 50, c 60)

(prn (+ a b c)) ; prints 150
</code></pre>
<p>When <code>=</code>'s first argument is a function call, it will inspect the name of the function, then 
replace the entire <code>=</code> form with a call to the corresponding &quot;setter&quot; function.</p>
<pre><code>(= (macro 'brew) (fn () #n))
(= (global 'cursed?) #t)

; ...is equivalent to...

(macro= 'brew (fn () #n))
(global= 'cursed? #t)
</code></pre>
<h3><a class="header" href="#naming-conventions" id="naming-conventions">Naming Conventions</a></h3>
<p>Functions which assign a value to some memory location are suffixed with <code>=</code>, while functions
which perform other kinds of mutation are suffixed with <code>!</code>.</p>
<pre><code>; reads as &quot;set the global cursed? to #t&quot;
(global= 'cursed? #t)

; reads as &quot;push the new-cat to the arr-of-cats&quot;
(push! arr-of-cats new-cat)

; reads as &quot;increment the cauldron-weight&quot;
(inc! cauldron-weight)
</code></pre>
<p>Where possible, it's good style to use the <code>=</code> macro, rather than calling a setter function 
directly. The <code>=</code> macro is easier to spot when visually scanning through the source code.</p>
<h3><a class="header" href="#in-place-mutation" id="in-place-mutation">In-Place Mutation</a></h3>
<p>It's a very common operation to read the value currently stored in a place, pass it to a function 
(perhaps with some other arguments), and then assign the function's return value to that same 
place. We provide a number of macros to make this easier.</p>
<pre><code>(let n 0)
(inc! n 5) ; add 5 to n
(mul! n 2 2 2) ; multiply n by 2, three times
(prn n) ; prints 40
</code></pre>
<p><a href="../std/inc-mut"><code>inc!</code></a>, <a href="../std/dec-mut"><code>dec!</code></a>, <a href="../std/mul-mut"><code>mul!</code></a>, 
<a href="../std/div-mut"><code>div!</code></a>, <a href="../std/div-euclid-mut"><code>div-euclid!</code></a>, <a href="../std/rem-mut"><code>rem!</code></a>, 
<a href="../std/rem-euclid-mut"><code>rem-euclid!</code></a>, <a href="../std/abs-mut"><code>abs!</code></a> and <a href="../std/clamp-mut"><code>clamp!</code></a> 
can be used to perform basic arithmetic in-place.</p>
<p>The <a href="../std/swap-mut"><code>(swap! a b)</code> macro</a> swaps the values stored in any two places.</p>
<pre><code>; the two places can be different from one another
(swap! my-local-var (global 'my-global-var))
(swap! [my-arr 0] [my-arr -1])
</code></pre>
<h2><a class="header" href="#arrows" id="arrows">Arrows</a></h2>
<p>The <a href="../std/arrow-first"><code>-&gt;</code></a> and <a href="../std/arrow-last"><code>-&gt;&gt;</code></a> macros perform a simple syntax 
transformation which can make deeply-nested function calls easier to read.</p>
<p>The <code>-&gt;</code> macro accepts a form followed by any number of arrays or symbols. The form is evaluated 
as normal, and it's then passed through a chain of function calls, where the return value of
each call acts as the first argument to the next call.</p>
<pre><code>(fourth (third (second (first a) b) c))

; ...could be refactored into...

(-&gt; (first a) (second b) (third c) fourth)

; ...which is equivalent to...

(do
  (let tmp-1 (first a))
  (let tmp-2 (second tmp-1 b))
  (let tmp-3 (third tmp-2 c))
  (fourth tmp-3))
</code></pre>
<p>The <code>-&gt;&gt;</code> macro is similar, except that it passes in each form's result as the <em>last</em> argument
to the following call, rather than its first argument.</p>
<pre><code>(fourth (third c (second b (first a))))

; ...could be refactored into...

(-&gt;&gt; (first a) (second b) (third c) fourth)

; ...which is equivalent to...

(do
  (let tmp-1 (first a))
  (let tmp-2 (second b tmp-1))
  (let tmp-3 (third c tmp-2))
  (fourth tmp-3))
</code></pre>
<p>When you have a several function calls deeply nested inside one other, it's usually possible to 
refactor them with either <code>-&gt;</code> or <code>-&gt;&gt;</code>. Having data flow from start to finish can be much 
easier to follow, compared to data which travels up and down a call-tree.</p>
<pre><code>(+ ..(map (fn (n) (* n 2)) (filter even? (arr 1 2 3 4))))

; ...could be refactored into...

(-&gt;&gt; 
  (arr 1 2 3 4)
  (filter even?)
  (map (fn (n) (* n 2)))
  ..+)
</code></pre>
<p>It's a little like a chain of method calls. In Rust, the above would be written as:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>[1, 2, 3, 4]
	.filter(is_even)
	.map(|n| n * 2)
	.sum()
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#numbers" id="numbers">Numbers</a></h1>
<p>Compared to other Lisps, GameLisp's numbers are relatively simple. A number may only be an <code>int</code>
(a 32-bit signed integer) or a <code>flo</code> (a 32-bit IEEE float). Rational fractions, arbitrary-precision 
integers and complex numbers are not supported.</p>
<p>The API for manipulating numbers is mostly unsurprising - the full list of functions is available
<a href="../std/numbers">here</a>. Some minor points:</p>
<ul>
<li>
<p>Bit manipulation is supported for integers.</p>
</li>
<li>
<p>We provide a simple random number generator.</p>
</li>
<li>
<p>There is a distinction between <code>sign</code> (which returns <code>0</code>, <code>1</code> or <code>-1</code> for any number) and
<code>flo‑sign</code> (which returns the sign of a float as <code>1.0</code>, <code>-1.0</code> or <code>nan.0</code>).</p>
</li>
</ul>
<p><span></span></p>
<pre><code>(prn (sign -0.0)) ; prints 0
(prn (flo-sign -0.0)) ; prints -1.0
</code></pre>
<h2><a class="header" href="#promotion-to-float" id="promotion-to-float">Promotion to Float</a></h2>
<p>Floats are &quot;contagious&quot;. When a function such as <a href="../std/add"><code>+</code></a> receives both an integer and a 
float among its arguments, the integer is promoted to a float before performing the operation, so 
the return value is always a float.</p>
<pre><code>(prn (+ 1 2 3 4)) ; prints 10
(prn (+ 1 2 3.0 4)) ; prints 10.0

(prn (/ 7 2)) ; prints 3
(prn (/ 7 2.0)) ; prints 3.5

(prn (% 5 1.5)) ; prints 0.5
</code></pre>
<p>Operations like <code>min</code> and <code>clamp</code> are the exception to the rule, because they return one of
their arguments unchanged.</p>
<pre><code>(prn (max 1 2 3.0 4)) ; prints 4
(prn (clamp 1.0 3 5.0)) ; prints 3
</code></pre>
<h2><a class="header" href="#nan" id="nan">NaN</a></h2>
<p>According to the IEEE 754 specification, all comparisons involving NaN floats should return 
false. This means that NaN floats are unequal to themselves, and they're neither less than nor 
greater than any other number.</p>
<p>This rule is inconvenient when sorting numbers, and when working with hash tables, priority
queues, and sorted arrays. GameLisp therefore imposes a total ordering on floats: NaN floats 
compare greater than all other floats (including positive infinity), and all NaN floats compare 
equal to all other NaN floats.</p>
<h2><a class="header" href="#wrapping-arithmetic" id="wrapping-arithmetic">Wrapping Arithmetic</a></h2>
<p>Integer arithmetic is always unchecked (wrapping), even when your crate is compiled in debug
mode.</p>
<pre><code>(prn (+ 1 2147483647)) ; prints -2147483648
</code></pre>
<p>This helps to keep the language simple. If GameLisp were to take Rust's approach to integer 
overflow, it would need to provide distinct APIs for normal, wrapping and checked arithmetic.
In Rust, this adds a <a href="https://doc.rust-lang.org/std/primitive.i32.html">large complexity burden</a> when working with integers.</p>
<p>GameLisp chose wrapping arithmetic over checked arithmetic in order to make fatal errors less 
likely. In game development, overflowing an entity's coordinates and getting a nonsensical value 
will usually be a minor bug, but overflowing an entity's coordinates and crashing the game's 
executable would be catastrophic.</p>
<h1><a class="header" href="#arrays" id="arrays">Arrays</a></h1>
<p>GameLisp's general-purpose sequential data structure is called an &quot;array&quot;, but it's actually
a <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>VecDeque</code></a>.</p>
<p>A <code>VecDeque</code> is a growable <a href="https://en.wikipedia.org/wiki/Circular_buffer">ring buffer</a>. It's very similar to a <code>Vec</code>, but with the added ability 
to push and pop items from the start of the sequence in constant time. (Note that a <code>VecDeque</code>
is very different from  a C++ <a href="https://en.cppreference.com/w/cpp/container/deque"><code>std::deque</code></a>, 
which has an odd memory-allocation pattern - <code>VecDeque</code> allocates all of its elements
in a single buffer, just like a <code>Vec</code>.)</p>
<h2><a class="header" href="#basic-functions" id="basic-functions">Basic Functions</a></h2>
<p>The <a href="../std/arr"><code>arr</code></a> function will return a new array which contains all of its arguments. 
When one of the arguments is an array, and that argument is prefixed with <code>..</code>, all of that 
array's elements are copied into the array which is being constructed. </p>
<pre><code>(prn (arr)) ; prints ()
(prn (arr 1 2 3 4)) ; prints (1 2 3 4)

(let src '(x y z))
(prn (arr 1 2 src 3 4)) ; prints (1 2 (x y z) 3 4)
(prn (arr 1 2 ..src 3 4)) ; prints (1 2 x y z 3 4)
(prn (arr ..src ..src)) ; prints (x y z x y z)
</code></pre>
<p><a href="../std/len"><code>len</code></a> returns the array's length, and <a href="../std/empty-p"><code>empty?</code></a> tests whether it 
has a length of 0.</p>
<pre><code>(prn (len '())) ; prints 0
(prn (len (arr 'a 'b))) ; prints 2

(prn (empty? (arr))) ; prints #t
(prn (empty? '(1))) ; prints #f
</code></pre>
<p>An array constructed using the <code>arr</code> function will be mutable. You can add any number of elements
to the start or end of an array using the functions <a href="../std/push-start-mut"><code>push-start!</code></a> and 
<a href="../std/push-mut"><code>push!</code></a>, or you can remove one element at a time using 
<a href="../std/pop-start-mut"><code>pop-start!</code></a> and <a href="../std/pop-mut"><code>pop!</code></a>.</p>
<pre><code>(let metals (arr 'pewter 'silver 'copper))

(push! metals 'iron 'bronze)
(prn metals) ; prints (pewter silver copper iron bronze)

(prn (pop! metals)) ; prints bronze
(prn (pop! metals)) ; prints iron
(prn (pop-start! metals)) ; prints pewter
(prn metals) ; prints (silver copper)

(push-start! metals 'titanium 'electrum)
(prn metals) ; prints (titanium electrum silver copper)
</code></pre>
<p>Many other useful functions are described in the <a href="../std/collections">standard library 
documentation</a>.</p>
<h2><a class="header" href="#indexing" id="indexing">Indexing</a></h2>
<p>The macro for looking up an element in any collection is called <a href="../std/access"><code>access</code></a>. 
To get the first element of an array, you might call <code>(access the-array 0)</code>.</p>
<p>Because <code>access</code> is such a fundamental operation, it can be
<a href="syntax-and-types.html#abbreviations">abbreviated</a> using square brackets. <code>(access the-array 0)</code>
would normally be written as <code>[the-array 0]</code> instead. Notice that this resembles the equivalent
Rust syntax: <code>the_array[0]</code>.</p>
<p>Negative indexes count backwards from the end of the array. <code>[names -1]</code> returns the last element
in the <code>names</code> array, and <code>[names -2]</code> returns its second-to-last element.</p>
<p>Array elements are <a href="built-in-macros.html#assignment">places</a>, so they can be mutated using the
<code>=</code> macro.</p>
<pre><code>(let blues (arr 'azure 'sapphire 'navy))

(prn [blues 2]) ; prints navy
(prn [blues -3]) ; prints azure

(= [blues 0] 'cerulean)
(= [blues -2] 'cobalt)

(prn blues) ; prints (cerulean cobalt navy)
</code></pre>
<h2><a class="header" href="#slicing" id="slicing">Slicing</a></h2>
<p>The <code>access</code> macro, and therefore the <code>[]</code> abbreviation, both support special syntax for accessing
multiple consecutive elements in an array. They use the <code>:</code> symbol, similar to Python's slice 
syntax.</p>
<pre><code>(let alphabet '(a b c d e f g h i j k l m n o p q r s t u v w x y z))

; elements from n to m are sliced using `n : m`
(prn [alphabet 3 : 8]) ; prints (d e f g h)
(prn [alphabet -10 : 21]) ; prints (q r s t u)
(prn [alphabet 5 : 5]) ; prints ()

; elements from 0 to n are sliced using `: n`
(prn [alphabet : 5]) ; prints (a b c d e)
(prn [alphabet : -23]) ; prints (a b c)
(prn [alphabet : 30]) ; an error

; elements from n to the end are sliced using `n :`
(prn [alphabet 23 :]) ; prints (x y z)
(prn [alphabet -1 :]) ; prints (z)

; the entire array can be sliced using `:`
(prn (eq? [alphabet :] alphabet)) ; prints #t

; the `:` symbol is whitespace-sensitive
(prn [alphabet 2:5]) ; an error
(prn [alphabet 3:]) ; an error
</code></pre>
<p>To keep things simple, all of these slicing operations will allocate, and return, a new array. 
Unlike Rust, there's no way to produce a reference which points into an array's interior.</p>
<p>The <a href="../std/del-mut"><code>del!</code></a> and <a href="../std/remove-mut"><code>remove!</code></a> macros also support the same 
slicing syntax.</p>
<pre><code>(del! names 3) ; delete element 3
(del! names 2 : 5) ; delete elements 2, 3 and 4
(del! names :) ; delete every element
</code></pre>
<p>A slice is a <a href="built-in-macros.html#assignment">place</a>. Assigning an array to a slice will overwrite
all of the elements stored there, changing the size of the array if necessary.</p>
<pre><code>(let numbers (arr 0 1 2 3 4 5 6 7 8 9))

(= [numbers : 6] '())
(prn numbers) ; prints (6 7 8 9)

(= [numbers -2 :] (arr 42 42 42))
(prn numbers) ; prints (6 7 42 42 42)

(= [numbers :] '(5 5 5))
(prn numbers) ; prints (5 5 5)
</code></pre>
<p>GameLisp doesn't include some of the traditional Lisp functions for processing sequences, like 
<code>rest</code>, <code>butlast</code>, <code>take</code> and <code>drop</code>. All of those functions can be expressed in a more versatile 
and general way using the slice syntax.</p>
<h2><a class="header" href="#arrows-1" id="arrows-1">Arrows</a></h2>
<p>Deeply-nested use of the <code>[]</code> syntax can sometimes be visually confusing.</p>
<pre><code>[[[the-array index] 0] start-index :]
</code></pre>
<p>&quot;Arrow macros&quot; were discussed in the <a href="built-in-macros.html#arrows">previous chapter</a>. The <code>[]</code>
syntax works well when used with the <code>-&gt;</code> macro:</p>
<pre><code>(-&gt; the-array [index] [0] [start-index :])
</code></pre>
<p>This is similar to the equivalent Rust syntax:</p>
<pre><code>the_array[index][0][start_index..]
</code></pre>
<h1><a class="header" href="#strings-and-text" id="strings-and-text">Strings and Text</a></h1>
<p>In GameLisp, a string is an array which can only store characters.</p>
<p>In fact, strings support the full array API described in the <a href="arrays.html">previous chapter</a>:
<code>len</code>, <code>push-start!</code>, <code>remove!</code>, indexing with integers, slicing, and so on. The only difference
is that assigning a non-character value to a string is an error.</p>
<p>This enables you to write code which is generic over both strings and arrays. For example,
a function which reverses a string or array in-place:</p>
<pre><code>(defn rev! (deq)
  (ensure (deque? deq))

  (forn (i (/ (len deq) 2))
    (swap! [deq i] [deq (- i)]))

  deq)
</code></pre>
<p>Notice that we test for the type <code>deque</code>, which is the <a href="syntax-and-types.html#type-summary">abstract type</a> 
implemented by anything which supports an array-like interface. For a string, 
<a href="../std/arr-p"><code>arr?</code></a> would return <code>#f</code>, but <a href="../std/deque-p"><code>deque?</code></a> returns <code>#t</code>.</p>
<h2><a class="header" href="#string-storage" id="string-storage">String Storage</a></h2>
<p>Because our double-ended queue API requires constant-time random access, we can't encode 
strings using UTF-8: locating the nth character in a UTF-8 string is an <code>O(n)</code> operation.</p>
<p>Instead, we take a leaf out of <a href="https://www.python.org/dev/peps/pep-0393/">Python's</a> book.
By default, a string will use a <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>VecDeque&lt;u8&gt;</code></a> for its backing storage. The first time a 
character with a scalar value above <code>255</code> is assigned to the string, it switches to a 
<code>VecDeque&lt;u16&gt;</code>. Similarly, any scalar value above <code>65535</code> will cause the storage to be 
converted to a <code>VecDeque&lt;char&gt;</code>.</p>
<p>This scheme has good performance characteristics. When compared to UTF-8, it typically uses 
equal or less storage, except when a string contains text from multiple scripts. Each string will 
change its character width at most two times; strings which only contain ASCII and the 
<a href="https://en.wikipedia.org/wiki/List_of_Unicode_characters#Latin-1_Supplement">Latin-1 Supplement</a> will never change their character width; and most non-Latin strings will 
typically change their character width zero or one times, rather than two.</p>
<h2><a class="header" href="#converting-values-to-strings" id="converting-values-to-strings">Converting Values to Strings</a></h2>
<p>Any value can be converted to text using the <a href="../std/str"><code>str</code> function</a>. It accepts zero or more 
arguments; inserts spaces between adjacent non-character, non-string arguments; converts each 
of those arguments to text; and returns the concatenation of all of the arguments' text as a 
newly-allocated, mutable string.</p>
<pre><code>(str)                      ; &quot;&quot;
(str \a \b \c)             ; &quot;abc&quot;
(str 1 2 3)                ; &quot;1 2 3&quot;: note the spaces
(str 1 &quot; &quot; 2 &quot; &quot; 3)        ; &quot;1 2 3&quot;: equivalent to the previous call
(str &quot;hello&quot; \w &quot;or&quot; &quot;ld&quot;) ; &quot;helloworld&quot;: no spaces added between strs/chars
</code></pre>
<p>This is also how <a href="../std/pr"><code>pr</code></a> and <a href="../std/prn-fn"><code>prn</code></a> process their arguments. <code>prn</code> 
appends a UNIX-style line ending, <code>&quot;\n&quot;</code>, to its output.</p>
<p>The <a href="../std/sym"><code>sym</code></a> function is similar to <code>str</code>, but it doesn't insert spaces between any of 
its arguments, and it converts the result into a symbol. It's an error if the string is empty, or 
if it contains anything other than the <a href="syntax-and-types.html#sym">valid symbol characters</a>. You can
test this using the functions <a href="../std/valid-sym-char-p"><code>valid-sym-char?</code></a> and
<a href="../std/valid-sym-str-p"><code>valid-sym-str?</code></a>.</p>
<pre><code>(valid-sym-str? &quot;&quot;) ; #f
(valid-sym-str? &quot;hello-world&quot;) ; #t
(valid-sym-str? &quot;hello world&quot;) ; #f
(valid-sym-str? &quot;42.42&quot;) ; #t

(prn (sym &quot;suffixed-&quot; 100)) ; prints suffixed-100
(prn (sym &quot;*invalid()\ncharacters[]&quot;)) ; an error
</code></pre>
<p>We also support <a href="syntax-and-types.html#abbreviations">template strings</a>. A template string evaluates 
to a newly-allocated, mutable string with values printed into it. It's like the <code>format!()</code>
macro in Rust, but more convenient.</p>
<pre><code>(let arg 2)
(prn &quot;1 + {arg} = {(+ 1 arg)}&quot;) ; prints 1 + 2 = 3

; within curly braces, adjacent values are separated by spaces
(prn &quot;{(+ 1 1) (+ 1 2)} 4 {(+ 1 4)}&quot;) ; prints 2 3 4 5
</code></pre>
<p>Finally, you'll sometimes want to customize how numbers are printed. 
<a href="../std/int-to-str"><code>(int-&gt;str i radix)</code></a> will convert an integer to a string with the given 
radix, and <a href="../std/flo-to-str"><code>(flo-&gt;str f places)</code></a> will convert a floating-point number to a 
string with the given number of digits after the decimal point.</p>
<h2><a class="header" href="#non-representable-values" id="non-representable-values">Non-Representable Values</a></h2>
<p>In the first chapter of this section, we mentioned <a href="syntax-and-types.html#representable-types">representable values</a>. A representable value
is one which can be converted to a string, and then parsed back from that string, with no loss of
information.</p>
<p>It's still possible to print non-representable values, or convert them to a string. The printer
will usually prefix them with <code>#&lt;</code> and suffix them with <code>&gt;</code>, to make it obvious that they can't be
parsed.</p>
<pre><code>(prn (gensym)) ; prints #&lt;gs:0&gt;
(prn (arr type-of +)) ; prints (#&lt;rfn:type-of&gt; #&lt;rfn:+&gt;)
(prn (fn () #n)) ; prints #&lt;fn&gt;
</code></pre>
<h2><a class="header" href="#parsing-and-unparsing" id="parsing-and-unparsing">Parsing and Unparsing</a></h2>
<p>The parser can be invoked manually using the <a href="../std/parse-all"><code>parse-all</code></a> function, which 
receives a string as its argument, and returns an array of all of the values parsed from that 
string. It's an error if the string contains invalid syntax.</p>
<p>When you know that the input contains exactly one form, <a href="../std/parse-1"><code>parse-1</code></a> will parse
and return that form.</p>
<pre><code>(parse-all &quot;1 (a b)&quot;) ; returns the array (1 (a b))
(parse-all &quot;hello&quot;) ; returns the array (hello)
(parse-1 &quot;hello&quot;) ; returns the symbol hello
</code></pre>
<p>You'll sometimes have data which you want to store as text and then read back in later - for
example, in a savegame or a configuration file. Under those circumstances, it's important that
the data is representable. You'll need to avoid the following:</p>
<ul>
<li>Values which belong to a non-representable type, such as functions or iterators</li>
<li>A reference cycle, which would cause the printer to get stuck in an endless loop</li>
<li>Symbols like <code>-10</code> or <code>..name</code>, which will be read back in as numbers or abbreviations</li>
<li>Symbols generated using <a href="../std/gensym"><code>gensym</code></a>, including <a href="../std/backquote"><code>backquote</code></a>'s 
<code>auto-gensym#</code> feature</li>
</ul>
<p>You'll also need to double-quote and escape strings, and convert characters to their literal 
representation, i.e. printing the string <code>&quot;\a&quot;</code> rather than the character <code>\a</code>.</p>
<p>Checking all of these conditions every time would be tedious, so we provide a function
<a href="../std/unparse"><code>unparse</code></a> which does the work for you. It's similar to <code>str</code>, but it guarantees 
that if the resulting string is passed to <code>parse-all</code>, the parsed values will be equal
to <code>unparse</code>'s arguments.</p>
<pre><code>(prn (unparse &quot;w&quot; \x (arr 'y 'z))) ; prints &quot;w&quot; \x (y z)
(prn (str &quot;w&quot; \x (arr 'y 'z))) ; prints wx(y z)

(let non-repr-sym (sym &quot;42&quot;))
(prn (str non-repr-sym)) ; prints 42
(prn (unparse non-repr-sym)) ; an error
</code></pre>
<h2><a class="header" href="#output-streams" id="output-streams">Output Streams</a></h2>
<p>By default, <code>pr</code> and <code>prn</code> send their output to the standard output stream.</p>
<p>We also provide <a href="../std/epr"><code>epr</code></a> and <a href="../std/eprn"><code>eprn</code></a>, which are identical except that 
their output goes to the standard error stream.</p>
<p>It's possible for the host Rust program to customize these functions so that they send their
output somewhere else - we'll discuss that in <a href="the-glsp-crate.html#output-streams">Section 2</a>.</p>
<h2><a class="header" href="#pretty-printing" id="pretty-printing">Pretty-Printing</a></h2>
<p>Although GameLisp's syntax is easy enough to write, the raw data is not very pleasant to read 
when printed:</p>
<pre><code>(prn '(cond
  ((&gt;= (len ar) 2)
    (run [ar 0] [ar 1]))
  (else
    (run [ar 0]))))

; prints (cond ((&gt;= (len ar) 2) (run [ar 0] [ar 1])) (else (run [ar 0])))
</code></pre>
<p>GameLisp comes with a simple pretty-printer which attempts to format data/code with reasonable
whitespace. It's not gold-standard, but it's usually good enough for debugging.</p>
<pre><code>(pretty-prn '(cond
  ((&gt;= (len ar) 2)
    (run [ar 0] [ar 1]))
  (else
    (run [ar 0]))))

#|
  prints:

  (cond
    ((&gt;= (len ar) 2) (run [ar 0] [ar 1]))
    (else (run [ar 0])))
|#
</code></pre>
<p>All of the pretty-printing functions only accept a single value, which they convert to a pretty
string with no leading or trailing whitespace. Those functions are 
<a href="../std/pretty-str"><code>pretty‑str</code></a>, <a href="../std/pretty-unparse"><code>pretty‑unparse</code></a>, 
<a href="../std/pretty-prn"><code>pretty‑prn</code></a> and <a href="../std/pretty-eprn"><code>pretty‑eprn</code></a>.</p>
<h1><a class="header" href="#tables" id="tables">Tables</a></h1>
<p>GameLisp's main associative data structure is the table. Tables are <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMaps</code></a> which can use 
arbitrary GameLisp data for their keys.</p>
<p>The basic operations are similar to those for an <a href="arrays.html">array</a>. You can read or write table
entries using square brackets, <code>[tbl key]</code>. Assignment will create an entry if it doesn't already
exist. The <a href="../std/has-p"><code>has?</code></a> function will tell you whether a key is already present, and 
the <a href="../std/del-mut"><code>del!</code></a> and <a href="../std/remove-mut"><code>remove!</code></a> functions will delete an existing 
entry. <a href="../std/len"><code>len</code></a>, <a href="../std/empty-p"><code>empty?</code></a> and <a href="../std/clear-mut"><code>clear!</code></a> all work 
as expected.</p>
<pre><code>(let strengths (tab))
(= [strengths 'goblin] 3)
(= [strengths 'dragon] 8)

(prn (has? strengths 'goblin)) ; prints #t
(prn (has? strengths 'kobold)) ; prints #f

(prn [strengths 'goblin]) ; prints 3
(prn [strengths 'manticore]) ; an error

(prn (len strengths)) ; prints 2
(clear! strengths)
(prn (empty? strengths)) ; prints #t
</code></pre>
<h2><a class="header" href="#table-construction" id="table-construction">Table Construction</a></h2>
<p>Recall that the syntax for table literals is <code>#((key0 value0) (key1 value1))</code>.</p>
<p>To construct a new table dynamically, you can use the <code>tab</code> macro. It receives a number of array 
forms of length two, and optionally a number of forms which evaluate to tables, each prefixed 
with <code>..</code>. Each array form, and each entry from each of the tables, is treated as a <code>(key value)</code> 
pair which is inserted into the table.</p>
<pre><code>(let basic (tab ('a 'b) ('c 'd)))
(let more (tab ('e 'f) ..basic))

(prn more) ; prints #((a b) (c d) (e f)), not necessarily in that order
</code></pre>
<p>The <a href="../std/extend-mut"><code>extend!</code></a> function receives a table as its first argument, followed by 
any number of <code>(key value)</code> two-element arrays. Those key-value pairs are each inserted into the 
table, overwriting elements which already exist. It's typically used to copy the full contents of 
one table into another, by treating the source table as an <a href="iterators.html">iterator</a>:</p>
<pre><code>(extend! dst-table ..src-table)
</code></pre>
<h2><a class="header" href="#nonexistent-elements" id="nonexistent-elements">Nonexistent Elements</a></h2>
<p>GameLisp is normally very strict when it comes to whether or not an element of a collection
exists. If you attempt to access a nonexistent table entry (or a nonexistent global, array index, 
object field, class field, or function parameter), it's an error.</p>
<p>This is in contrast to some other scripting languages, which return <code>nil</code> or <code>undefined</code> for
nonexistent elements. I find that this is not a sensible default: it can cause errors to
silently propagate, making refactoring and debugging more difficult.</p>
<p>If you need to access an element which may or may not exist, various macros support the special
syntax <code>(? form)</code>. This syntax can be used in place of a key or an index. It will cause the 
operation to succeed and return <code>#n</code> when an element is missing, rather than triggering an error.</p>
<pre><code>(let heights (tab ('mira 165) ('paul 178)))

(prn [heights 'sara]) ; an error
(prn [heights (? 'sara)]) ; prints #n

(let ar (arr 10 20 30 40 50))

(= [ar -8] -20) ; an error
(= [ar (? -8)] -20) ; a silent no-op

(prn (remove! ar 2)) ; prints 30
(prn (remove! ar 7)) ; an error
(prn (remove! ar (? 7))) ; prints #n

(prn (global (? 'possibility))) ; prints #n
(bind-global! 'possibility 100)
(prn (global (? 'possibility))) ; prints 100
</code></pre>
<h2><a class="header" href="#key-equivalence" id="key-equivalence">Key Equivalence</a></h2>
<p>All hash tables need to enforce an <a href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence relation</a> on their keys. They use this equivalence
relation to establish whether, when key B is inserted into the table, it should overwrite the entry
previously created for key A.</p>
<p>Our hash tables can use any GameLisp data as a key, including <code>#n</code> and NaN floats. The equivalence 
relation is represented by the function <a href="../std/keys-eqv-p"><code>keys-eqv?</code></a>. This function is very 
similar to <a href="miscellaneous.html#equality"><code>eq?</code></a>, with a few small changes:</p>
<ul>
<li>
<p>Numbers and characters act as distinct keys, even if they're numerically equal.
<code>65</code>, <code>65.0</code> and <code>\A</code> are all <code>==</code> to one another, but they're not key-equivalent.</p>
</li>
<li>
<p>For performance reasons, tables have to be compared for key-equivalence using 
<a href="../std/same-p"><code>same?</code></a> rather than <a href="../std/eq-p"><code>eq?</code></a>. This means that two tables can have 
identical contents, but still be considered distinct when used as table keys.</p>
</li>
<li>
<p>Objects and Rust data can overload <code>eq?</code>, but there's no way to overload <code>keys-eqv?</code>.</p>
</li>
</ul>
<p>Otherwise, table keys mostly work as you would expect. Arrays and strings are key-equivalent when
they have the same contents. Other reference types are key-equivalent when they refer to the
same object. Value types are equivalent when they have the same type and the same contents.</p>
<h1><a class="header" href="#iterators" id="iterators">Iterators</a></h1>
<p>Rust's iterators are a joy to use. They often enable you to replace a dozen lines of imperative
code with a single line of declarative code, without obscuring your program's meaning.</p>
<p>This kind of expressiveness seemed like a great fit for GameLisp, so the language comes with an
iterator library which is, for the most part, shamelessly copied from Rust. (To be fair, Rust 
originally copied many of its iterator APIs from Python...)</p>
<pre><code>(let text &quot;Revered. Exalted. Wise.&quot;)

(for word in (-&gt;&gt; (split text \space) (rev) (map uppercase))
  (pr word &quot; &quot;)) ; prints WISE. EXALTED. REVERED. 
</code></pre>
<h2><a class="header" href="#iteration" id="iteration">Iteration</a></h2>
<p>The <a href="syntax-and-types.html#type-summary"><code>iter</code> primitive type</a> is like a Rust <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a>,
except that it's dynamically typed and heap‑allocated. (Don't panic! GameLisp is smart enough
to reuse an iterator's heap storage when you're done with it, so the allocation is very cheap.)</p>
<p>The simplest way to allocate a new iterator is by calling <a href="../std/iter"><code>(iter x)</code></a>, where <code>x</code> is 
some kind of collection or sequence. We say that if something can be passed to the <code>iter</code> 
function, it belongs to the <a href="syntax-and-types.html#abstract-types"><code>iterable</code> abstract type</a>. 
The following types are iterable:</p>
<ul>
<li>Arrays iterate over their elements.</li>
<li>Strings iterate over their characters.</li>
<li>Tables iterate over their entries as <code>(key value)</code> pairs. Each pair is a newly-allocated, 
two-element array.
<ul>
<li>Alternatively, you can use the <a href="../std/keys"><code>(keys tbl)</code></a> function to iterate over a 
table's keys, or the <a href="../std/values"><code>(values tbl)</code></a> function to iterate over its values.</li>
</ul>
</li>
<li>Coroutines will be discussed in the <a href="coroutines.html">next chapter</a>.</li>
<li>Passing an iterator to <code>(iter x)</code> is the identity operation - it just returns <code>x</code>.</li>
</ul>
<p>To advance an iterator and return its next item, use the <a href="../std/iter-next-mut"><code>iter-next!</code> 
function</a>. If the iterator has no more items, it will return <code>#n</code>.</p>
<p>However, you can't assume that an iterator is finished just because it's returned <code>#n</code> - if so, 
iteration over the array <code>(1 2 #n 4 5)</code> would stop after the first two items! Instead, you should 
use the function <a href="../std/iter-finished-p"><code>iter-finished?</code></a>. If it returns <code>#t</code>, then the iterator 
has no more items, and the previous <code>#n</code> item should be discarded.</p>
<h3><a class="header" href="#the-for-macro" id="the-for-macro">The <code>for</code> Macro</a></h3>
<p>GameLisp comes with a <a href="../std/for"><code>for</code> macro</a>, which is very similar to Rust's <code>for</code> loop. It 
takes an iterable, and evaluates its body once for each item produced by the iterable, binding 
that item to a <a href="patterns.html">pattern</a>. <a href="../std/break"><code>break</code></a> and <a href="../std/continue"><code>continue</code></a> 
work as expected.</p>
<pre><code>(for element in '(1 2 3 4 5)
  (prn (* element 10)))

(for (key value) in table
  (ensure (sym? key))
  (prn &quot;{key}: {value}&quot;))
</code></pre>
<p><code>for</code> isn't doing anything special - it just invokes the <code>iter</code>, <code>iter-next!</code> and <code>iter-finished?</code>
functions.</p>
<h2><a class="header" href="#standard-iterators" id="standard-iterators">Standard Iterators</a></h2>
<p>GameLisp comes with a large library of built-in iterators. Almost all of Rust's standard
iterators are included: <a href="../std/enumerate"><code>enumerate</code></a>, <a href="../std/zip"><code>zip</code></a>, <a href="../std/map"><code>map</code></a>, 
<a href="../std/lines"><code>lines</code></a>, and so on. You can take a look at <a href="../std/iterators">the standard library 
documentation</a> for the full list.</p>
<p>Unlike Rust, GameLisp's <a href="../std/once"><code>once</code></a> and <a href="../std/repeat"><code>repeat</code></a> iterators can accept 
multiple arguments. If you want an empty iterator which won't produce anything, just call 
<code>(once)</code> with no arguments.</p>
<p><a href="../std/rn"><code>rn</code></a> counts upwards from one number to another. <code>(rn 5 10)</code> is equivalent to the Rust
iterator <code>5 .. 10</code>, and <code>(rn 8)</code> is equivalent to <code>0 .. 8</code>. If you need an inclusive upper bound,
you can use <a href="../std/rni"><code>rni</code></a>: <code>(rni -5 5)</code> is equivalent to <code>-5 ..= 5</code>.</p>
<p>Because <code>rn</code> is such a common iterator, we provide the <a href="../std/forn"><code>forn</code> macro</a> to make it more
convenient to use. (<code>forn</code> should be read as a contraction of <code>for rn</code>, in the same way that
<code>defn</code> is a contraction of <code>def fn</code>.)</p>
<pre><code>(forn (digit 0 10)
  (prn digit))

; ...is equivalent to...

(for digit in (rn 0 10)
  (prn digit))
</code></pre>
<h3><a class="header" href="#double-ended-iterators" id="double-ended-iterators">Double-Ended Iterators</a></h3>
<p>Some iterators are &quot;double-ended&quot;: items can be produced both from their back and from their
front. For example, array and string iterators are double-ended. You can query whether an iterator
is double-ended using the <a href="../std/iter-double-ended-p"><code>iter-double-ended?</code></a> function, and you can 
produce items from the back of a double-ended iterator using 
<a href="../std/iter-next-back-mut"><code>iter-next-back!</code></a>.</p>
<p><a href="../std/rev"><code>rev</code></a> takes a double-ended iterable and reverses it, treating its back as its front 
and its front as its back.</p>
<h3><a class="header" href="#exact-size-iterators" id="exact-size-iterators">Exact-Size Iterators</a></h3>
<p>Some iterators know more about their length than others do. For example, a <code>rn</code> iterator knows
the exact number of items it will return, but a <code>lines</code> iterator has no way to predict its item 
count in advance.</p>
<p>We don't provide an equivalent to Rust's <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.size_hint"><code>size_hint()</code></a>, because it wouldn't be useful. 
GameLisp doesn't provide any way for you to manipulate the capacity of its collections or reserve
memory in advance.</p>
<p>Instead, the <a href="../std/len"><code>len</code></a> function can accept an iterator as its argument. If that iterator
knows its exact length, it returns an integer; if it knows itself to be infinite, it returns the
symbol <code>infinite</code>; and otherwise it returns the symbol <code>unknown</code>.</p>
<pre><code>(prn (len (rn 5))) ; prints 5
(prn (len (repeat #t))) ; prints infinite
(prn (len (split text \space))) ; prints unknown
</code></pre>
<p>There's nothing to prevent an array or string from being mutated during iteration (although
this is strongly discouraged). This means that array and string iterators do not know their exact 
size. Pushing or popping from the end of a deque during iteration will work as expected, but 
pushing or popping from the start may cause the iterator to behave unpredictably.</p>
<h2><a class="header" href="#splaying" id="splaying">Splaying</a></h2>
<p>We've previously mentioned that you can use <a href="../std/splay-abbrv"><code>..</code></a>, an abbreviation for
<a href="../std/splay"><code>splay</code></a>, to pass all of an array's elements to the array constructor.</p>
<pre><code>(let triad '(x y z))
(prn (arr 'a 'b 'c ..triad 1 2 3)) ; prints (a b c x y z 1 2 3)
</code></pre>
<p>The splay operator is actually much more powerful than this. It will accept <em>any</em> iterable, 
and pass all of its items as arguments to <em>any</em> function call.</p>
<p>This means that there's no need for GameLisp to have a <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect"><code>collect</code></a> function: you can just splay
an iterator while calling <a href="../std/arr"><code>arr</code></a>, <a href="../std/str"><code>str</code></a>, <a href="../std/tab"><code>tab</code></a>, or any 
other constructor function.</p>
<pre><code>(prn (str ..(take 5 (repeat \A)))) ; prints AAAAA
</code></pre>
<p>There's also no need for GameLisp to have <a href="http://clhs.lisp.se/Body/f_apply.htm"><code>apply</code></a>: you 
can just splay an array as a function's last argument instead.</p>
<p>If you want to take the sum of an array of numbers, there's no need to look up the API for <code>fold</code>.
Addition is a variadic function, so you can just call <code>(+ ..the-array)</code>. The smallest element of
a collection is <code>(min ..coll)</code>. To test whether an array of numbers is sorted, call 
<code>(&lt;= ..numbers)</code>. Appending the contents of one array onto another is just <code>(push! arr0 ..arr1)</code>.</p>
<h2><a class="header" href="#indexing-1" id="indexing-1">Indexing</a></h2>
<p>Arrays, strings, objects and classes are normally indexed using an integer or a symbol. However,
it's possible to index them using an iterable instead.</p>
<p>This returns a new iterator which takes each item in turn from the original iterable, indexes
the collection using <a href="../std/access"><code>[coll item]</code></a>, and produces the resulting element.</p>
<p>In effect, <code>[coll iterable]</code> is equivalent to <a href="../std/map"><code>(map (fn1 [coll _]) iterable)</code></a>.</p>
<pre><code>; re-order an array's elements
(let shuf (arr ..[src-arr '(1 3 0 2)]))

; equivalent to...
(let shuf (arr [src-arr 1] [src-arr 3] [src-arr 0] [src-arr 2]))

; swizzle an object's fields
(let offset (Vec3 x y z))
(let swizzled (Vec3 ..[offset '(y z x)]))

; discard every second character in a string
(let text &quot;You're filled with DETERMINATION.&quot;)
(prn ..[text (step-by 2 (rn (len text)))]) ; prints Yur ildwt EEMNTO.

; use multiple object fields as consecutive function arguments
(draw-sprite spr ..[very-long-coordinates-name '(x y)])

; equivalent to...
(draw-sprite spr [very-long-coordinates-name 'x] [very-long-coordinates-name 'y])
</code></pre>
<p>Note that tables do not support this kind of indexing. This is because table keys can belong
to any primitive type, including iterators, arrays, strings, and so on. If you were to call
<code>[table '(0 0 0)]</code>, it would be ambiguous whether you were trying to access the key <code>(0 0 0)</code>
once, or trying to access the key <code>0</code> three times.</p>
<h2><a class="header" href="#arrows-2" id="arrows-2">Arrows</a></h2>
<p>Creating a complicated iterator might involve several deeply-nested function calls.</p>
<p>As ever, the <a href="built-in-macros.html#arrows">arrow macros</a> are the best way to flatten out
a deep call hierarchy. <code>-&gt;&gt;</code> is often a good choice when working with iterators,
because <a href="../std/iterators#iterator-adapters">iterator adapters</a> usually expect an iterator or 
iterable as their last argument.</p>
<pre><code>(-&gt;&gt; my-array (step-by 3) (map (fn1 (+ _ 10))) enumerate)

; ...is equivalent to...

(enumerate (map (fn1 (+ _ 10)) (step-by 3 my-array)))
</code></pre>
<p>The arrow macros include special handling for the splay operator. If you prefix one of the 
arrowed function calls with <code>..</code>, then the result of the previous function will be splayed.</p>
<pre><code>(-&gt;&gt; my-array (step-by 3) (map abs) (filter (fn1 (&lt; _ 10))) ..arr)

; ... is equivalent to...

(arr ..(filter (fn1 (&lt; _ 10)) (map abs (step-by 3 my-array))))
</code></pre>
<h1><a class="header" href="#coroutines" id="coroutines">Coroutines</a></h1>
<p>A coroutine is a function which can be paused, and later on resumed from where it left off.</p>
<p>Coroutines are defined using the <a href="../std/yield"><code>yield</code></a> special form. When <code>yield</code> is encountered 
within a function, that function pauses its execution, and control flow returns to the caller. 
Later, <a href="../std/coro-run"><code>coro-run</code></a> can be used to resume the coroutine, which causes execution 
to restart from the <code>yield</code> form.</p>
<pre><code>(defn example+ ()
  (pr &quot;first &quot;)
  (yield)
  (prn &quot;third&quot;))

; invoking a function which contains a (yield) does not start its execution.
; instead, it returns a coroutine which is paused at the start of the
; function's body.
(let coroutine (example+))

(coro-run coroutine) ; executes up until the yield
(pr &quot;second &quot;)
(coro-run coroutine) ; executes from the yield to the end of the function

; the above code prints: first second third
</code></pre>
<p>Coroutines can pass values back and forth to their caller when they are paused and resumed.
<code>(yield x)</code> causes the value <code>x</code> to be returned from the <code>(coro-run ...)</code> call. 
<code>(coro-run coroutine y)</code> causes the value <code>y</code> to be returned from the <code>(yield)</code> call. In both 
cases, when no value is specified it defaults to <code>#n</code>.</p>
<pre><code>; this coroutine returns values to its caller. note that coroutines can
; receive arguments, just like a normal function call
(defn increment-forever+ (n)
  (loop
    (yield n)
    (inc! n)))

(let co (increment-forever+ 100))

(prn (coro-run co)) ; prints 100
(prn (coro-run co)) ; prints 101
(prn (coro-run co)) ; prints 102

; this coroutine receives values from its caller
(defn overly-elaborate-prn+ ()
  (loop
    (prn (yield))))

(let co (overly-elaborate-prn+))
(coro-run co) ; run until the first (yield)...

(coro-run co 'alpha) ; the coroutine prints alpha
(coro-run co 'beta) ; the coroutine prints beta
(coro-run co 'gamma) ; the coroutine prints gamma
</code></pre>
<p><a href="../std/fn-yields-p"><code>fn-yields?</code></a> will tell you whether or not a function will create a
coroutine when called.</p>
<p>By convention, functions which <code>yield</code> have <code>+</code> appended to the end of their name. This helps
to prevent mistakes when refactoring a non-yielding function into a yielding function, or 
vice-versa.</p>
<h2><a class="header" href="#life-cycle-of-a-coroutine" id="life-cycle-of-a-coroutine">Life-Cycle of a Coroutine</a></h2>
<p>The <a href="../std/coro-state"><code>coro-state</code> function</a> returns a symbol describing the current state of a 
coroutine: <code>newborn</code>, <code>running</code>, <code>paused</code>, <code>finished</code> or <code>poisoned</code>.</p>
<p><img src="coroutine-lifecycle.svg" alt="Coroutine life-cycle diagram" /></p>
<p>When you call a function which has at least one <code>yield</code> form somewhere in its body, it will return
a <code>newborn</code> coroutine. You can execute it with <code>coro-run</code>; a currently-executing coroutine is
in the <code>running</code> state. When it encounters a <code>yield</code> form, it will become <code>paused</code>, meaning it 
can be resumed again with <code>coro-run</code>. When a <code>running</code> coroutine returns, it will transition to 
the <code>finished</code> state, which is the end of its life-cycle.</p>
<p>If an <a href="errors.html">error</a> bubbles through a coroutine while it's executing, we assume that it's
been left in a disorderly state. Its state is set to <code>poisoned</code>, and any attempt to resume it
will trigger an error. This is analogous to how Rust's <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code> type</a> works.</p>
<h2><a class="header" href="#coroutines-and-iteration" id="coroutines-and-iteration">Coroutines and Iteration</a></h2>
<p>Coroutines are <code>iterable</code>. A coroutine iterator will repeatedly call <code>(coro-run the-coro)</code> and 
produce each value which the coroutine yields.</p>
<p>This can be used to implement custom iterators:</p>
<pre><code>; a coroutine-based implementation of the `lines` function. copies 
; a string and then splits it into individual lines, yielding one 
; line at a time. once there are no lines left, it returns.
(defn lines+ (source-str)
  (let st (clone source-str))
  (while (&gt; (len st) 0)
    (let pos (position st \newline))
    (cond
      ((nil? pos)
        (yield st)
        (break))
      (else
      	(let line (remove! st : pos))
      	(pop-start! st)
        (yield line)))))

(prn (arr ..(lines+ &quot;aaa\nbbb\nccc&quot;))) ; prints (&quot;aaa&quot; &quot;bbb&quot; &quot;ccc&quot;)
</code></pre>
<h2><a class="header" href="#stackful-and-stackless-coroutines" id="stackful-and-stackless-coroutines">Stackful and Stackless Coroutines</a></h2>
<p>In languages like Lua and Ruby, coroutines are &quot;stackful&quot;. Each coroutine allocates its own 
call-stack, and it can yield from arbitrarily deep within that call-stack.</p>
<p>On the other hand, GameLisp's coroutines follow the model set by Rust, Python, C# and C++. Our
coroutines are &quot;stackless&quot;: they only store enough data to pause a single call-frame, so it's
not possible for a coroutine to call a non-coroutine function and <code>yield</code> from inside it. You 
can only <code>yield</code> from the body of the coroutine function itself.</p>
<p>The primary reason for this is that it's much more efficient. Each and every Ruby coroutine 
(known as a <a href="https://ruby-doc.org/core-2.7.1/Fiber.html"><code>Fiber</code></a>) allocates a four-kilobyte, fixed-size callstack. In contrast, a typical
GameLisp coroutine will only allocate 100 to 300 bytes of data - about one-twentieth of the memory 
burden!</p>
<p>The other reason to prefer stackless coroutines is that they can be nested almost as
straightforwardly as stackful coroutines. The <a href="../std/yield-from"><code>yield-from</code> macro</a> will loop 
through an <code>iterable</code>, repeatedly yielding each of its results until it's finished. When the 
<code>iterable</code> is a coroutine, this is roughly equivalent to calling a function and yielding from 
inside it.</p>
<pre><code>; a coroutine which keeps yielding until some event is triggered,
; and then returns
(defn wait-until-trigger+ (trigger-name)
  (until (trigger-set? trigger-name)
    (yield)))

; a coroutine which controls the behaviour of an entity. the coroutine is
; resumed once per frame. it will do nothing until the 'can-move event 
; has been triggered, and then it will horizontally slide towards the 
; target x coordinate, bit by bit, until it has been reached.
(defn move-to+ (self x-target)
  (yield-from (wait-until-trigger+ 'can-move))

  (until (= [self 'x] x-target)
    (seek! [self 'x] x-target 1.5)
    (yield)))
</code></pre>
<h2><a class="header" href="#why-coroutines" id="why-coroutines">Why Coroutines?</a></h2>
<p>Coroutines can be thought of as a form of cooperative multitasking. They behave like 
operating-system threads, but rather than being interrupted at unpredictable intervals by the 
scheduler, they're allowed to execute for as long as they please. The coroutine itself decides 
when to manually end its time-slice and yield control back to the &quot;scheduler&quot; (in this case,
the function which invoked <code>coro-run</code>).</p>
<p>This type of control flow is a natural fit for game programming. Game worlds tend to be filled
with entities which perform complicated behaviours, splitting their actions into tiny incremental
&quot;steps&quot;. When the entity isn't doing anything too elaborate, it's easy to model their behaviour
as a simple function which is called once per frame - but when you want to do a few different
things in sequence, &quot;action A followed by action B followed by action C&quot;, then coroutines are
usually a much better choice.</p>
<p>Consider a cutscene script controller. We want this cutscene to show a dialogue bubble until the
player dismisses it, then have the main character walk to the right until they reach a
waypoint, then pause dramatically for three seconds, then show another dialogue bubble. 
Cramming all of this state into a single event-handler function is a real challenge:</p>
<pre><code>(defn step-handler (self)
  (match [self 'current-state]
    ('start
      (= [self 'bubble] (speak self &quot;You don't understand! I just have...&quot;))
      (= [self 'current-state] 'bubble-0))

    ('bubble-0
      (when (bubble-finished? [self 'bubble])
        (= [self 'current-state] 'walking-to-waypoint)))

    ('walking-to-waypoint
      (step-towards-point self (waypoint 'dramatic-pause))
      (when (at-waypoint? self (waypoint 'dramatic-pause))
        (start-sound 'howling-wind)
        (= [self 'pause-timer] 3.0)
        (= [self 'current-state] 'pausing)))

    ('pausing
      (dec! [self 'pause-timer] :dt)
      (when (&lt;= [self 'pause-timer] 0.0)
        (= [self 'bubble] (speak self &quot;...too many Incredibly Deep Feelings.&quot;))
        (= [self 'current-state] 'bubble-1)))

    ('bubble-1
      (when (bubble-finished? [self 'bubble])
        ; leave the viewer to process the scene's breathtaking emotional pathos
        (= [self 'current-state] 'finished)))))
</code></pre>
<p>The equivalent coroutine is a beauty:</p>
<pre><code>(defn run-cutscene+ (self)
  (yield-from (speak+ self &quot;You don't understand! I just have...&quot;))
  (yield-from (walk-to-point+ self (waypoint 'dramatic-pause)))
  (start-sound 'howling-wind)
  (yield-from (wait-secs+ 3.0))
  (yield-from (speak+ self &quot;...too many Incredibly Deep Feelings.&quot;)))
</code></pre>
<p>All of that state which we had to manually store elsewhere is now implicit in the coroutine.
The child functions would be simpler, too: the coroutine <code>walk-to-point+</code> is likely to be much
easier to implement, compared to the function <code>step-towards-point</code>. Our coroutine even has 
slightly better performance! Previously we were calling <code>(waypoint)</code> every frame because it would 
have been too much effort to cache it, but the coroutine makes it obvious that rechecking the 
waypoint every frame is actually the more-expensive option.</p>
<p>Cutscene scripting is usually such a nightmare that many smaller game projects either give up
hope of doing anything interesting with it, or come up with some hacky, limited, data-driven 
cutscene control library. But with the incredible power of coroutines, it's all just code, and you 
can make your cutscenes as complicated and emotional as you like! Try not to make your players 
cry too much.</p>
<p>Coroutines are particularly powerful when combined with explicit state machines. We'll explore 
the possibilities in more depth when we discuss <a href="object-oriented-programming.html">object-oriented 
programming</a>.</p>
<h1><a class="header" href="#patterns" id="patterns">Patterns</a></h1>
<p>Checking whether a value has a particular shape, and extracting other values from its interior, 
is a fundamental operation. In languages which don't have first-class support for destructuring, 
this operation tends to be unnecessarily difficult. For example, binding array elements to local 
variables in C is more verbose than it ought to be:</p>
<pre><code class="language-c">assert(array_len &gt;= 3);
float x = array_ptr[0];
float y = array_ptr[1];
float z = array_ptr[2];
</code></pre>
<p>Likewise for iterating over an array of 3D points in Lua:</p>
<pre><code class="language-lua">for _, point in ipairs(points) do
    local x, y, z = point.x, point.y, point.z
    -- ...
end
</code></pre>
<p>GameLisp includes destructuring facilities which are as powerful as Rust's, with a number of 
changes and additions to reflect the fact that GameLisp is dynamically-typed rather than 
statically-typed.</p>
<h2><a class="header" href="#basic-patterns" id="basic-patterns">Basic Patterns</a></h2>
<p>A pattern may appear anywhere that you might create a new variable binding: the left-hand-side
of a <a href="../std/let"><code>let</code></a>, <a href="../std/def"><code>def</code></a>, <a href="../std/field-clause"><code>field</code></a>, or 
<a href="../std/with-global"><code>with-global</code></a> form, a function parameter, or the item in a 
<a href="../std/for"><code>for</code> loop</a>.</p>
<p>A pattern is a form, but it's not evaluated or macro-expanded in the normal way. Patterns have
their own special evaluation rules.</p>
<p>When a pattern is a symbol, it matches any value and binds it to that symbol.</p>
<pre><code>(let x-doubled (* x 2))
</code></pre>
<p>The symbol <code>_</code> is special: it matches any value and discards it.</p>
<pre><code>(forn (_ 100)
  (do-something-one-hundred-times))

(let _ 100)
(prn _) ; an error: the symbol _ is not bound to a variable
</code></pre>
<p>Self-evaluating forms, like strings, quoted forms, tables, empty arrays, and numbers, only match a 
value which is <code>eq?</code> to the pattern. The value is then discarded.</p>
<pre><code>; both of these succeed, but without creating any bindings
(let 10 (+ 5 5)) 
(let #((a b)) (tab ('a 'b)))
</code></pre>
<p>Unlike Rust, patterns in <code>let</code> bindings are not required to be infallible. Any pattern can fail
to match. If a mismatch occurs in <code>let</code>, <code>def</code>, <code>field</code>, <code>with-global</code> or <code>for</code>, it's an error.</p>
<pre><code>(let &quot;xyz&quot; (arr 'x 'y 'z)) ; an error
(let 'a-symbol (tab ('a 'b))) ; an error
</code></pre>
<p>You can deal with fallible bindings using the <a href="../std/match"><code>match</code></a>, 
<a href="../std/when-let"><code>when-let</code></a> and <a href="../std/matches-p"><code>matches?</code></a> macros. </p>
<ul>
<li><code>match</code> checks a value against a series of patterns and executes some code for the first pattern 
which successfully matches the value, returning <code>#n</code> if no patterns match. </li>
<li><code>when-let</code> does the same for a single pattern.</li>
<li><code>matches?</code> returns <code>#t</code> when a value matches a pattern, or <code>#f</code> when it's a mismatch.</li>
</ul>
<p><span></span></p>
<pre><code>(match (len ar)
  (0
    &quot;empty array&quot;)
  (1
    &quot;array with a single element&quot;)
  (n
    &quot;array with {n} elements&quot;))
</code></pre>
<p>A pattern isn't always just a single form; it's sometimes described by a series of consecutive
forms. For example, wherever you would write a pattern, you can instead write <code>x at pat</code>. This
processes <code>pat</code> as normal, but also binds the additional variable <code>x</code>, which is set to the
pattern's input value. (This is similar to Rust's <a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#-bindings"><code>x @ pat</code> syntax</a>.)</p>
<h2><a class="header" href="#predicates" id="predicates">Predicates</a></h2>
<p>A &quot;predicate&quot; is a function which asks a question. For example, the functions 
<a href="../std/int-p"><code>int?</code></a>, <a href="../std/gte"><code>&gt;=</code></a>, <a href="../std/eq-p"><code>eq?</code></a> and 
<a href="../std/fn-yields-p"><code>fn-yields?</code></a> are all predicates.</p>
<p>Any pattern can test an arbitrary predicate using the syntax <code>pat : pred?</code>. When <code>pat</code> matches
the input value, the predicate function <code>pred?</code> is invoked - if the result is false, then 
the match becomes a mismatch.</p>
<p>Note that the <code>:</code> is whitespace-sensitive, so <code>pat: pred?</code> would be invalid syntax.</p>
<pre><code>(match arg
  (i : int?
    &quot;the integer {i}&quot;)
  (f : flo?
    &quot;the floating-point number {f}&quot;)
  (val
    (bail &quot;expected a number but received {(type-of val)}&quot;)))

(let result : num? (calculate-number))

(when-let f : flo? result
  (prn &quot;calculated the floating-point number {f}&quot;)
  (prn (matches? result _ : int?))) ; prints #f
</code></pre>
<p>When <code>pred?</code> is a symbol, the predicate is invoked on the input value being tested, 
<code>(pred? input)</code>. Under those circumstances, to avoid confusion, <code>pat</code> must be a symbol or <code>_</code>.</p>
<p>When <code>pred?</code> is not a symbol, it's evaluated as an arbitrary form which has access to all of
the pattern's bindings. If the evaluation result is false, the pattern is a mismatch. The 
form will usually be a function call which inspects one or more of the pattern's variables.</p>
<pre><code>; a predicate can be used like a match guard in Rust
(match (calculate-x)
  (x : (== x 0)
    &quot;zero&quot;)
  (x : (&gt; x 0)
    &quot;the positive number {x}&quot;)
  (x
    &quot;the negative number {x}&quot;))
</code></pre>
<p>You can test arbitrarily complex predicates by defining your own functions.</p>
<pre><code>(let-fn u8? (n)
  (and (int? n) (&lt;= 0 n 255)))

(defn rgb (r : u8?, g : u8?, b : u8?)
  (bitor (bitshl r 16) (bitshl g 8) b))

(ensure (== (rgb 0xb7 0x41 0x0e) 0xb7410e))
</code></pre>
<p>Predicates can perform Boolean operations using the forms <code>(and pred? ...)</code>, <code>(or pred? ...)</code> and 
<code>(not pred?)</code>. These forms can be arbitrarily nested inside one another.</p>
<pre><code>(match f
  (f : (and flo? (or inf? nan?))
    &quot;a weird float {f}&quot;)
  (f : flo?
    &quot;a normal float {f}&quot;)
  (_
    &quot;not a float&quot;))

(when-let sym : (and sym? has-global?) input
  (let g (global sym))
  (prn &quot;the input is a symbol bound to the global {g}&quot;))
</code></pre>
<p>Predicates are not a static type system! When you place a predicate on a variable's definition, it 
only checks the variable's initial value - if the variable is mutated, the predicate may no longer
hold.</p>
<pre><code>(def name : str? &quot;global string&quot;)
(= name 'assigned-symbol)
(prn (str? name)) ; prints #f
</code></pre>
<h2><a class="header" href="#arrays-1" id="arrays-1">Arrays</a></h2>
<p>An array pattern will match an array value with exactly the same number of arguments.</p>
<pre><code>(let (one two three) '(1 2 3))
(let (one two) '(1 2 3 4 5)) ; an error
</code></pre>
<p>Each element of the array pattern is, itself, a pattern. </p>
<pre><code>(let ((a b) (c d)) '((1 2) (3 4)))
</code></pre>
<p>Complex patterns should be separated using <a href="syntax-and-types.html#whitespace">commas</a> to 
improve readability.</p>
<pre><code>(defn constant-fold (form)
  (match form
    ((callee : (has? foldable-ops callee), a : num?, b : num?)
      ((global callee) a b))
    (form
      form)))

(prn (constant-fold '(+ 2 3))) ; prints 5
(prn (constant-fold '(+ var-name 3))) ; prints (+ var-name 3)
</code></pre>
<p>Predicates can access variables defined for earlier array elements - not just their current
element.</p>
<pre><code>(let (one, two : (&gt; two one)) '(1 2))
</code></pre>
<p>In forms like <code>let</code> and <code>def</code>, when there is no initializer value, the pattern will automatically
succeed and set all of its bindings to <code>#n</code>. This is a convenient way to declare several 
uninitialized local variables at once.</p>
<pre><code>(let (width height depth))
(prn width height depth) ; prints #n #n #n
</code></pre>
<h3><a class="header" href="#optional-patterns" id="optional-patterns">Optional Patterns</a></h3>
<p><code>(? pat)</code> is an &quot;optional pattern&quot; - it represents an element which may or may not exist. In an
array pattern, if that element is missing (because the array is too short to have an element at 
that index), the pattern unconditionally succeeds and all of its bindings are initialized to 
<code>#n</code>.</p>
<pre><code>(let (a (? b) (? c)) '(1 2))
(prn a b c) ; prints 1 2 #n

; the predicate succeeds, even though (int? #n) is false
(let (d : int?, (? e) : int?) '(4)) 
(prn d e) ; prints 4 #n
</code></pre>
<p>An optional array element may specify a default value, which is used in place of <code>#n</code> when the
element is missing. The syntax is <code>(? pat init)</code>. When the pattern has a predicate,
<code>(? pat init) : pred?</code>, the default value <em>is</em> tested by the predicate.</p>
<pre><code>(let (x y (? z 0.0)) '(5.0 3.5))
(prn x y z) ; prints 5.0 3.5 0.0
</code></pre>
<p>While a default value is being evaluated, any bindings from earlier array elements will be in 
scope and initialized.</p>
<pre><code>(let (small (? big (* small 10))) '(5))
(prn small big) ; prints 5 50
</code></pre>
<h3><a class="header" href="#rest-patterns" id="rest-patterns">Rest Patterns</a></h3>
<p><code>..pat</code> is a &quot;rest pattern&quot; - it can be used to capture zero or more contiguous array elements 
which were not captured by any other patterns. Each element is tested against <code>pat</code> (including 
calling <code>pat</code>'s predicate, if it has one, for each element individually). The rest pattern only 
matches when all of the individual elements match. Each variable binding in <code>pat</code> is bound to a 
newly-allocated array which contains one value for each element.</p>
<pre><code>(let pairs '((a 1) (b 2) (c 3)))

(let (..(letters : sym?, numbers : int?)) pairs)

(prn letters numbers) ; prints (a b c) (1 2 3)

; the most common use of rest patterns is to unconditionally collect
; part of an array into a variable.
(let (first, second, ..rest : int?) '(0 1 2 3 4))
(prn first second rest) ; prints 0 1 (2 3 4)

; the .._ pattern can be used to discard any number of array elements.
; in that case, no allocation will be performed.
(let (first .._ last) '(0 1 2 3 4))
(prn first last) ; prints 0 4
</code></pre>
<p>The order of optional and rest patterns is quite flexible. Any of the following would be valid 
array patterns:</p>
<pre><code>(a (? b) (? c))
(a (? b) ..c)
(..a b c)
(a ..b c)
</code></pre>
<h3><a class="header" href="#functions-1" id="functions-1">Functions</a></h3>
<p>Function parameter lists are just array patterns, where the input array contains all of the
arguments to the function call. This means that functions and macros can take advantage of the 
full power of predicates, optional patterns, and rest patterns.</p>
<pre><code>(defn draw-text (text : str?, x : num?, y : num?, 
                 (? font simple-font) : (is? font 'Font))
  ...)

(defn process (first ..rest)
  ...

  (unless (empty? rest)
    (process ..rest)))
</code></pre>
<p>Array patterns can be used to emulate function overloading. For example, this function expects
a different parameter list depending on whether its first argument is a deque or a table:</p>
<pre><code>(defn search (..args)
  (match args

    ((haystack : deque?, needle)
      (any? (fn1 (eq? _ needle)) haystack))

    ((haystack : tab?, key, value)
      (eq? [haystack key] value))

    (args (bail &quot;invalid argument list {args}&quot;))))
</code></pre>
<p>GameLisp can optimize functions more aggressively when their parameter list follows all of 
these rules:</p>
<ul>
<li><code>..rest</code> is either the last parameter, or absent.</li>
<li>For <code>(? opt)</code> and <code>..rest</code> parameters, the pattern itself is <code>_</code> or a symbol.</li>
<li>For <code>(? opt init)</code> parameters, <code>init</code> is either self-evaluating (like <code>()</code>) or 
quoted (like <code>'(6 7)</code>).</li>
</ul>
<h2><a class="header" href="#or-patterns" id="or-patterns"><code>or</code> Patterns</a></h2>
<p><code>or</code> isn't only useful in predicates. You can use an <code>(or pat ...)</code> form wherever you would use 
any other pattern. It matches, and binds, the first matching child pattern. If none of the child 
patterns match, the <code>or</code> pattern is a mismatch.</p>
<p>You can think of <code>or</code> as being like <a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#multiple-patterns"><code>|</code> in Rust patterns</a>.</p>
<pre><code>; match on a valid (+), (-), (*) or (/) form. (/) requires at least
; one argument, but the others can be called with zero arguments.
(match form
  ((or ((or '+ '- '*) ..rest)
       ('/ first ..rest))
    ...))
</code></pre>
<p>All possible variable bindings from all of the child forms will be bound by the <code>or</code> pattern.
If a variable isn't present in the sub-pattern which matches, that variable will still be bound, 
but it will be initialized to <code>#n</code>.</p>
<pre><code>; search for an item in a deque, which can be defined either by a predicate
; callback, or by an argument which should be (eq?) to the item.
(defn search (haystack : deque?, (or is-needle? : callable?, needle-item))
  (for (i item) in (enumerate haystack)
    (cond
      ((nil? is-needle?)
        (when (eq? needle-item item)
          (return i)))
      (else
        (when (is-needle? item)
          (return i)))))
  #n)
</code></pre>
<h2><a class="header" href="#indexing-2" id="indexing-2">Indexing</a></h2>
<p>When a pattern is an <a href="../std/access"><code>access</code> form</a> - in other words, when a pattern is enclosed 
in square brackets - it will attempt to index its value. The pattern matches if all of the indexes 
are present.</p>
<p>The <code>access</code> form's children are usually symbol patterns, in which case each indexed value is 
bound to the corresponding name.</p>
<pre><code>(let [x y z] 3d-vector)
(let length (cbrt (+ (* x x) (* y y) (* z z))))

(let [height : int?, weight : flo?] physical-properties)
</code></pre>
<p>Each child form may also be an array <code>(index pat)</code>, where <code>index</code> is a literal value (not 
necessarily a symbol!) used to index the collection, and <code>pat</code> is a pattern which is matched 
against the resulting value.</p>
<pre><code>(let [(x src-x) (y src-y)] src-2d-vector)
(let [(x dst-x) (y dst-y)] dst-2d-vector)
(prn &quot;from ({src-x}, {src-y}) to ({dst-x}, {dst-y})&quot;)

(let [(0 zeroth : flo?) (500 five-hundredth : flo?)] huge-array)
</code></pre>
<p><code>?</code> and <code>..</code> patterns work in much the same way that they do for arrays. The <code>..</code> pattern
will collect all remaining key/value pairs into a table; it only matches input collections which
are, themselves, tables. Any predicates are tested against the value, rather than the key.</p>
<pre><code>(let table #((a 1) (b 2) (d 4) (e 5)))

(let [a (? b) (? c) ..rest : int?] table)
(prn a b c) ; prints 1 2 #n
(prn rest) ; prints #((d 4) (e 5)), not necessarily in that order
</code></pre>
<h2><a class="header" href="#file-formats" id="file-formats">File Formats</a></h2>
<p>If you have some custom data files which your game should store - for example, the file format used
by your level editor - then you should consider storing them in the GameLisp text format.</p>
<p>GameLisp already has powerful facilities for parsing and manipulating its own data-types, but 
patterns take things to the next level. For example, a function to validate the level file-format 
for a simple role-playing game might look like this:</p>
<pre><code>(defn level-valid? (lvl)
  (matches? lvl [
    name : str?
    background-music : sym?
    (tiles (..(x : int?, y : int?)))
    (entities (..entity : entity-spec-valid?))
  ]))

(defn entity-spec-valid? (entity)
  (matches? entity [
    class-name : sym?
    (coords (x : int?, y : int?))
    (? init-args ()) : arr?
  ]))

; the (level-valid?) function would match a level file with these contents
#(
	(name &quot;tower-exterior&quot;)
	(background-music aria)
	(tiles ((0 5) (3 1) (1 1) (1 1) #|and so on|#))
	(entities (
		#((class-name TowerGuard) (coords (70 95)) (init-args (alert)))
		#((class-name Portcullis) (coords (70 60)))
	))
)

; contrast similar code written in a more imperative style...
(defn entity-spec-valid? (entity)
  (and
    (sym? [entity (? 'class-name)])
    (has? entity 'coords)
    (do
      (let coords [entity 'coords])
      (and
        (arr? coords)
        (== (len coords) 2)
        (do
          (let x [coords 0], y [coords 1])
          (and (int? x) (int? y)))))
    (or
      (not (has? entity 'init-args))
      (arr? [entity 'init-args]))))

(defn level-valid? (lvl)
  (and
    (str? [lvl (? 'name)])
    (sym? [lvl (? 'background-music)])
    (has? lvl 'tiles)
    (block tiles-checker
      (for tile in [lvl 'tiles]
        (unless (and (arr? tile) (== (len tile) 2) (int? [tile 0]) (int? [tile 1]))
          (finish-block tiles-checker #f)))
      #t)
    (has? lvl 'entities)
    (all? entity-spec-valid? [lvl 'entities])))
</code></pre>
<p>Patterns are concise and powerful, but they should be used cautiously - it can be difficult to 
fully understand the behaviour of a complex pattern. If you find that a pattern you've written
isn't self-explanatory at a glance, consider refactoring it into multiple simpler patterns,
even if that makes your code more verbose.</p>
<h2><a class="header" href="#cheat-sheet" id="cheat-sheet">Cheat Sheet</a></h2>
<table><thead><tr><th>Pattern</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>_</code></td><td>Match, and discard, any value</td></tr>
<tr><td><code>&quot;hello&quot;</code></td><td>Match, and discard, the string <code>&quot;hello&quot;</code></td></tr>
<tr><td><code>'world</code></td><td>Match, and discard, the symbol <code>world</code></td></tr>
<tr><td><code>x</code></td><td>Match any value and bind it to <code>x</code></td></tr>
<tr><td><code>x : pred?</code></td><td>Match a value for which <code>(pred? x)</code> is true, and bind it to <code>x</code></td></tr>
<tr><td><code>pat : (form y z)</code></td><td>As for <code>pat</code>, but only matches when <code>(form y z)</code> is true</td></tr>
<tr><td><code>x at pat</code></td><td>As for <code>pat</code>, but additionally binds the input value to <code>x</code></td></tr>
<tr><td><code>x at pat : pred?</code></td><td>Combines the previous two cases</td></tr>
<tr><td><code>(or pat1 pat2)</code></td><td>Match either <code>pat1</code> or <code>pat2</code></td></tr>
<tr><td><code>(pat1 pat2)</code></td><td>Match an array of two elements</td></tr>
<tr><td><code>(pat1 (? pat2))</code></td><td>Match an array of one or two elements</td></tr>
<tr><td><code>(pat1 ..pat2)</code></td><td>Match an array of one or more elements</td></tr>
<tr><td><code>[x]</code></td><td>Match a collection with the field <code>'x</code>, binding it to <code>x</code></td></tr>
<tr><td><code>[(x pat)]</code></td><td>As for <code>[x]</code>, but the value is matched against <code>pat</code></td></tr>
</tbody></table>
<h1><a class="header" href="#object-oriented-programming" id="object-oriented-programming">Object-Oriented Programming</a></h1>
<p>Game code is naturally object-oriented. A typical game codebase might contain:</p>
<ul>
<li>
<p>A central &quot;engine&quot;, mostly implemented in a native language, to handle anything highly 
performance-sensitive (such as physics and rendering) and anything which is inherently 
global (such as key bindings and saved games).</p>
</li>
<li>
<p>A very large number of unique &quot;entity&quot; types, mostly implemented in a scripting language,
each representing a different kind of in-game object.</p>
<ul>
<li>
<p>The engine behaves as a &quot;server&quot; and the entities behave as its &quot;clients&quot;: registering 
themselves to participate in the physics system, emitting drawing commands, 
serializing themselves when the game is saved, and so on.</p>
</li>
<li>
<p>Entities are sometimes data-driven (for example, a monster in an action-adventure game
might be partially defined by its total health and a list of elemental weaknesses), but 
defining a new entity usually involves at least some scripting (for example, each monster 
would have an AI script to control its behaviour in combat).</p>
</li>
</ul>
</li>
</ul>
<p>Entity definitions usually make up the lion's share of any game's codebase, so providing a great
environment for defining entities was my number one priority while designing GameLisp. After 
experimenting with a few <a href="object-oriented-programming.html#aside-why-not-prototypes">alternatives</a>, I eventually settled on a 
traditional, class‑based object‑oriented programming (OOP) system.</p>
<p>This may surprise some readers - after all, OOP has been steadily going out of fashion for the
last decade or two, particularly in game development. This is because OOP has a few well-known
flaws which can make it architecturally awkward. GameLisp has a unique take on OOP which
tries to minimize those downsides, while still taking advantage of its convenience and 
intuitiveness. It's quite different from OOP as seen in languages like C++, Java and Python.</p>
<h2><a class="header" href="#fundamentals" id="fundamentals">Fundamentals</a></h2>
<p>GameLisp's <a href="syntax-and-types.html#type-summary">primitive types</a> include objects and classes.
Each class describes a type of object, and each object is an individual instance of a class.</p>
<p>You can define a new class using the macros <a href="../std/defclass"><code>defclass</code></a>, 
<a href="../std/let-class"><code>let-class</code></a> and <a href="../std/class"><code>class</code></a>. They work in the same way as 
<code>defn</code>, <code>let-fn</code> and <code>fn</code>, respectively.</p>
<pre><code>(defclass Bomb
  (const initial-time 30.0)
  (field timer @initial-time)

  (met tick (delta-time)
    (dec! @timer delta-time)
    (when (&lt;= @timer 0.0)
      (prn &quot;BOOM!&quot;))))
</code></pre>
<p>Classes are full-fledged GameLisp values. You can store them in an array, bind them to a local
variable, pass them as a function argument, and so on. <code>defclass</code> just evaluates a <code>(class ...)</code> 
form and binds it to a global variable.</p>
<pre><code>(let Renamed Bomb)
(ensure (class? Bomb))
(ensure (same? Bomb Renamed))

(prn Bomb) ; prints #&lt;class:Bomb&gt;
(del-global! 'Bomb)
(prn Bomb) ; an error
</code></pre>
<p>Classes are always immutable. There's no way to modify a class after you've defined it.</p>
<p>As demonstrated above, classes are described using a sequence of &quot;clause&quot; forms. The most 
important clauses are <a href="../std/field-clause"><code>(field ...)</code></a>, 
<a href="../std/const-clause"><code>(const ...)</code></a> and <a href="../std/met-clause"><code>(met ...)</code></a>.</p>
<h3><a class="header" href="#fields-and-constants" id="fields-and-constants">Fields and Constants</a></h3>
<p>A <a href="../std/field-clause"><code>(field name)</code> clause</a> defines an object field. Each field reserves enough 
space inside the object to store a single GameLisp value, of any type. You can optionally provide 
an initializer form, which will be evaluated during <a href="object-oriented-programming.html#initialization">object initialization</a>. All 
fields are mutable.</p>
<p>A <a href="../std/const-clause"><code>(const name init)</code> clause</a> defines an associated constant. Constants take 
up no storage in the object. Their <code>init</code> form is evaluated when the class is defined, and it can 
refer to previous constants in the same class.</p>
<pre><code>(const width 40)
(const height 60)
(const area (* @width @height))
</code></pre>
<p>Fields and constants share the same namespace, and they're public by default. You can access a 
field or constant on a particular object using the <a href="../std/access"><code>[]</code> syntax</a>, just as you might 
access a table field.</p>
<pre><code>(defn describe-bomb (bomb)
  (prn &quot;initial time: &quot; [bomb 'initial-time])
  (prn &quot;current time: &quot; [bomb 'timer]))

(defn reset-bomb (bomb)
  (= [bomb 'timer] [bomb 'initial-time]))
</code></pre>
<p>You can also use <code>[]</code> to look up the value of a constant in a class.</p>
<pre><code>(prn &quot;initial time for all bombs: &quot; [Bomb 'initial-time])
</code></pre>
<h3><a class="header" href="#methods" id="methods">Methods</a></h3>
<p>A <a href="../std/met-clause"><code>(met name (args...) body...)</code> clause</a> defines a method: a function which 
&quot;acts on&quot; a particular object. Unlike Rust, the <code>self</code> argument is defined implicitly rather than 
explicitly, so you would write <code>(met a (b) ...)</code> rather than <code>(met a (self b) ...)</code>.</p>
<p>Methods share the same namespace as fields and constants, and like fields and constants, they're 
public by default.</p>
<p>To invoke a method on an object, use the <code>(.name obj args...)</code> syntax.</p>
<pre><code>(defn tick-all-bombs (bombs delta-time)
  (for bomb in bombs
    (.tick bomb delta-time)))
</code></pre>
<p>That same syntax can be used to invoke a function which is stored in a field or constant. In that 
case, the function isn't considered to be a method, so it won't receive a <code>self</code> parameter and it
won't be able to access any object fields.</p>
<pre><code>(defclass Static
  (const print-description (fn () 
    (prn &quot;your hair is standing on end!&quot;))))

(.print-description Static)
</code></pre>
<h2><a class="header" href="#-forms" id="-forms"><code>@</code> Forms</a></h2>
<p><code>@name</code> is an <a href="syntax-and-types.html#abbreviations">abbreviation</a> for 
<a href="../std/atsign"><code>(atsign name)</code></a>.</p>
<p><code>@</code> is only meaningful within the body of a method, or within the initializer form of a field or 
constant. Broadly speaking, it's used to access some property of the current object, similar to 
<code>self</code> in Rust. </p>
<p><code>@width</code> means &quot;access the field or constant named <code>width</code> on the current object&quot;.</p>
<p><code>(@run a b)</code> means &quot;invoke the method <code>run</code> on the current object, with arguments <code>a</code> and <code>b</code>&quot;.</p>
<pre><code>(defclass Paintbrush
  (field red)
  (field green)
  (field blue)

  (met rgb ()
    (arr @red @green @blue))

  (met print-color ()
    (prn (@rgb)))

  (met make-grayscale! ()
    (let avg (/ (+ @red @green @blue) 3))
    (= @red avg, @green avg, @blue avg)))
</code></pre>
<p>There are a <a href="../std/objects-and-classes#abbreviations">few special cases</a>. <code>@self</code> returns a 
reference to the current object, <code>@class</code> is the current object's class, and <code>@class-name</code> is 
the name of the current object's class as a symbol.</p>
<h3><a class="header" href="#first-class-functions" id="first-class-functions">First-Class Functions</a></h3>
<p>Methods can't be passed around as first-class values. If you try to access a method as you would
access a field or constant, it's an error.</p>
<pre><code>(defclass WidgetValidator
  (const threshold 10.0)

  (met widget-valid? (widget)
    (&gt;= [widget 'validity] @threshold))

  (met validate (widgets)
    (all? @widget-valid? widgets))) ; an error
</code></pre>
<p>However, forms like <code>@self</code> and <code>@width</code> work by referring to a hidden local variable, which is
eligible to be captured using <code>fn</code>. Therefore, creating a first-class function which delegates to 
a method is straightforward.</p>
<pre><code>(met validate (widgets)
  ; invoke the widget-valid? method on @self, passing in each widget
  (all? (fn1 (@widget-valid? _)) widgets))
</code></pre>
<h2><a class="header" href="#initialization" id="initialization">Initialization</a></h2>
<p>To instantiate a new object, simply call a class, in the same way that you would call a function.</p>
<pre><code>(let bomb (Bomb))

(prn bomb) ; prints #&lt;obj:Bomb&gt;
(ensure (obj? bomb))
(ensure (same? (class-of bomb) Bomb))
</code></pre>
<p>You can pass in parameters to the function call. Those parameters will be passed to a special
initializer method, which can be defined using an <a href="../std/init-clause"><code>(init ...)</code> clause</a>.</p>
<pre><code>(defclass Refinery
  (field fuel-limit)
  (field fuel)

  (init (@fuel-limit)
    (= @fuel (/ @fuel-limit 5))))

(let refinery (Refinery 1000))
(prn [refinery 'fuel]) ; prints 200
</code></pre>
<p>There will often be a one-to-one relationship between your class's fields and the parameters to
its initializer method. To save you from typing out the same name several times, we provide
special field-initialization syntax:</p>
<pre><code>(defclass AppleTree
  (field fruit-count)
  (field health (* @fruit-count 20))
  (field planted-on-date)

  (init (@fruit-count @planted-on-date))
    (prn &quot;created an apple tree with {@fruit-count} fruit&quot;))

(let tree (AppleTree 6 (in-game-date)))
</code></pre>
<p>The initialization method may prefix any of its parameter names with <code>@</code>, in which case the class 
must have a field which shares the same name. At the start of the initialization method, each 
field is initialized in the order that they were defined, emitting an <code>(= @name name)</code> form for 
any parameters prefixed with <code>@</code>.</p>
<p>In other words, the above <code>AppleTree</code> class definition is equivalent to:</p>
<pre><code>(defclass AppleTree
  (field fruit-count)
  (field health)
  (field planted-on-date)

  (init (fruit-count planted-on-date)
    (= @fruit-count fruit-count)
    (= @health (* @fruit-count 20))
    (= @planted-on-date planted-on-date)
    (prn &quot;created an apple tree with {@fruit-count} fruit&quot;)))
</code></pre>
<p>Normal <code>met</code> clauses may also have <code>@</code>-parameters. In that case, they just emit a <code>(= @name name)</code>
form at the start of their body, in no particular order.</p>
<pre><code>(met on-health-change (@health)
  (when (&lt; @health 0)
    (prn &quot;the tree withers away!&quot;)))

; ...is equivalent to...

(met on-health-change (health)
  (= @health health)
  (when (&lt; @health 0)
    (prn &quot;the tree withers away!&quot;)))
</code></pre>
<h2><a class="header" href="#finalization" id="finalization">Finalization</a></h2>
<p>The <a href="../std/obj-kill-mut"><code>obj-kill!</code> function</a> will execute an object's finalizer method 
(defined using a <a href="../std/fini-clause"><code>(fini ...)</code> clause</a>), and then permanently delete 
its storage. Trying to access a field or call a method on a killed object is an error.</p>
<pre><code>(defclass Mandrake
  (field coords)

  ; ...

  (fini
    (for entity in (query-entities 'within-distance 50 @self)
      (.hit entity 150 'necrotic))))

(let mandrake (Mandrake spawn-coords))
(obj-kill! mandrake)
(prn [mandrake 'coords]) ; an error
</code></pre>
<p>Note that the <code>fini</code> method will not be called if an object is simply garbage-collected,
so it can't be used for RAII-style resource cleanup. We'll discuss some alternatives to RAII
in the <a href="errors.html">Errors</a> chapter.</p>
<h2><a class="header" href="#privacy" id="privacy">Privacy</a></h2>
<p>If you read the textbooks, they will tell you that information hiding is one of the pillars
of object-oriented programming. Languages like C# tend to make all class members private
by default - not only is it impossible to access them from a different project, but they can't
even be accessed by a different class within the same source file!</p>
<p>In practice, for day-to-day code, it's easy to waste too much effort carefully hiding fields 
and methods from yourself and your colleagues. I find that a game codebase can tolerate a lot of 
&quot;unnecessarily public&quot; fields and methods, as long as you choose sensible names for those few 
bindings which are intended to be accessed from outside the class. This is why fields, constants 
and methods are public by default in GameLisp.</p>
<p>That being said, privacy is occasionally useful. If you're writing a <a href="code-reuse.html#mixins">mixin</a> 
or <a href="object-oriented-programming.html#classmacros">classmacro</a> which will be integrated into many different classes, or if you're
writing a class for a library which is intended to be used by strangers, then putting lots of 
names in your object's public namespace becomes significantly more risky.</p>
<p>In the macros chapter, we discussed a technique for avoiding name collisions in macros:
<a href="macros.html#hygiene">auto‑gensym</a>. Classes have access to the same technique. When a symbol
anywhere in a class is suffixed with <code>#</code>, each occurrence of that symbol will be replaced with 
the same <a href="../std/gensym"><code>gensym</code></a>. This makes it impossible to refer to that name from outside 
the class, but it can still be accessed by other objects of the same class.</p>
<pre><code>(defclass SecretivePoint
  (field x#)
  (field y#)

  (init (@x# @y#))

  (met op-eq? (other)
    (and (== @x# [other 'x#]) (== @y# [other 'y#]))))

(let point (SecretivePoint 20 20))
(prn [point 'x#]) ; an error
</code></pre>
<h2><a class="header" href="#properties" id="properties">Properties</a></h2>
<p>If you have one entity which advertises its coordinates as a field <code>[et 'coords]</code>, and a more 
complex entity which provides the same information as a method <code>(.coords et)</code>, writing client code 
to deal with both possibilities can be irritating.</p>
<p>On the other hand, when defining a class, you don't want to waste a lot of effort writing useless
methods which only return a field's value.</p>
<pre><code>(defclass GameLispOrJava?
  (field width# 5)
  (field height# 5)

  (met width ()
    @width#)

  (met height ()
    @height#))
</code></pre>
<p>GameLisp borrows a leaf from C#'s book by allowing you to define a pair of methods which behave 
like a field. The &quot;getter&quot; method is called when the field is accessed, and the &quot;setter&quot; method is
called when a new value is assigned to the field.</p>
<pre><code>(defclass GameLispOrCSharp?
  (prop width 5 (get))
  (prop height 5 (get)))
</code></pre>
<p>Each property has a &quot;backing field&quot; which stores a single value. The class above would define
one field named <code>width:field</code> and another named <code>height:field</code>. The empty <code>(get)</code> forms simply
return the backing field's current value. You could also define an empty <code>(set)</code> form, which just 
assigns its argument to the backing field.</p>
<p>Of course, <code>(get ...)</code> and <code>(set ...)</code> can also be defined with a method body. Within those 
methods, it's possible to refer to the backing field as <a href="../std/atsign-field"><code>@field</code></a>:</p>
<pre><code>; a creature whose apparent position differs from its true position
(defclass DisplacerBeast
  (prop coords
    (get
      (let (x y) @field)
      (arr (- x 10) (- y 10)))
    (set (arg)
      (let (x y) arg)
      (= @field (arr (+ x 10) (+ y 10)))))

  (met print-description ()
    (prn &quot;my coords are &quot; @coords))

  (met print-secret-description ()
    (prn &quot;my actual coords are &quot; @coords:field)))
</code></pre>
<p>Just like fields and constants, properties can be initialized automatically, using the syntax
<code>(prop name initializer-form ...)</code>. The initial value is assigned to the backing field directly; 
the setter is not invoked.</p>
<p>Properties are more complicated than fields, so you should avoid using them when they're not
necessary. Unless you really need to prevent assignment for some reason, the classes above 
should simply be written as:</p>
<pre><code>(defclass GameLisp
  (field width 5)
  (field height 5))
</code></pre>
<h2><a class="header" href="#arrows-3" id="arrows-3">Arrows</a></h2>
<p>As usual, the <a href="built-in-macros.html#arrows">arrow macros</a> can be used to flatten out deeply-nested
function calls and field accesses. The arrow macros include special handling for <code>@name</code> and 
<code>.name</code> forms.</p>
<pre><code>(-&gt; rect .coords (.offset-by 10 10) @to-local ['x])

; ...is equivalent to...

[(@to-local (.offset-by (.coords rect) 10 10)) 'x]
</code></pre>
<p>Notice the resemblance to Rust's method invocation syntax:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>rect.coords.offset_by(10, 10)
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#classmacros" id="classmacros">Classmacros</a></h2>
<p>Class definitions can become repetitive. For example, every entity in your game might have
an <code>on-step</code> method with the same set of parameters:</p>
<pre><code>(defclass MetalWall
  (met on-step (controller delta-time)
    ...))

(defclass LaserSword
  (met on-step (controller delta-time)
    ...))

; i've only typed that boilerplate twice and i'm already tired of it
</code></pre>
<p>You can use <code>defclassmacro</code> to define a macro which will be invoked in place of a class clause.
For example, in the above case, we might define a <code>step</code> classmacro:</p>
<pre><code>(defclassmacro step (..body)
  `(met on-step (controller delta-time)
    ..body))

(defclass MetalWall
  (step
    ...))

(defclass LaserSword
  (step
    ...))
</code></pre>
<p>Classmacros can use <a href="macros.html#the-expansion-algorithm"><code>splice</code></a> to emit multiple clauses from a 
single macro invocation. On the other hand, if a classmacro decides that it doesn't want to emit 
any clauses, it can return <code>#n</code>. Nil clauses are silently ignored.</p>
<p>Classmacros are powerful. For example, you could define a small <code>coro-step</code> classmacro which 
resumes a coroutine every step.</p>
<pre><code>(defclassmacro coro-step (..body)
  `(splice
    (field coro-name#)
    (field setter-name#)

    (met on-step (controller cur-delta-time#)
      (when (or (nil? coro-name#) (not (eq? (coro-state coro-name#) 'paused))) 
        (let delta-time cur-delta-time#)
        (= coro-name# ((fn () ..body)))
        (ensure (coro? coro-name#))
        (= setter-name# (fn (dt) (= delta-time dt))))

      (setter-name# cur-delta-time#)
      (coro-run coro-name#))))

(defclass LaserSword
  (coro-step
    (prn &quot;vrumm&quot;)
    (yield)
    (prn &quot;VWOM&quot;)
    (yield)
    (prn &quot;ñommmm&quot;)))
</code></pre>
<h2><a class="header" href="#aside-why-not-prototypes" id="aside-why-not-prototypes">Aside: Why Not Prototypes?</a></h2>
<p>Several popular scripting languages (namely Lua, JavaScript, and their derivatives) have an object
system very different from GameLisp's. In those languages, there is no distinction between an 
object and a table, or between a method and a table field. Tables may delegate field accesses to 
another table, which establishes a <em>de facto</em> single inheritance hierarchy.</p>
<p>Prototype-based object systems have the advantage of being extremely simple and easy to learn.
Unfortunately, they're also quite limited. Some pre-release versions of GameLisp experimented 
with a prototype-based object system, and encountered these problems:</p>
<ul>
<li>Prototype chains tend to have poor performance, and the nature of the object model makes
optimization difficult.</li>
<li>The hybrid object/tables tend to be weakly-typed and excessively dynamic. There's often no way
to disable unhelpful operations like adding arbitrary fields to any object, or deleting any 
field, or iterating over every field. Abstractions end up feeling leaky and insecure.</li>
<li>The lack of dedicated syntax for things like methods and fields causes many quality-of-life
papercuts. Methods being called as non-method functions accidentally; silent name collisions;
no easy way to differentiate a general-purpose hash table from an object; no good way to make
an individual table field immutable; etc.</li>
<li>Prototypes are a natural fit for single inheritance, but a poor fit for more complicated kinds 
of class relationship, like those which we'll explore in the next two chapters.</li>
</ul>
<h1><a class="header" href="#state-machines" id="state-machines">State Machines</a></h1>
<p>The behaviour of most game entities can be at least partially described by a <a href="https://en.wikipedia.org/wiki/Finite-state_machine">state machine</a>.
The door might be opening, open, closing, or closed. The gold ring might be bouncing around, 
flickering as it's about to vanish, or disappearing in a flash of light as it's collected.
The ghost might be playing an animation as it springs out of its hiding-place, or it might be 
slowly gliding towards the player character. The main menu might be fading in, showing the title 
screen, showing the settings screen, or fading out.</p>
<p>As a Rust programmer, you probably understand better than most the value of state machines for
modelling programs. Rust's <code>enums</code> are one of its greatest strengths: they take what would be a 
vague, implicit set of state transitions, and change them into something completely explicit
and obvious which can be statically checked by the compiler.</p>
<p>As we saw in the <a href="coroutines.html">Coroutines</a> chapter, describing a state machine using traditional
object-oriented code is very challenging. Consider a frog which cycles between crouching, jumping
and croaking:</p>
<pre><code>(defclass Frog
  (field color 'green)

  (field state 'crouching)

  (field state-change-timer 3.0)
  (field next-state 'croaking)

  (field elevation 0.0)
  (field vertical-speed 0.0)
  (const gravity -9.81)

  (met on-step (elapsed)
    (match @state
      ('crouching
        (dec! @state-change-timer elapsed)
        (when (&lt;= 0.0 @state-change-timer)
          (match @next-state
            ('crouching
              (bail))
            ('jumping
              (= @vertical-speed 3.0)
              (= @state 'jumping))
            ('croaking
              (= @state 'croaking)
              (= @state-change-timer 2.0)))))

      ('jumping
        (inc! @elevation (* elapsed @vertical-speed))
        (inc! @vertical-speed (* elapsed @gravity))
        (when (&gt;= @elevation 0.0)
          (= @elevation 0.0)
          (= @state 'crouching)
          (= @state-change-timer 1.0)
          (= @next-state 'croaking)))

      ('croaking
        (inc! @state-change-timer elapsed)
        (when (&lt;= 0.0 @state-change-timer)
          (= @state 'crouching)
          (= @state-change-timer 3.0)
          (= @next-state 'jumping))))))
</code></pre>
<p>This is code which only a mother could love. The object scatters its state variables across a
mess of different toplevel fields, which stick around even after their state is complete, and
which are sometimes overloaded between one state and the next. The intended lifetime of each 
field is unclear. Understanding the flow of control takes a fair amount of conscious effort. 
Adding in nested state machines, or multiple simultaneous state machines, would be a great
challenge.</p>
<p>On the other hand, if we were to try to formalize this state machine in a language like Java or 
Rust, it could easily become over-engineered. You don't want to create an entirely separate type,
or potentially even a hierarchy of types, just to manage control flow in a forty-line class.</p>
<p>When programming a game, you'll face this dilemma for just about every entity which you come
across. It wouldn't be unusual for a game to contain hundreds, or even thousands, of state 
machines. When they're all defined using code which looks like the above, it's not a pretty sight.</p>
<p>This brings us to GameLisp's <code>state</code> clauses:</p>
<pre><code>(defclass Frog
  (field color 'green)

  (fsm
    (state* Crouching
      (field timer)
      (field next-state)

      (init-state ((? @timer 3.0) (? @next-state 'Jumping)))

      (met on-step (elapsed)
        (dec! @timer elapsed)
        (when (&lt;= @timer 0.0)
          (@enab! @next-state))))

    (state Jumping
      (field elevation 0.0)
      (field vertical-speed 3.0)
      (const gravity -9.81)

      (met on-step (elapsed)
        (inc! @elevation (* elapsed @vertical-speed))
        (inc! @vertical-speed (* elapsed @gravity))
        (when (&lt;= @elevation 0.0)
          (@enab! 'Crouching 1.0 'Croaking))))

    (state Croaking
      (field timer 2.0)

      (met on-step (elapsed)
        (dec! @timer elapsed)
        (when (&lt;= @timer 0.0)
          (@enab! 'Crouching))))))
</code></pre>
<h2><a class="header" href="#states" id="states">States</a></h2>
<p>A <code>state</code> represents part of a class which can be switched on and switched off.
<a href="../std/statex-clause"><code>state*</code> clauses</a> are enabled by default, whereas
<a href="../std/state-clause"><code>state</code> clauses</a> are disabled by default.</p>
<p>States may contain most of the same clauses which are permitted at the toplevel of a class:
<code>field</code>, <code>const</code>, <code>prop</code>, <code>met</code>, classmacros, and so on. The difference is that, while the state 
is disabled, its contents &quot;stop existing&quot;. Its fields, constants and properties can't be accessed, 
and its methods can't be invoked.</p>
<p>A state can be enabled by calling the function <a href="../std/enab-mut"><code>(enab! obj name)</code></a>, where 
<code>name</code> is the state's name as a symbol, e.g. <code>'Opening</code>. Similarly, <a href="../std/disab-mut"><code>disab!</code></a>
can be used to disable a state, and <a href="../std/enab-p"><code>enab?</code></a> to test whether a state is currently
enabled.</p>
<p>Within a method, <code>(@enab! name)</code> is shorthand for <code>(enab! @self name)</code>, and likewise for
<code>@disab!</code> and <code>@enab?</code>. <code>@state-name</code> will return the name of the enclosing state.</p>
<pre><code>(defclass Gem
  ...

  (state Sparkling
    (met stop-sparkling
      (@disab! @state-name))

    ...))

(let gem (Gem))
(prn (enab? gem 'Sparkling)) ; prints #f

(enab! gem 'Sparkling)
(prn (enab? gem 'Sparkling)) ; prints #t

(.stop-sparkling gem)
(prn (enab? gem 'Sparkling)) ; prints #f

(.stop-sparkling gem) ; an error
</code></pre>
<h2><a class="header" href="#finite-state-machines" id="finite-state-machines">Finite State Machines</a></h2>
<p>A single <code>state</code> by itself is rarely useful. What you usually need is a group of states which are 
mutually exclusive, so that no more than one of the states can be enabled at any given moment.
This can be achieved using an <a href="../std/fsm-clause"><code>fsm</code> clause</a>.</p>
<pre><code>(defclass Fighter
  (fsm
    (state* Neutral
      (const defense 50))
    (state Guarding
      (const defense 150))
    (state Staggered
      (const defense 0))))
</code></pre>
<p>When a state within an <code>fsm</code> clause is about to be enabled, but one of its siblings is already 
enabled, that sibling is automatically disabled first. In this case, if we were to call
<code>(@enab! 'Guarding)</code>, it would automatically call <code>(@disab! 'Neutral)</code> first.</p>
<h2><a class="header" href="#nested-states" id="nested-states">Nested States</a></h2>
<p>A <code>state</code> clause may appear within another <code>state</code> clause, establishing a hierarchy of state
machines.</p>
<p>If you attempt to enable a child state, and its parent is disabled, the parent will automatically
be enabled first. </p>
<p>Similarly, if you disable a parent state when any of its children are enabled, those child states 
will automatically be disabled first.</p>
<pre><code>(defclass Owl
  (fsm
    (state* Sleeping
      ...
      (met on-startled ()
        (@enab! 'Awake))) ; disables Sleeping, enables Fleeing

    (state Awake
      (fsm
        (state* Fleeing
          ...
          (met on-collide (other)
            (when (is? other TreeBranch)
              (@enab! 'Perching other)))) ; disables Fleeing
        
        (state Perching
          ...
          (met on-step ()
            (unless (humans-nearby? @self)
              (@enab! 'Sleeping)))))))) ; disables Perching and Awake
</code></pre>
<h2><a class="header" href="#initialization-and-finalization" id="initialization-and-finalization">Initialization and Finalization</a></h2>
<p>A state may include an <a href="../std/init-state-clause"><code>init-state</code> clause</a> and/or a 
<a href="../std/fini-state-clause"><code>fini-state</code> clause</a>. These are analogous to the <code>init</code> and <code>fini</code> 
clauses which can appear at the toplevel of a class.</p>
<p><code>init-state</code> defines a method which is automatically invoked just after the state is enabled. Its 
arguments are the same arguments which were passed to <code>enab!</code> or <code>@enab!</code>. </p>
<pre><code>(defclass Cog
  (fsm
    (state* Immobile
      (met on-activate ()
        (@enab! 'Mobile (rand-pick -1 1))))

    (state Mobile
      (field direction)
      (field rotation-rate)

      (init-state (@direction)
        (= rotation-rate (* @direction 0.3))))))
</code></pre>
<p>When a state is enabled automatically by GameLisp (e.g. if it's a parent state whose child state 
is enabled, or if it was defined using <code>state*</code> rather than <code>state</code>), then its initializer is 
invoked with no arguments.</p>
<p><code>fini-state</code> defines a cleanup method which is automatically called just before the state is 
disabled. It will also be called if the object is 
<a href="object-oriented-programming.html#finalization">killed</a>.</p>
<p>It's possible to call <code>@enab!</code> and <code>@disab!</code> from within an <code>init-state</code> or <code>fini-state</code> method,
but it's not recommended. It can make the order of operations confusing, and in the worst 
case it might trigger an endless loop of state changes.</p>
<h3><a class="header" href="#errors" id="errors">Errors</a></h3>
<p>If an error occurs during initialization or finalization, the object will be left in an incoherent
state. Child <code>state*</code> forms may not have been automatically enabled, a state passed to <code>disab!</code> 
may not actually have been disabled, an <code>init</code> method may have only been executed halfway, 
and so on.</p>
<p>This is almost never a recoverable situation, so GameLisp takes no chances: if an error bubbles 
through an <code>init</code>, <code>fini</code>, <code>init-state</code> or <code>fini-state</code> method, the object is immediately 
<a href="object-oriented-programming.html#finalization">killed</a> without any finalizers being run.</p>
<h2><a class="header" href="#shadowing" id="shadowing">Shadowing</a></h2>
<p>If you have a global or local variable bound to the name <code>dragon</code>, and you define a new local
variable using <code>(let dragon ...)</code>, then any references to the name <code>dragon</code> will refer to the
new binding rather than the older bindings. We say that the later local binding &quot;shadows&quot; the
earlier bindings.</p>
<p>The same is true for fields and constants in states. It's possible for a name to be bound by
several different states at the same time, all of which might be simultaneously enabled.
Under those circumstances, when GameLisp evaluates an expression like <code>@dragon</code> or <code>[obj 'dragon]</code>,
it needs to choose which binding takes priority.</p>
<p>The rules are:</p>
<ul>
<li>
<p>Names in child states will shadow names defined by their parent.</p>
</li>
<li>
<p>Names in any state will shadow names defined by sibling states which appear textually earlier 
in the <code>class</code> definition.</p>
</li>
</ul>
<p>These are essentially the same rules which govern local variable bindings.</p>
<pre><code>(defclass ShoppingCentre
  (const tax-revenue 10_000)

  (state WellKnown
    (const tax-revenue 15_000))

  (state Damaged
    (const tax-revenue 2_000)

    (state Demolished
      (const tax-revenue 0))))

(let shops (ShoppingCentre))
(prn [shops 'tax-revenue]) ; prints 10000

(enab! shops 'Demolished)
(prn [shops 'tax-revenue]) ; prints 0

(enab! shops 'WellKnown)
(prn [shops 'tax-revenue]) ; prints 0
</code></pre>
<h3><a class="header" href="#fully-qualified-names" id="fully-qualified-names">Fully-Qualified Names</a></h3>
<p>If you need to access a field or constant in a specific state, you can use its fully-qualified 
name, <code>StateName:field-name</code>, to bypass the normal shadowing rules. For the purpose of name lookup, 
all fields and constants defined in the toplevel of a class are considered to belong to a <code>Main</code>
state which can never be disabled.</p>
<pre><code>(defclass FancyChair
  (const comfort-points 75)
  (const room-points 40)
  (const fun-points 5)

  (state Grubby
    (const comfort-points 40)
    (const room-points 10)

    (state Filthy
      (const room-points -30))))

(let chair (FancyChair))
(enab! chair 'Filthy)

(prn [chair 'comfort-points]) ; prints 40
(prn [chair 'room-points]) ; prints -30
(prn [chair 'fun-points]) ; prints 5

(prn [chair 'Main:comfort-points]) ; prints 75
(prn [chair 'Grubby:room-points]) ; prints 10
(prn [chair 'Filthy:room-points]) ; prints -30
</code></pre>
<p>This highlights a quirky detail of how state namespaces work: state names don't actually form a 
hierarchy. A state <code>Child</code> defined within the state <code>Parent</code> defined within the <code>Main</code> state is 
just called <code>Child</code>, rather than <code>Main:Parent:Child</code>. This means that you can't 
simultaneously have, say, <code>Defending:KnockedBack</code> and <code>Attacking:KnockedBack</code> - that would be a 
name collision, because both states are actually just named <code>KnockedBack</code>.</p>
<p>This is a deliberate design choice. Being able to define multiple different states which share
the same name would be confusing, and typing out fully-qualified names would be too much effort.
Flattening the namespace hierarchy is an effective solution.</p>
<h2><a class="header" href="#wrapper-methods" id="wrapper-methods">Wrapper Methods</a></h2>
<p>You will sometimes want to change the behaviour of a method depending on which states are enabled.
For example, when the main character is being controlled by a cutscene script rather than being 
directly controlled by the player, you might want to override their <code>on-input</code> event handler to 
do nothing.</p>
<p>A naive attempt to achieve this using name shadowing will fail:</p>
<pre><code>(defclass Character
  (met on-input (input-event)
    (match [input-event 'tag]
      ('left (@walk-left))
      ('right (@walk-right))
      ('pause (game:pause))))
  
  (state CutsceneControl
    (met on-input (input-event)
      ; do nothing
      #n)))

(let mc (Character))
(enab! mc 'CutsceneControl) ; error: name collision for 'on-input
</code></pre>
<p>It's not possible to have multiple active <code>met</code> forms which share the same name. This is because, 
although name-shadowing is adequate for fields and constants, it's not powerful enough for methods.
We provide a better alternative.</p>
<p>A <a href="../std/wrap-clause"><code>(wrap ...)</code> clause</a> defines a &quot;wrapper method&quot;: a method which replaces, 
and modifies, a method in another state.</p>
<pre><code>(defclass Character
  (met on-input (input-event)
    (match [input-event 'tag]
      ('left (@walk-left))
      ('right (@walk-right))
      ('pause (game:pause))))
  
  (state CutsceneControl
    (wrap Main:on-input (input-event)
      ; do nothing
      #n)))
</code></pre>
<p>In this case, when the <code>CutsceneControl</code> state is active, any calls to <code>(.on-input ch ev)</code> will be 
routed to the wrapper method in <code>CutsceneControl</code>. It would still be possible to invoke the 
original method using its fully-qualified name: <code>(.Main:on-input ch ev)</code> or <code>(@Main:on-input ev)</code>.</p>
<p>Within our wrapper method, we can invoke the original <code>met on-input</code> by calling 
<a href="../std/atsign-base"><code>(@base)</code></a>. This is a versatile tool. We could ignore the base method 
altogether, execute some additional code before or after calling <code>(@base)</code>, transform the 
base method's arguments or return value, or even call the base method multiple times!</p>
<p>For example, some cutscenes might want to give the player a limited ability to move the main
character around, but still forbid them from opening the pause menu. This would be easy to achieve 
using <code>(@base)</code>:</p>
<pre><code>(defclass Character
  (met on-input (input-event)
    (match [input-event 'tag]
      ('left (@walk-left))
      ('right (@walk-right))
      ('pause (game:pause))))
  
  (state CutsceneControl
    (wrap Main:on-input (input-event)
      (unless (eq? [input-event 'tag] 'pause)
        (@base input-event))))
</code></pre>
<h3><a class="header" href="#chained-wrappers" id="chained-wrappers">Chained Wrappers</a></h3>
<p>You will have noticed that the <code>wrap</code> clause receives a fully-qualified name for its target
method: in this case, <code>Main:on-input</code>. </p>
<p>The target is usually a <code>met</code> form, but it's also possible to recursively wrap another <code>wrap</code> 
form. The wrapper methods form an orderly stack, with each <code>(@base)</code> call moving down the stack 
until it reaches the <code>met</code>.</p>
<p>Let's suppose that we're writing an action game (or a business simulation game?) with a 
<code>BerserkerBoss</code> entity who turns progressively more red and angry as the encounter goes on:</p>
<pre><code>(defclass BerserkerBoss
  (met ruddiness ()
    (+ @attacks-received @henchmen-defeated))

  (state Angry
    (wrap Main:ruddiness ()
      (match @difficulty-level
        ('easy
          (* 1.2 (@base)))
        ('hard
          (* 1.4 (+ 3 (@base))))))

    (state Furious
      (wrap Angry:ruddiness ()
        (* 1.5 (@base))))))
</code></pre>
<p>When the <code>Furious</code> state is enabled, its parent state <code>Angry</code> must also be enabled. The
original definition of <code>ruddiness</code> is wrapped by <code>Angry:ruddiness</code>, which is in turn wrapped
by <code>Furious:ruddiness</code>, so a non-specific call to the <code>ruddiness</code> method will end up invoking
<code>Furious:ruddiness</code>. Each wrapper delegates down the chain through successive calls to <code>(@base)</code>.</p>
<h3><a class="header" href="#property-wrappers" id="property-wrappers">Property Wrappers</a></h3>
<p>You can wrap a property in much the same way that you might wrap a method. Simply define a
<code>(wrap-prop ...)</code> clause. If we wanted to refactor <code>ruddiness</code> to be a property rather than a 
method, we would write:</p>
<pre><code>(defclass BerserkerBoss
  (prop ruddiness (get (+ @attacks-received @henchmen-defeated)))

  (state Angry
    (wrap-prop Main:ruddiness
      (get
        (match @difficulty-level
          ('easy
            (* 1.2 (@base)))
          ('hard
            (* 1.4 (+ 3 (@base)))))))

    (state Furious
      (wrap-prop Angry:ruddiness (get (* 1.5 (@base)))))))
</code></pre>
<p>Property wrappers can't use the <code>@field</code> shorthand to access the original property's backing
storage. Instead, they should invoke the original getter or setter using <code>(@base)</code>.</p>
<h2><a class="header" href="#zombie-methods" id="zombie-methods">Zombie Methods</a></h2>
<p>A state may be disabled partway through executing one of its own methods. Similarly, an object
may call <code>(obj-kill! @self)</code> from within one of its own methods. In both cases, this will land you
in an awkward grey area. Code will be executing which <em>appears</em> to belong to a state or object,
even though the state or object no longer exists. Under those circumstances, any <code>@name</code> 
field accesses or <code>(@name)</code> method calls will usually trigger an error. I call this situation a 
&quot;zombie method&quot;.</p>
<pre><code>(defclass Person
  (met check-health ()
    (when (&lt;= @health 0)
      (obj-kill! @self))

    ; execution continues after the object is killed. braaains...

    (when (== @health 100) ; error: nonexistent field 'health
      (prn &quot;feeling pretty healthy!&quot;))))
</code></pre>
<p>(For the record, this is a problem which already exists in many game state machines - it's just 
something which GameLisp makes explicit, rather than leaving it as a silent logic error.)</p>
<p>There's  no practical way for GameLisp to prevent this. It would require dynamic checks
to be inserted every time control flow leaves the body of a method, which would be difficult 
to implement and carry a huge performance cost.</p>
<p>Zombie methods tend to fail loudly rather than introducing subtle bugs, so they're mostly just
an annoyance. You could consider using two techniques to make zombie methods less common:</p>
<ul>
<li>
<p>Get into the habit of calling <a href="../std/return"><code>return</code></a> immediately after 
<code>(@disab! 'CurrentStateName)</code>. You might like to combine the two calls by defining a 
macro - perhaps <code>(done)</code>, <code>(end)</code>, or <code>(switch-to state-name)</code>.</p>
</li>
<li>
<p>Postpone any <code>(obj-kill!)</code> calls until the very end of each frame. (As it so happens, most game 
engines already do this by default. Entity deletion is a common source of bugs, probably 99% of 
which can be prevented by postponing the deletion.)</p>
</li>
</ul>
<h1><a class="header" href="#code-reuse" id="code-reuse">Code Reuse</a></h1>
<p>In game development, you'll often have a small piece of data and behaviour which you need to 
duplicate between many different classes. In a go-kart racing game, you might require all entities 
to register their bounding box with the collision system; or in a city simulator, you might have 
many different buildings which have their own population count and tax revenue; or in a 3D
exploration game, you may wish to plug hundreds of diverse entities into the same animation system.</p>
<p>You already have several ways to achieve this sort of code reuse:</p>
<ul>
<li>
<p>In many cases, the code can simply be <a href="https://twitter.com/ID_AA_Carmack/status/53512300451201024">refactored into a free function</a>. &quot;The <code>on-grow</code> method
for all of my fruit tree classes is identical - they should be calling a shared <code>grow-fruit-tree</code>
function instead.&quot;</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Duck_typing">Duck typing</a> can be an elegant solution for some simple cases, but you normally can't use it to 
uphold complex invariants. &quot;If I'm creating an entity, and I notice that has a <code>target-rect</code> 
field, I will automatically register it with the combat-targeting system.&quot;</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">Composition over inheritance</a> will explicitly fracture your classes into small, reusable
components which are separate from the whole. This will certainly make each component reusable,
but it can be a hassle. &quot;When I create a <code>Skyscraper</code>, it automatically creates a new
<code>PopulationNode</code> and <code>TaxNode</code>.&quot;</p>
</li>
<li>
<p>If the only thing the entities have in common is that they all belong to the same general 
category, and some external system needs to manipulate them all in the same way, then you could 
implement a tag database. &quot;Each frame, my <code>Lava</code> entity looks up any nearby entities with the 
<code>heat-sensitive</code> tag, and calls their <code>on-heat</code> method.&quot;</p>
</li>
<li>
<p>Consider whether the differences between your entities can be described using plain data rather 
than code. If you were to reimplement the original <a href="https://youtu.be/fTdlzqhSdt8?t=2879">Final Fantasy</a> in GameLisp, you wouldn't 
need distinct classes for an <code>Ogre</code> and a <code>Creep</code> - you would just have a single <code>Enemy</code> class 
which makes use of plain data like &quot;hit points&quot; and &quot;sprite size&quot;. Likewise, if you were to 
reimplement <a href="https://youtu.be/NG7lgdJNgB0?t=1806">The Sims</a>, all of the different doorways would probably be modelled as a single 
<code>Door</code> class which is capable of displaying a few different sprites.</p>
</li>
</ul>
<p>Occasionally, none of those options will be sufficient. This usually happens when a component
is shared by a very large number of entities (dozens or hundreds), and those entities need to 
frequently interact with the component in some intrusive way, so splitting it into a separate 
object would make things too bureaucratic. For example...</p>
<ul>
<li>
<p>In an action-adventure game, we don't want to type out <code>[@collider 'coords]</code> every single time 
an entity needs to know its own coordinates; we just want to type <code>@coords</code> instead. On the other 
hand, an entity's physical location is a very fragile thing (if you get it wrong, entities will 
start clipping through the scenery!), so our physics system shouldn't just manipulate a bare 
<code>@coords</code> field using duck typing.</p>
</li>
<li>
<p>In a theme-park simulation game, the code for saving and loading the game needs to be able
to serialize and deserialize most of the game's entities. Explicitly writing <code>serialize</code> and
<code>deserialize</code> methods for every building, every visitor and every worker would be 
labour-intensive and tedious.</p>
</li>
<li>
<p>In a massively-multiplayer online game, the code for scripting the user-interface might need
to filter or intercept certain methods. For example, if a user-interface element has scrollbars, 
then the arguments to its <code>on-mouse-click</code> method should be adjusted to give the illusion that 
it belongs to a different coordinate system. If each new type of user-interface element was 
forced to convert between coordinate systems manually, you would end up writing a lot of extra 
code, and bugs would certainly creep in.</p>
</li>
</ul>
<p>In situations like these, your first port of call should be a macro or a 
<a href="object-oriented-programming.html#classmacros">classmacro</a>. It would be straightforward to write 
a <code>defentity</code> macro which acts like <code>defclass</code>, but emits a few extra clauses to hook the 
resulting class into the savegame system and the collision system.</p>
<p>If you find that even macros aren't powerful enough, GameLisp does have one more trick up
its sleeve.</p>
<h2><a class="header" href="#mixins" id="mixins">Mixins</a></h2>
<p>A mixin is a small class which can't be instantiated. Instead, it can only be &quot;mixed into&quot; the
definition of another class. The target class will incorporate all of the mixin's fields, methods, 
states, and so on, almost as though they were simply copied and pasted at the beginning of the 
class definition.</p>
<pre><code>(defmixin Sized
  (field width)
  (field height))

(defclass Box
  (mixin Sized)
  (init (@width @height)))

(let box (Box 20 15))
(prn [box 'width] [box 'height]) ; prints 20 15
(prn (is? box Box) (is? box Sized)) ; prints #t #t
</code></pre>
<p>This is similar to a classmacro, but it comes with several advantages:</p>
<ul>
<li>
<p>Mixins can customize their object's initialization and finalization. (This would be difficult
to achieve using a classmacro, since each class may only have a single <code>init</code> clause and a
single <code>fini</code> clause, which can't normally be wrapped.)</p>
</li>
<li>
<p>Mixins introduce a new namespace. If your <code>SoftBody</code> mixin specifically wants to override a 
method introduced by your <code>Collider</code> mixin, it can include the clause 
<code>(wrap Collider:something ...)</code>.</p>
</li>
<li>
<p>As demonstrated above, the <code>(is? obj class)</code> function can be used to test whether an object's 
class implements a particular mixin.</p>
</li>
</ul>
<p><span></span></p>
<pre><code>; a mixin which adds a `coords` property and a `move` method to a class, 
; and ensures that the collision system is kept up-to-date whenever the 
; coords are changed.
(defmixin Coords
  (prop coords 
    (get)
    (set (new-coords)
      (= @field new-coords)
      (colliders:update @self)))

  (met move (dx dy)
    (colliders:move @self dx dy))

  (init-mixin (..args)
    (@base ..args)
    (colliders:register @self))

  (fini-mixin ()
    (colliders:unregister @self)))
</code></pre>
<h2><a class="header" href="#advanced-wrapper-methods" id="advanced-wrapper-methods">Advanced Wrapper Methods</a></h2>
<p>In the <a href="state-machines.html">previous chapter</a>, we discussed wrapper methods, which can be used to 
override a specific <code>met</code> or <code>wrap</code> clause defined elsewhere in the class.</p>
<p>So far, the obvious limitation of wrapper methods is that they require you to know the entire 
structure of your class up front. There's a <code>Jumping</code> state, which wraps the <code>Active:energy-level</code> 
property, which wraps the <code>Main:energy-level</code> property...</p>
<p>Let's suppose you have an <code>on-step</code> method, and you want to write a mixin which spawns a particle 
effect every step, without replacing or modifying the entity's normal behaviour. GameLisp gives you
two options for achieving that.</p>
<p>The first option:</p>
<pre><code>(defmixin Cloudy
  (wrap Main:on-step ()
    (@base)
    (spawn-particle @coords 'clouds)))
</code></pre>
<p>If <code>Main:on-step</code> is undefined, or if you include multiple states or mixins which all try to 
override <code>Main:on-step</code>, or if a state other than <code>Main</code> tries to define a <code>met on-step</code>, an 
error will occur. This is normally a good thing! It highlights the fact that your code has 
an ambiguous order of execution, and it prompts you to disambiguate it by, for example, changing 
one of your wrapper methods to override <code>Cloudy:on-step</code> instead.</p>
<p>In cases where you're absolutely sure that you don't care about the order of execution, you could
consider the second option:</p>
<pre><code>(defmixin Cloudy
  (wrap _:on-step ()
    (@base)
    (spawn-particle @coords 'clouds)))
</code></pre>
<p>The underscore makes this a &quot;wildcard wrapper method&quot;. It means &quot;I want this code to be executed 
when <code>on-step</code> is called, but I don't care about what happens before or after&quot;.</p>
<p>Wildcard wrappers are much less strict than explicit wrappers. It's fine to have a wildcard
wrapper for <code>_:on-step</code>, even when there is no actual <code>met on-step</code> anywhere in the class. 
If there is no other <code>on-step</code> method, or if it's disabled, <code>(@base)</code> will be a silent no-op. 
There can be any number of <code>_:on-step</code> wrappers in each class; you can even put several in the 
same state!</p>
<p>Wildcard wrappers can only be invoked using their unqualified method name: <code>(.Cloudy:on-step ob)</code>
would fail, but <code>(.on-step ob)</code> would succeed. When you call an unqualified method like <code>on-step</code>,
<code>(@base)</code> will chain through all of the wildcard wrappers in an unspecified order, followed by all 
of the explicit wrappers, followed by the <code>met</code> form. Methods which belong to disabled states are 
skipped.</p>
<p>Although wildcard wrappers can lead to spaghetti code when overused, they're a powerful tool when
used responsibly.</p>
<pre><code>(class Monster
  (met on-inspect ()
    (prn &quot;It's terrifying!&quot;))
  
  (state OnFire
    (wrap _:on-inspect ()
	  (@base)
	  (prn &quot;Also, it's on fire!&quot;)))
  
  (state Howling
    (wrap _:on-inspect ()
	  (@base)
	  (prn &quot;It's howling, too!&quot;))))
</code></pre>
<h2><a class="header" href="#initialization-and-finalization-1" id="initialization-and-finalization-1">Initialization and Finalization</a></h2>
<p>Mixins are initialized using an <a href="../std/init-mixin-clause"><code>init-mixin</code> clause</a>, which defines a 
wrapper for the class's initializer method. If a class has three mixins and an <code>init</code> clause...</p>
<pre><code>(defclass
  (mixin A B C)
  (init
    ...))
</code></pre>
<p>...then it effectively has a hidden initializer method <code>Main:init</code>, which is wrapped by 
<code>C:init-mixin</code>, which is wrapped by <code>B:init-mixin</code>, which is wrapped by <code>A:init-mixin</code>.</p>
<p>Like any other wrapper method, <code>init-mixin</code> is versatile. It can intercept leading or trailing
initializer arguments, modify arguments, and execute arbitrary code before or after calling 
<code>(@base)</code>. The only thing it's not capable of doing is inverting the flow of information - a class 
can't decide which arguments to pass to each of its mixins - but this is a deliberate design 
choice.</p>
<p>Finalization is simpler than initialization. When an object is killed, GameLisp will first call
the object's <code>fini</code> method, and then call <a href="../std/fini-mixin-clause"><code>fini-mixin</code></a> for each mixin 
from right to left. <code>fini-mixin</code> isn't a wrapper method, so it doesn't need to call <code>(@base)</code>.</p>
<h2><a class="header" href="#states-in-mixins" id="states-in-mixins">States in Mixins</a></h2>
<p>Mixins may define states. However, it's an error for a mixin to define a state which is also
defined by the target class, or by another mixin. GameLisp provides no way to mix two states 
together, simply because it would be too confusing.</p>
<p>For similar reasons, mixins don't <a href="state-machines.html#shadowing">shadow</a> their implementing class. 
If the toplevel of a mixin defines a field or constant which is also defined by the <code>Main</code> state 
of its implementing class, it's an error.</p>
<p>If a mixin defines a state, that state will participate in name-shadowing as normal, as though
it was copied-and-pasted in at the very start of the implementing class.</p>
<pre><code>(defmixin Heavy
  (const kg 1000)
  (state* Burdened
    (const kg 1100)))

; this is an error, because the name Weight:kg collides with Heavy:kg.
; if Heavy's (const kg 1000) were commented out, the code would compile.
(defclass Weight
  (mixin Heavy)
  (const kg 500))
</code></pre>
<h3><a class="header" href="#mixin-states" id="mixin-states">Mixin States</a></h3>
<p>It's ordinarily an error for a mixin and a state to share the same name, because it would cause
a namespace collision:</p>
<pre><code>; which one of these two fields is named `Fighting:health`?
(mixin Fighting
  (field health)
  (state Fighting
    (field health)))
</code></pre>
<p>However, there's a special exception when a mixin only contains a single <code>state</code> or <code>state*</code>,
with no other clauses. In that case, the state &quot;takes over&quot; the mixin's namespace. In effect, you 
end up with a mixin which can be dynamically enabled and disabled - a useful abstraction.</p>
<h2><a class="header" href="#aside-why-not-inheritance" id="aside-why-not-inheritance">Aside: Why Not Inheritance?</a></h2>
<p>Most object-oriented languages in common use include an inheritance hierarchy. Code reuse is
achieved by designating one or more &quot;parent classes&quot; for each class. All of the fields and methods
in the parent class are incorporated into the child class.</p>
<p>I find that this is often an unhelpful abstraction, for two main reasons:</p>
<ul>
<li>
<p>The boundary between a parent class and its children can be fiendishly difficult to manage.
Designing <code>ClassA</code> so that it extends and improves <code>ClassB</code> sounds deceptively straightforward,
but in reality it's anything but.</p>
</li>
<li>
<p>The problems with multiple inheritance are well-documented, but single inheritance is too
limited. It tends to create awkward, towering inheritance hierarchies, bringing in many
features which the final object doesn't actually need.</p>
</li>
</ul>
<p>Mixins vaguely resemble an inheritance hierarchy, but they're deliberately simpler. Mixins can't 
include or require other mixins, so they form a flat list rather than a tree. Mixins don't have
a general ability to override or shadow everything in the implementing class - they just have a 
limited ability to override initialization, finalization and methods. By convention, mixins are 
also much smaller than base classes: a mixin should define a small, reusable piece of code,
rather than defining the entire foundation upon which another class will be built.</p>
<h3><a class="header" href="#emulating-inheritance" id="emulating-inheritance">Emulating Inheritance</a></h3>
<p>One thing which single inheritance excels at is defining multiple classes which are almost
identical, but with only small differences in their logic. In a military-strategy game, if you 
have a red soldier with an aggressive AI and a musket, and a blue soldier with a defensive AI and a
pike, then it would be natural to model them as:</p>
<pre><code class="language-java">class Soldier extends Entity { ... }
class RedSoldier extends Soldier { ... }
class BlueSolider extends Soldier { ... }
</code></pre>
<p>If you're trying to achieve something like this in GameLisp, I would strongly advise against
defining a <code>Soldier</code> mixin. Mixins aren't designed to be used for inheritance; you'll be able
to make it work with a little effort, but it won't be elegant.</p>
<p>Instead, you should use runtime configuration: a single <code>Soldier</code> class which accepts a <code>color</code>
parameter. States make it easy to compartmentalize the class into two sub-types.</p>
<pre><code>(defclass Soldier
  (init (color)
    (match color
      ('red (@enab! 'Red))
      ('blue (@enab! 'Blue))
      (_ (bail))))

  (state Red
    (const weapon-name 'musket)
    (met select-action ()
      ...))

  (state Blue
    (const weapon-name 'pike)
    (met select-action ()
      ...)))
</code></pre>
<h2><a class="header" href="#aside-why-not-ecs" id="aside-why-not-ecs">Aside: Why Not ECS?</a></h2>
<p>The Entity-Component-System pattern (ECS) is currently very popular among Rust game developers.</p>
<p>With strict use of an ECS, entities are completely refactored into small, independent components. 
All game code must be written in terms of those components, rather than directly manipulating 
individual entities. In exchange for this inconvenience, ECS provides excellent performance.</p>
<p>Architecturally speaking, ECS is an appropriate choice for games with intricate, complex 
rule systems. The ECS will encourage you to generalise anything which can possibly
be generalised; this can reduce the risk that your game's complexity will spiral out of
control. Herbert Wolverson demonstrates the advantages of this approach in his excellent 
<a href="https://bfnightly.bracketproductions.com/">roguelike tutorial</a>.</p>
<p>However, ECS carries a major disadvantage: it makes it more difficult to write code
which <em>isn't</em> generalised.</p>
<p>Let's suppose you were recreating Super Mario Bros. 3 using an ECS, and you needed to program 
the behaviour of <a href="https://youtu.be/L7aJxY65QDc?t=145">the final boss, Bowser</a>. Bowser has an 
attack which isn't seen anywhere else in the game: he leaps into the air and strikes downwards, 
destroying any scenery beneath him. When he finally breaks through the floor, there's a special 
sound effect, the screen shakes, and the exit door opens. The uniqueness of this attack is what 
makes the battle so exciting!</p>
<p>In practice, the simplest way to make all of this work with a strict ECS would be to define a 
<code>BowserComponent</code> and <code>BowserSystem</code>, both of which are only ever used by this single entity. 
They would almost certainly be more difficult to write, and have worse performance, compared to 
a naive object-oriented approach. If most of your entities are as unique as Bowser, defining a 
new <code>System</code> for each of them would be tedious.</p>
<p>GameLisp is designed for games in which most entities are &quot;special&quot; in some way; games where each 
entity's unique features are best described using code, rather than plain data. Because this 
type of game tends to be a poor fit for the ECS pattern, GameLisp wasn't designed with ECS in 
mind. Trying to integrate GameLisp with a pure, strict ECS would be unwise.</p>
<p>However, many games take the middle road: they define a few generalised entity features using 
an ECS, while still permitting individual entities to be scripted using a more traditional 
object-oriented approach. For those games, GameLisp would be a good choice. A few technical 
challenges are discussed in <a href="rglobal.html#using-gamelisp-with-ecs">Section 2</a>.</p>
<h1><a class="header" href="#structs" id="structs">Structs</a></h1>
<p>Objects are fast and space-efficient, especially when they don't contain any <code>state</code> forms. If 
you have a small compound data structure (say, a geometric primitive, or the return value from a 
function), it's usually best to implement it as a class, rather than a table or an array.</p>
<pre><code>(defclass Rect
  (field x)
  (field y)
  (field w)
  (field h)

  (met init (@x @y @w @h))

  (met area ()
    (* @w @h))

  (met op-clone ()
    (Rect @x @y @w @h))

  (met op-eq? (other)
    (let [x y w h] other)
    (and (== @x x) (== @y y) (== @w w) (== @h h))))
</code></pre>
<p>That's a lot of code for something so simple! We provide the <code>defstruct</code> macro to get rid of
the boilerplate:</p>
<pre><code>(defstruct Rect 
  x y w h

  (met area ()
    (* @w @h)))

(prn Rect) ; prints #&lt;class:Rect&gt;
(let rect (Rect:new 10 10 20 20))
(prn rect) ; prints #&lt;obj:Rect&gt;
(prn [rect 'x]) ; prints 10
(prn (.area rect)) ; prints 400
</code></pre>
<p>As demonstrated above, the <code>defstruct</code> macro defines a class with the given named fields. After 
the list of field names, <code>defstruct</code> also accepts zero or more <code>met</code>, <code>prop</code> and <code>const</code> 
clauses. Other class clauses, like <code>init</code>, <code>state</code>, <code>fsm</code>, <code>wrap</code> and <code>mixin</code>, are forbidden.
Classmacros are also forbidden.</p>
<h2><a class="header" href="#struct-initialization" id="struct-initialization">Struct Initialization</a></h2>
<p>When programming in Rust, you will have encountered tuple structs: structs which identify their
fields by position, rather than by name.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Raster {
	pixels: Vec&lt;u32&gt;,
	width: u32,
	height: u32,
	format: ImageFormat
}

// vs.

struct Raster(Vec&lt;u32&gt;, u32, u32, ImageFormat);
<span class="boring">}
</span></code></pre></pre>
<p>Tuple structs with more than one field are generally discouraged. They're hard to understand, 
hard to refactor, and they require more documentation. This is doubly true in a dynamically-typed 
language. For example, if you wanted to change the order of a tuple's fields in a Python
codebase, the language would give you no help at all; it would be a completely manual task.</p>
<p>To encourage the use of named (rather than positional) struct fields, <code>defstruct</code> registers a 
global initialization macro which shares the struct's name. This macro behaves like a Rust struct 
initializer, or like the <code>tab</code> macro:</p>
<pre><code>(defstruct Hit
  hitbox
  strength
  element)

(let hitbox (Rect @x @y w h))

(let fire-punch (Hit
  hitbox
  (strength 35)
  (element 'fire)))

(let ice-punch (Hit
  (element 'ice)
  ..fire-punch))

; the Hit macro resembles a table constructor
(let fire-punch-table (tab
  ('hitbox hitbox)
  ('strength 35)
  ('element 'fire)))
</code></pre>
<p>The original class is bound to the global <code>Name:new</code>. This enables you to easily opt in to
using positional arguments, when you think they would be the better choice.</p>
<pre><code>(defstruct Rgb r g b)

(let named (Rgb (r 32) (g 139) (b 32)))
(let positional (Rgb:new 32 139 32))

(prn (eq? named positional)) ; prints #t
</code></pre>
<p>Finally, the global <code>Name?</code> is bound to a function which tests whether or not a value is
a <code>Name</code> struct. This is more convenient and intuitive than writing <code>(is? val Name)</code> every
time.</p>
<pre><code>(let chartreuse (Rgb 0x7f 0xff 0x00))
(prn (Rgb? chartreuse)) ; prints #t
</code></pre>
<h2><a class="header" href="#operator-overloading" id="operator-overloading">Operator Overloading</a></h2>
<p>The default behaviour of the <code>eq?</code> function, when comparing two objects, is to test them for
<a href="miscellaneous.html#equality">identity</a> using the <code>same?</code> function. This means that two objects
can belong to the same type, and store the same values, but still compare unequal to one
another.</p>
<p>You can override this default behaviour by defining a method named <code>op-eq?</code>.</p>
<p>As noted above, <code>op-eq?</code> is automatically implemented by the <code>defstruct</code> macro. It will compare 
each struct field in turn using <code>eq?</code>.</p>
<pre><code>(defclass Spawner
  (field level) ; a large, immutable table
  (field to-spawn) ; a class
  (field remaining) ; an integer counter

  (met op-eq? (other)
    (and
      (same? @level [other 'level])
      (same? @to-spawn [other 'to-spawn])
      (== @remaining [other 'remaining]))))
</code></pre>
<p>By default, the <code>clone</code> and <code>deep-clone</code> functions only duplicate a reference to an object;
they don't copy the object's storage. You can provide <code>op-clone</code> and <code>op-deep-clone</code> methods to
override this behaviour.</p>
<h1><a class="header" href="#errors-1" id="errors-1">Errors</a></h1>
<p>GameLisp's error-handling story is quite minimalist. Errors silently bubble up through the 
call-stack; they can be caught by the Rust API or caught within GameLisp code; and uncaught errors
print a stack trace and an error message. Internally, they're implemented using <a href="https://doc.rust-lang.org/std/result/"><code>Result</code></a>.</p>
<pre><code>(defmacro add-5 (form)
  `(+ 5 ~form))

(defn recursive (n)
  (cond
    ((&gt; n 0)
      (recursive (- n 1)))
    (else
      (add-5 'symbol))))

(recursive 2)

#|
    stack trace:
        glsp::load(&quot;example.glsp&quot;)
        (recursive) at example.glsp:11
        (recursive) at example.glsp:7
        (recursive) at example.glsp:7
        (add-5) at example.glsp:9
            expanded to (+) at example.glsp:2

    error: non-number passed to a numeric op
|#
</code></pre>
<p>You can manually trigger an error by calling <a href="../std/bail"><code>bail</code></a> or <a href="../std/ensure"><code>ensure</code></a>, 
which resemble Rust's <code>panic!()</code> and <code>assert!()</code> respectively. They accept any number of arguments 
to describe their error message. When two or more error-message arguments are present, those 
arguments are converted to a string, as though they had been passed to the <a href="../std/str"><code>str</code>
function</a>. </p>
<pre><code>(bail &quot;expected {expected-type} but received {(type-of arg)}&quot;)

(ensure (&gt;= [stats 'level] 10) &quot;level is too low. stats: &quot; (pretty-stats))
</code></pre>
<p><code>ensure</code> doesn't actually evaluate its error-message arguments unless an error occurs, so it's 
safe to use expensive function calls when describing the error.</p>
<h2><a class="header" href="#error-recovery" id="error-recovery">Error Recovery</a></h2>
<p>In game development, closing down the release-build executable when an error occurs should be the
last resort - something only done for unrecoverable errors. For some errors, it's safe to simply
log the fact that an error occurred, and then continue executing.</p>
<p>Consider code which loops through each of your game's entities and calls a function to render
them to the screen. If you catch any error produced by an entity's rendering function, and then
move on to the next entity as normal, it could potentially change a catastrophic bug (the
game crashing) into a minor one (&quot;due to a calculation error, the fire elemental's particle effect
sometimes disappears&quot;).</p>
<p>You can catch errors within GameLisp code using the macros <a href="../std/try"><code>try</code></a> and 
<a href="../std/try-verbose"><code>try-verbose</code></a>:</p>
<pre><code>(for entity in draw-list
  (match (try (draw-entity entity))
    (('ok result)
      #n)
    (('err payload)
      (log-error entity payload))))
</code></pre>
<p><code>try</code> evaluates its child forms within an implicit <code>do</code> block. When no error occurs, it returns
the two-element array <code>(ok result)</code>, where the first element is the symbol <code>ok</code>, and the second 
element is the result of evaluating its last child form.</p>
<p>If an error occurs within the <code>try</code> form's dynamic scope - including errors generated internally
by GameLisp, a <code>Result::Err</code> being returned by a Rust function, or even a <code>panic!()</code> within a
Rust function - the <code>try</code> macro will catch the error and return <code>(err payload)</code>, where the first 
element is the symbol <code>err</code> and the second element is a value which represents the error.</p>
<p>When <code>bail</code> or <code>ensure</code> are called with a single argument, that argument will not be converted
into a string. This means that <code>payload</code> can have any type. You could potentially use it to
set up a more structured and formal error-handling scheme.</p>
<pre><code>(let ('err payload) (try (bail 100)))
(prn (int? payload)) ; prints #t

(bail (tab
  ('error-kind 'missing-resource-error)
  ('filename &quot;space-station.lvl&quot;)
  ('resource-name 'laser-rifle)
  ('recoverable #t)))
</code></pre>
<p><code>try-verbose</code> is identical to <code>try</code>, but when an error occurs it returns
<code>(err payload stack-trace)</code>, where <code>stack-trace</code> is a string describing the call-stack when the
error was generated. Stack-trace generation can cost a lot of time, sometimes in excess of one 
millisecond, so <code>try-verbose</code> should be used sparingly.</p>
<h3><a class="header" href="#exception-safety" id="exception-safety">Exception Safety</a></h3>
<p>There is a downside to capturing errors. If a function makes a series of changes which are
globally visible (like mutating an object field, mutating a global variable, or enabling or
disabling a state), an error could cause the function to suddenly stop executing, even if those 
changes are only partially complete. Capturing that error would leave your game in a buggy, 
incoherent state.</p>
<p>It's technically possible to guarantee coherency by using language features like 
<a href="errors.html#cleanup"><code>defer</code></a>, but maintaining <a href="https://en.wikipedia.org/wiki/Exception_safety">exception safety</a> across your whole codebase would be a 
huge engineering challenge. For the average game codebase, it's certainly not worth the effort.</p>
<p>Instead, it's usually best to only capture errors when they originate from &quot;read-only&quot; code 
which doesn't mutate any global data. This might include your rendering code, or the function 
which deserializes a level file, or the function which writes a saved game to the file system. 
When you do capture an error, you should capture it as far down the call stack as possible, to 
limit the number of function calls which it might disrupt.</p>
<h2><a class="header" href="#debugging" id="debugging">Debugging</a></h2>
<p>GameLisp's debugging facilities are not yet very mature.</p>
<p>The <a href="../std/dbg"><code>dbg</code> macro</a> works like Rust's <code>dbg!()</code>: each argument's line number, form and 
return value are printed to the standard error stream.</p>
<pre><code>(let variable 10)
(dbg (+ 2 3) variable)

#|
    prints:

    [example.glsp:2] (+ 2 3) = 5
    [example.glsp:2] variable = 10
|#
</code></pre>
<p>Likewise, the <a href="../std/todo"><code>todo</code> macro</a> is designed to resemble Rust's <code>todo!()</code>. It calls 
<code>(bail)</code> with an error message along the lines of <code>&quot;not yet implemented&quot;</code>.</p>
<p>The <a href="../std/file-location"><code>file-location</code> function</a> returns a brief filename and line number 
as a string, like <code>&quot;scripts/somewhere.glsp:42&quot;</code>. </p>
<p>The <a href="../std/stack-trace"><code>stack-trace</code> function</a> returns a full stack-trace string, as described 
above. </p>
<h2><a class="header" href="#cleanup" id="cleanup">Cleanup</a></h2>
<p>You'll be familiar with the use of <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> in Rust to clean up resources like file handles
and mutex locks.</p>
<p>This type of scoped resource-handling is less common in GameLisp, but you might still need
to execute cleanup code from time to time. This can be achieved using the <a href="../std/defer"><code>defer</code> special
form</a>. <code>defer</code> executes a number of forms when control exits from its enclosing 
lexical scope, whether that's because of normal execution, <code>return</code>, <code>continue</code>, <code>break</code>, 
<code>restart-block</code>, <code>finish-block</code>, or an uncaught error.</p>
<pre><code>; prints: first second third fourth
(defer (prn &quot;fourth&quot;))
(do
  (defer (pr &quot;third &quot;))
  (do
    (defer (pr &quot;second &quot;))
    (pr &quot;first &quot;))
  (bail)
  (prn &quot;this line is unreachable&quot;))
</code></pre>
<p><a href="../std/yield"><code>yield</code></a> is more complicated. With <code>yield</code>, it's possible to leave a lexical scope, 
and then return to it later on using <code>coro-run</code>. Many other languages simply don't perform cleanup 
when yielding out of a coroutine, which can lead to unexpected resource leaks. To avoid this,
we provide the <a href="../std/defer-yield"><code>defer-yield</code> special form</a>, which executes one form every 
time a <code>yield</code> exits its lexical scope, and another form every time <code>coro-run</code> resumes into its 
lexical scope.</p>
<p>The combination of <code>defer</code> and <code>defer-yield</code> is powerful. They allow you to guarantee that a
particular condition holds for the entire duration of a dynamic scope (that is, the forms which
fall within a particular lexical scope, and any functions which those forms call, and any 
functions called by those functions...). We use this to provide the <a href="../std/with-global"><code>with-global</code> 
macro</a>, which overrides the value of a global variable for the duration of a
dynamic scope:</p>
<pre><code>(defmacro with-global (name value-form)
  `(splice
    (let old-value# (global '~name))
    (let new-value# ~value-form)
    (= (global '~name) new-value#)
    (defer
      (= (global '~name) old-value#))
    (defer-yield
      (do
        (= new-value# (global '~name))
        (= (global '~name) old-value#))
      (do
        (= old-value# (global '~name))
        (= (global '~name) new-value#)))))

(defn hello-world ()
  (prn &quot;hello, world&quot;))

; make all prn calls much more exciting within a dynamic scope
(let boring-prn prn)
(with-global prn (fn (..args) (boring-prn ..args &quot;!!!&quot;)))

(hello-world) ; prints hello, world!!!
</code></pre>
<p><code>with-global</code> is as powerful as <a href="https://docs.racket-lang.org/guide/parameterize.html">Racket's parameters</a> and <a href="http://www.gigamonkeys.com/book/variables.html#dynamic-aka-special-variables">Common Lisp's dynamic variables</a>, but we 
were able to implement it as a simple macro, without any special support from the language.</p>
<h2><a class="header" href="#syntax-information" id="syntax-information">Syntax Information</a></h2>
<p>When an array is parsed from a file, it's tagged with a small amount of hidden syntax information 
which indicates the file and line number from which it was parsed. This syntax information is 
essential for reporting a meaningful backtrace when an error occurs.</p>
<p>You normally won't need to think about this. Macros, <code>expand</code> and <code>backquote</code> automatically
generate appropriate syntax information for you.</p>
<p>The exception is when you manually transform one array into another within a macro - for example, 
by calling <code>(arr ..(rev source-arr))</code>. The <code>arr</code> function has no way of knowing that its result 
should be syntactically similar to <code>source-arr</code>, so syntax information is not preserved.</p>
<p>One solution is to <code>clone</code> the source array, and then mutate the resulting array in-place,
perhaps by <code>clear!</code>ing it and then rebuilding it from scratch. <code>clone</code> preserves syntax 
information, so the new array will have the same syntax information as the source array.</p>
<p>Alternatively, the <a href="../std/map-syntax"><code>map-syntax</code> function</a> takes an array and a mapping 
function, and returns a new array with the same syntax information, where each element was 
created by calling <code>(mapper source-element)</code>.</p>
<h1><a class="header" href="#miscellaneous" id="miscellaneous">Miscellaneous</a></h1>
<h2><a class="header" href="#freezing-data" id="freezing-data">Freezing Data</a></h2>
<p>GameLisp's variables and collections are mutable by default. This is convenient, but it can also
be nerve-wracking. It's sometimes difficult to know whether or not you have exclusive ownership of
a collection, so there's always the risk that typing <code>(push! ar x)</code> or <code>(clear! coll)</code> could 
have unintended side-effects in some distant part of your codebase.</p>
<p>The <a href="../std/freeze-mut"><code>freeze!</code> function</a> takes any number of GameLisp values as arguments. 
For each value which refers to an array, string, table, or object, a flag is set on that 
collection which prevents it from being mutated. Future calls to <code>(= [ob 'x] 10)</code>, 
<code>(swap-remove! ar 5)</code> and so on will trigger an error. Frozen collections can never be unfrozen, 
and they can't even be mutated using the Rust API.</p>
<p><code>freeze!</code> is not recursive: you can always mutate a non-frozen collection, even if you're 
accessing it via a frozen collection. To freeze a value <em>and</em> all of the values which it
transitively refers to, use <a href="../std/deep-freeze-mut"><code>deep-freeze!</code></a> instead.</p>
<p>Finally, you'll sometimes want the security of knowing that a global variable can't be 
accidentally mutated. You can enforce this by calling <a href="../std/freeze-global-mut"><code>freeze-global!</code></a>.
(GameLisp automatically freezes a few of the built-in functions, such as <code>+</code>, so that they can be 
optimized more aggressively.)</p>
<pre><code>(def ar (arr (arr 'a 0) (arr 'b 1)))

(push! ar (arr 'c 2))
(prn ar) ; prints ((a 0) (b 1) (c 2))

(freeze-global! 'ar)
;(= ar '()) ; this would be an error

(freeze! ar)
;(push! ar (arr 'd 3)) ; this would be an error
(push! [ar 0] 0)
(prn ar) ; prints ((a 0 0) (b 1) (c 2))

(deep-freeze! ar)
;(push! [ar 1] 1) ; this would be an error
</code></pre>
<h3><a class="header" href="#literals" id="literals">Literals</a></h3>
<p>Using <code>quote</code> or self-evaluating types, it's possible to create multiple aliasing references to 
data which was originally passed in to the <a href="evaluation.html">evaluator</a>. For example:</p>
<pre><code>(loop
  (let ar ())
  (push! ar 1)
  (prn ar))
</code></pre>
<p>Intuitively, you might expect <code>ar</code> to be a fresh, empty array each time it's initialized, so that
the <code>prn</code> call prints <code>(1)</code> every time. Unfortunately, because empty arrays are self-evaluating,
the <code>()</code> form will repeatedly return the same array. This loop would print <code>(1)</code>, then <code>(1 1)</code>, 
then <code>(1 1 1)</code>...</p>
<p>In order to prevent this, whenever GameLisp encounters a <code>quoted</code> or self-evaluating array, string
or table, if it's not already deep-frozen then it will be replaced with a 
<a href="miscellaneous.html#cloning-data">deep-cloned</a>, <a href="miscellaneous.html#freezing-data">deep-frozen</a> copy of itself. This means that 
self-evaluating forms and <code>quoted</code> forms are always immutable, avoiding problems like the above.</p>
<p>To make unintended mutation even less likely, all data produced by the parser is automatically 
frozen. You can <a href="miscellaneous.html#cloning-data">clone</a> the data if you need a mutable copy.</p>
<h2><a class="header" href="#cloning-data" id="cloning-data">Cloning Data</a></h2>
<p>The <a href="../std/clone"><code>clone</code> function</a> receives a single value as its argument. If this value is 
an array, string, table, or iterator, it returns a shallow copy of that value. The copy will be 
mutable, even if the original collection was frozen.</p>
<p>The <a href="../std/deep-clone"><code>deep-clone</code> function</a> shallow-clones its argument, and then recurses 
through to clone any collections referred to by the argument, and any collections referred to 
by <em>those</em> collections, and so on.</p>
<p>Cloning an iterator will never clone the array, string or table which is being iterated, even when 
using <code>deep-clone</code>. When they encounter an iterator, both <code>clone</code> and <code>deep-clone</code> perform just 
enough copying to ensure that <a href="../std/iter-next-mut"><code>iter-next!</code></a> will not modify the original 
iterator.</p>
<h2><a class="header" href="#equality" id="equality">Equality</a></h2>
<p>GameLisp provides four different equality tests. This is a necessary complication: in 
languages like Rust, the <code>==</code> operator is heavily overloaded, which it its own <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">source</a> 
of <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html#method.ptr_eq">complexity</a>.</p>
<p>In GameLisp, the <a href="../std/num-eq"><code>==</code> function</a> specifically tests for numeric equality. It 
exists to complement the other numeric comparison functions: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code> and <code>&gt;</code>. It's an 
error to pass a non-numeric value to <code>==</code>.</p>
<p>The <a href="../std/same-p"><code>same?</code> function</a> tests for <a href="https://en.wikipedia.org/wiki/Identity_(object-oriented_programming)">identity</a>. For all <a href="syntax-and-types.html#type-summary">reference 
types</a>, two references are the <code>same?</code> if they point to the 
same allocation.</p>
<p><code>same?</code> is usually more strict than you'd like. For example, <code>(same? '(1 2) (arr 1 2))</code> will 
return <code>#f</code>, because it sees its arguments as being two distinct arrays, even though they have 
identical contents.</p>
<p>You'll generally want to use the <a href="../std/eq-p"><code>eq?</code> function</a> instead. It differs from <code>same?</code> 
in that arrays, strings and tables are deeply inspected: they compare equal when their contents
are recursively identical.</p>
<p>The final built-in equality test is <code>keys-eqv?</code>, which was 
<a href="tables.html#key-equivalence">discussed previously</a>.</p>
<h3><a class="header" href="#multiple-comparisons" id="multiple-comparisons">Multiple Comparisons</a></h3>
<p>Functions like <code>==</code> and <code>eq?</code> are variadic. <code>(== a b c d)</code> tests whether <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> 
are all <code>==</code> to one another.</p>
<p>If you need to test one value against multiple others, you can use the functions 
<a href="../std/num-eq-any-p"><code>==any?</code></a>, <a href="../std/same-any-p"><code>same-any?</code></a> and 
<a href="../std/eq-any-p"><code>eq-any?</code></a>.</p>
<pre><code>(ensure (eq-any? (coro-state c) 'newborn 'running 'paused 'finished 'poisoned))

(when (same-any? current-room graveyard dungeon prison-cell)
  (inc! fear-level))
</code></pre>
<h2><a class="header" href="#time-and-date" id="time-and-date">Time and Date</a></h2>
<p>Because the Rust standard library only has limited facilities for handling time, the same is
true for GameLisp.</p>
<p>The <a href="../std/time"><code>time</code> function</a> returns a high-precision <a href="https://doc.rust-lang.org/std/time/struct.Instant.html">monotonic timestamp</a> measured in 
seconds, and the <a href="../std/sleep"><code>sleep</code> function</a> suspends the current thread for a specified 
number of seconds. Note that although <code>time</code> should have excellent precision on all platforms, 
<code>sleep</code> is often very imprecise, particularly on Windows. You should prefer to time your main 
loop using an external signal, such as blocking on VSync.</p>
<p>The only date-and-time facility provided by GameLisp is the <a href="../std/unix-time"><code>unix-time</code> 
function</a>, which returns the number of elapsed whole seconds in the 
<a href="https://en.wikipedia.org/wiki/Unix_time">UNIX epoch</a>. In order to avoid the <a href="https://en.wikipedia.org/wiki/Year_2038_problem">2038 problem</a> it returns a string, such as <code>&quot;1153689688&quot;</code>. 
It's intended to be used as a basic timestamp for logging - it can't be readily converted into a 
human-readable format.</p>
<h2><a class="header" href="#last-but-not-least" id="last-but-not-least">Last But <code>(not least)</code>...</a></h2>
<p>The <a href="../std/not"><code>not</code> function</a> returns <code>#t</code> for a <a href="syntax-and-types.html#bool">falsy</a> argument, 
and <code>#f</code> for a <a href="syntax-and-types.html#bool">truthy</a> argument.</p>
<p>The <a href="../std/identity"><code>identity</code> function</a> accepts a single argument and returns it unchanged.
The <a href="../std/no-op"><code>no-op</code> function</a> accepts any number of arguments and returns <code>#n</code>. Both are
occasionally useful as first-class functions.</p>
<p>The <a href="../std/fn0"><code>fn0</code></a> and <a href="../std/fn1"><code>fn1</code></a> macros provide a concise way to define functions
with zero or one arguments. <code>fn1</code> can use a single underscore, <code>_</code>, to refer to its argument. 
Within a <code>fn1</code> form, you should try to avoid discarding a value in a pattern (e.g. 
<code>(match ... (_ x))</code>), since it can be visually confusing.</p>
<pre><code>(ensure (all? (fn1 (eq? _ 'red)) colors) &quot;non-red color detected&quot;)

; ...is equivalent to...

(ensure (all? (fn (color) (eq? color 'red)) colors) &quot;non-red color detected&quot;)
</code></pre>
<p>In Section 2, we'll discuss how to invoke and tune the <a href="garbage-collection.html">garbage collector</a> 
from Rust. You might find that you prefer to do that from within GameLisp, in which case you
can use the functions <a href="../std/gc"><code>gc</code></a> and <a href="../std/gc-value"><code>gc-value</code></a>.</p>
<h2><a class="header" href="#inputoutput" id="inputoutput">Input/Output</a></h2>
<p>You may have noted the conspicuous absence of an input/output (IO) library. GameLisp doesn't
provide any built-in functions for filesystem access, beyond <code>load</code>, <code>require</code> and <code>include</code>.</p>
<p>This is a deliberate design choice. IO is a huge topic: a full-featured IO library
for game development would need to include byte streams, compression, string streams, stdio,
text encodings, networking, non-blocking io, sandboxing, logging... the list goes on.</p>
<p>Meanwhile, your game engine will almost certainly have its own opinions about how filesystem and 
network access should be done. Something as simple as storing your game's assets in a .zip
file might make the entire IO library unusable!</p>
<p>Instead, you're encouraged to use the <a href="the-rust-api.html">Rust API</a> to bind your engine's existing 
APIs to GameLisp.</p>
<h1><a class="header" href="#the-rust-api" id="the-rust-api">The Rust API</a></h1>
<p>This section will take you on a guided tour of the <code>glsp</code> crate: the Rust API which can be used
to create and manipulate a GameLisp runtime.</p>
<p>Binding script code to native code tends to be a pain point when using languages like Lua
and Python. GameLisp leverages Rust's powerful type system and macro system to make its interface 
with Rust as seamless as possible.</p>
<h1><a class="header" href="#the-glsp-crate" id="the-glsp-crate">The <code>glsp</code> Crate</a></h1>
<p>Let's take another look at the skeleton project from the <a href="overview.html">Overview</a> chapter:</p>
<pre><pre class="playpen"><code class="language-rust">use glsp::prelude::*;

fn main() {
	let runtime = Runtime::new();
	runtime.run(|| {
		glsp::load(&quot;main.glsp&quot;)?;
		Ok(())
	});
}
</code></pre></pre>
<p>The main player here is the <a href="https://docs.rs/glsp/*/glsp/struct.Runtime.html"><code>Runtime</code> type</a>. 
It owns all of the data required to run a single GameLisp instance: a garbage‑collected heap, 
a symbol registry and a call stack, among other things. When the <code>Runtime</code> is dropped, all of that 
data is automatically freed.</p>
<p>There can be many simultaneous <code>Runtimes</code> in a program, and a <code>Runtime</code> can be created
on any thread, but <code>Runtimes</code> (and handles to the data inside them) can never be moved from one 
thread to another. Although GameLisp can be gracefully integrated into a multithreaded program, 
each individual GameLisp runtime is entirely single-threaded.</p>
<h2><a class="header" href="#the-active-runtime" id="the-active-runtime">The Active Runtime</a></h2>
<p>Unusually for a Rust library, the <code>glsp</code> crate uses <a href="https://doc.rust-lang.org/std/macro.thread_local.html"><code>thread_local</code> storage</a> internally. 
This means that there's no need to pass around a context object (aka &quot;God object&quot;), because that 
would make the crate much less convenient to use.</p>
<p>Instead, each thread has a hidden <code>thread_local</code> pointer to its active <code>Runtime</code>. The <code>rt.run(...)</code>
method sets <code>rt</code> to be the active <code>Runtime</code>, executes an arbitrary closure, and then restores the 
<code>Runtime</code> which was previously active, if any.</p>
<p>The <code>glsp</code> crate contains a large number of free functions, like <a href="https://docs.rs/glsp/*/glsp/fn.sym.html"><code>glsp::sym</code></a>, which 
manipulate the active <code>Runtime</code> via that <code>thread_local</code> pointer. If these functions are called 
when no <code>Runtime</code> is active, they panic.</p>
<p>Most of the functions closely imitate an equivalent function which is built in to GameLisp.
For example, <a href="https://docs.rs/glsp/*/glsp/fn.sym.html"><code>glsp::sym</code></a> is equivalent to the <a href="../std/sym"><code>sym</code> function</a>, and <a href="https://docs.rs/glsp/*/glsp/fn.load.html"><code>glsp::load</code></a> 
is equivalent to <a href="../std/load"><code>load</code></a>.</p>
<p>Most games will have no need for multiple <code>Runtimes</code>. The simplest way to use GameLisp is to 
create a single <code>Runtime</code> at program start, and immediately make it active by calling its 
<a href="https://docs.rs/glsp/*/glsp/struct.Runtime.html#method.run"><code>run()</code> method</a>, passing in a closure which lasts for the entire duration of your program's
<code>main</code> function.</p>
<pre><pre class="playpen"><code class="language-rust">use glsp::prelude::*;

fn main() {
	let runtime = Runtime::new();
	runtime.run(|| {
		
		//...your entire program executes within this scope...

		Ok(())
	});
}
</code></pre></pre>
<h2><a class="header" href="#types" id="types">Types</a></h2>
<p>To introduce a few of the crate's most important types:</p>
<ul>
<li>
<p><a href="https://docs.rs/glsp/*/glsp/enum.Val.html"><code>Val</code></a> is the enum which represents a GameLisp value. Each variant corresponds to 
one of the sixteen <a href="syntax-and-types.html#type-summary">primitive types</a>.</p>
</li>
<li>
<p><a href="https://docs.rs/glsp/*/glsp/struct.Sym.html"><code>Sym</code></a> represents a GameLisp symbol. It's a small <code>Copy</code> type which just wraps a
<code>u32</code> identifier.</p>
</li>
<li>
<p><a href="https://docs.rs/glsp/*/glsp/struct.Root.html"><code>Root</code></a> is a smart pointer which refers to something stored on the garbage-collected 
heap. It points to a struct which represents one of GameLisp's primitive types, such as 
<a href="https://docs.rs/glsp/*/glsp/struct.Arr.html"><code>Root&lt;Arr&gt;</code></a> for an array or <a href="https://docs.rs/glsp/*/glsp/struct.Coro.html"><code>Root&lt;Coro&gt;</code></a> for a coroutine. Such types can only be accessed
using a <code>Root</code>; your program will never take direct ownership of an <a href="https://docs.rs/glsp/*/glsp/struct.Arr.html"><code>Arr</code></a> or a <a href="https://docs.rs/glsp/*/glsp/struct.Coro.html"><code>Coro</code></a>.</p>
</li>
<li>
<p><a href="https://docs.rs/glsp/*/glsp/struct.GFn.html"><code>GFn</code></a> is the name for GameLisp's <code>fn</code> primitive type, to avoid confusion with Rust's
<code>Fn</code> trait. Similarly, the GameLisp type <code>iter</code> is represented by the Rust type <a href="https://docs.rs/glsp/*/glsp/struct.GIter.html"><code>GIter</code></a>.</p>
</li>
</ul>
<h3><a class="header" href="#moving-data-between-runtimes" id="moving-data-between-runtimes">Moving Data Between Runtimes</a></h3>
<p>Types which represent GameLisp data, like <code>Root</code>, <code>Val</code> and <code>Sym</code>, are closely linked to the
specific <code>Runtime</code> in which they were constructed. You shouldn't attempt to manipulate GameLisp 
data when there's no active <code>Runtime</code>, and you should never move GameLisp data from one <code>Runtime</code> 
to another.</p>
<p>For example, if you return a <code>Val</code> from <code>Runtime::run</code>, and then attempt to print it, your
program will panic. If you construct a symbol in one <code>Runtime</code>, and attempt to compare it
to a symbol from a different <code>Runtime</code>, the comparison may return a false positive or false
negative.</p>
<p>Moving data between <code>Runtimes</code> is always memory-safe, but the results are otherwise undefined.
Under some rare circumstances, in order to preserve memory safety, GameLisp may be forced to 
<a href="https://doc.rust-lang.org/std/process/fn.abort.html">abort the process</a>!</p>
<h2><a class="header" href="#generic-conversions" id="generic-conversions">Generic Conversions</a></h2>
<p>Functions and methods in the <code>glsp</code> crate tend to be highly generic, to keep manual type 
conversions to a minimum.</p>
<p>For example, this is the signature of the <a href="https://docs.rs/glsp/*/glsp/fn.global.html"><code>glsp::global</code></a> function, which is designed
to imitate GameLisp's <code>(global)</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn global&lt;S, T&gt;(s: S) -&gt; GResult&lt;T&gt; where
    S: ToSym,
    T: FromVal, 
<span class="boring">}
</span></code></pre></pre>
<p>The <a href="https://docs.rs/glsp/*/glsp/trait.ToSym.html"><code>ToSym</code></a> trait converts something to a symbol, and the <a href="https://docs.rs/glsp/*/glsp/trait.FromVal.html"><code>FromVal</code></a> trait is implemented by 
anything which can be fallibly converted from a <a href="https://docs.rs/glsp/*/glsp/enum.Val.html"><code>Val</code></a>. In practice, this means that the function 
can be called like this...</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let frames: u32 = glsp::global(&quot;frames&quot;)?;
<span class="boring">}
</span></code></pre></pre>
<p>...rather than needing a mess of explicit type conversions:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let frames = u32::from_val(&amp;glsp::global(glsp::sym(&quot;frames&quot;)?)?)?;
<span class="boring">}
</span></code></pre></pre>
<p>The only downside is that with so many generic types, Rust's type inference will sometimes get 
confused. Rust doesn't yet allow you to <a href="https://github.com/rust-lang/rfcs/pull/2522">put type annotations wherever you please</a>, so under
those circumstances, you'll usually need to introduce a temporary local variable with an
explicit type.</p>
<p>In particular, for functions like <a href="https://docs.rs/glsp/*/glsp/fn.call.html"><code>glsp::call</code></a> which have a generic return value, the type of
the return value must be specified explicitly, even when it's discarded.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>//an error
glsp::call(&amp;my_gfn, &amp;(1, 2, 3))?;

//correct
let _: Val = glsp::call(&amp;my_gfn, &amp;(1, 2, 3))?;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#comprehensive-coverage" id="comprehensive-coverage">Comprehensive Coverage</a></h2>
<p>The <code>glsp</code> crate aims to be comprehensive: if it's possible to achieve something in GameLisp code,
it should also be possible to achieve it in Rust. It's usually possible for any GameLisp code to be
translated into (much uglier) Rust code line-by-line.</p>
<pre><code>(for plant in plants
  (when (&lt; [plant 'height] 100)
    (.grow plant 10)))
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let plants: Root&lt;Arr&gt; = glsp::global(&quot;plants&quot;)?;
for val in plants.iter() {
	let plant = Root::&lt;Obj&gt;::from_val(&amp;val)?;
    let height: i32 = plant.get(&quot;height&quot;)?;
    if height &lt; 100 {
        let _: Val = plant.call(&quot;grow&quot;, &amp;(10,))?;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#the-prelude" id="the-prelude">The Prelude</a></h2>
<p>Importing the <a href="https://docs.rs/glsp/*/glsp/prelude/index.html"><code>glsp::prelude::*</code></a> module will pull in all of the most commonly-used names 
from the <code>glsp</code> crate, except for the free functions: <code>glsp::bind_global()</code> doesn't become 
<code>bind_global()</code>. </p>
<p>I can't overstate how much more convenient this is, compared to manually adding and removing 
dozens of imports to every file. If name collisions occur, they can be disambiguated via renaming:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use glsp::prelude::*;
use num::Num as NumTrait;
use error_chain::bail as ec_bail;
<span class="boring">}
</span></code></pre></pre>
<p>If glob imports aren't to your taste, naturally there's nothing stopping you from importing
names individually instead.</p>
<h2><a class="header" href="#sandboxing" id="sandboxing">Sandboxing</a></h2>
<p><a href="https://docs.rs/glsp/*/glsp/struct.Runtime.html#method.new"><code>Runtime::new()</code></a> creates a default <code>Runtime</code>. It's also possible to use the 
<a href="https://docs.rs/glsp/*/glsp/struct.RuntimeBuilder.html"><code>RuntimeBuilder</code> struct</a> to configure a <code>Runtime</code> before creating it.</p>
<p>Currently, the only configuration setting is <a href="https://docs.rs/glsp/*/glsp/struct.RuntimeBuilder.html#method.sandboxed"><code>sandboxed</code></a>, which defaults to <code>false</code>. A sandboxed
<code>Runtime</code> does not provide any of the built-in GameLisp functions which access the filesystem - 
namely <a href="../std/load"><code>load</code></a>, <a href="../std/include"><code>include</code></a> and <a href="../std/require"><code>require</code></a>. 
Untrusted GameLisp code can get up to all sorts of mischief even without filesystem access, so 
you should still proceed with great caution when running it.</p>
<h2><a class="header" href="#output-streams-1" id="output-streams-1">Output Streams</a></h2>
<p>By default, <a href="../std/prn-fn"><code>prn</code></a> will print its output to <a href="https://doc.rust-lang.org/std/io/struct.Stdout.html"><code>std::io::Stdout</code></a>, and 
<a href="../std/eprn"><code>eprn</code></a> will print its output to <a href="https://doc.rust-lang.org/std/io/struct.Stderr.html"><code>std::io::Stderr</code></a>.</p>
<p>It's possible to replace those streams with an arbitrary <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>std::io::Write</code></a> type using the 
functions <a href="https://docs.rs/glsp/*/glsp/fn.set_pr_writer.html"><code>glsp::set_pr_writer</code></a> and <a href="https://docs.rs/glsp/*/glsp/fn.set_epr_writer.html"><code>glsp::set_epr_writer</code></a>. For example, to 
discard both streams:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::io::sink;

glsp::set_pr_writer(Box::new(sink()));
glsp::set_epr_writer(Box::new(sink()));
<span class="boring">}
</span></code></pre></pre>
<p>Or to send output to a log file and also to the standard output streams:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::io::{self, stdout, stderr, Write};

struct Tee&lt;A: Write, B: Write&gt;(A, B);

impl&lt;A: Write, B: Write&gt; Write for Tee&lt;A, B&gt; {
	fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {
		self.0.write_all(buf).and_then(|_| self.1.write_all(buf))?;
		Ok(buf.len())
	}

	fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; {
		self.0.flush().and_then(|_| self.1.flush())
	}
}

//defining a cloneable file handle is left as an exercise for the reader
let log_file = SharedFile::new(&quot;log.txt&quot;);
glsp::set_pr_writer(Box::new(Tee(log_file.clone(), stdout())));
glsp::set_epr_writer(Box::new(Tee(log_file.clone(), stderr())));
<span class="boring">}
</span></code></pre></pre>
<p>Unless you <a href="https://github.com/rust-lang/rust/issues/31343">manually override them</a>, the Rust 
macros <code>print!()</code>, <code>println!()</code>, <code>eprint!()</code> and <code>eprintln!()</code> will still print to the standard
output and standard error streams. As an alternative, you can use the macros <a href="https://docs.rs/glsp/*/glsp/macro.pr.html"><code>pr!()</code></a>, <a href="https://docs.rs/glsp/*/glsp/macro.prn.html"><code>prn!()</code></a>,
<a href="https://docs.rs/glsp/*/glsp/macro.epr.html"><code>epr!()</code></a> and <a href="https://docs.rs/glsp/*/glsp/macro.eprn.html"><code>eprn!()</code></a> to print to the active <code>Runtime</code>'s <code>pr_writer</code> and <code>epr_writer</code>.</p>
<h1><a class="header" href="#collection-types" id="collection-types">Collection Types</a></h1>
<p>The collection types are <a href="https://docs.rs/glsp/*/glsp/struct.Arr.html"><code>Arr</code></a> for arrays, <a href="https://docs.rs/glsp/*/glsp/struct.Str.html"><code>Str</code></a> for strings, and <a href="https://docs.rs/glsp/*/glsp/struct.Tab.html"><code>Tab</code></a> for tables. Their 
API has a few quirks to bear in mind.</p>
<h2><a class="header" href="#error-handling" id="error-handling">Error-Handling</a></h2>
<p>We try to keep panics to an absolute minimum. Because there are a lot of things which can
potentially go wrong when interacting with a collection (out-of-bounds errors, failed type
conversions, mutating a borrowed collection), almost every collection method returns a
<a href="https://docs.rs/glsp/*/glsp/type.GResult.html"><code>GResult</code></a>. You'll need to make generous use of the <code>?</code> operator.</p>
<h2><a class="header" href="#interior-mutability" id="interior-mutability">Interior Mutability</a></h2>
<p>All of the collection types are both aliasable and mutable - in Rust, this requires <a href="https://doc.rust-lang.org/reference/interior-mutability.html">interior 
mutability</a>. There are two ways 
this could potentially have worked:</p>
<ul>
<li>
<p>Allow the Rust programmer to explicitly lock the interior of the type, as though working with
a <a href="https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html"><code>RefCell</code></a>, and then mutate it freely - perhaps even directly accessing the internal storage.</p>
</li>
<li>
<p>Build the API around &quot;atomic&quot; method calls which lock the type, do something to it, and then 
unlock it before returning.</p>
</li>
</ul>
<p>GameLisp previously chose the first solution, but it ended up cluttering the Rust code with
too many calls to <code>borrow()</code> and <code>borrow_mut()</code>, so we switched to the second option. The
second option also causes fewer lifetime problems in practice, since <code>borrow()</code> handles tend to be 
scoped for a longer lifetime than necessary.</p>
<p>The only methods which aren't completely atomic are those which <a href="collection-types.html#iteration">create a Rust iterator</a> 
over a collection. If a collection is mutated while Rust code is iterating over it, an error will 
occur.</p>
<p>Because we don't allow the caller to create direct references into a collection's storage, none of
our collections can be indexed using Rust's <code>[]</code> syntax. You'll need to use the <code>get()</code> and
<code>set()</code> methods instead.</p>
<h2><a class="header" href="#construction" id="construction">Construction</a></h2>
<p>There is no way to place an <code>Arr</code>, <code>Str</code> or <code>Tab</code> directly on the Rust stack. Instead, they're
always accessed indirectly via a <code>Root</code> smart pointer: <code>Root&lt;Arr&gt;</code>, <code>Root&lt;Str&gt;</code>, <code>Root&lt;Tab&gt;</code>.</p>
<p>New collections can be allocated using global functions in the <code>glsp</code> namespace, such as
<a href="https://docs.rs/glsp/*/glsp/fn.arr.html"><code>glsp::arr</code></a>, <a href="https://docs.rs/glsp/*/glsp/fn.str_from_iter.html"><code>glsp::str_from_iter</code></a>, and <a href="https://docs.rs/glsp/*/glsp/fn.tab_with_capacity.html"><code>glsp::tab_with_capacity</code></a>.</p>
<p>Alternatively, we provide convenience macros for constructing each type of collection, in the
same spirit as Rust's <a href="https://doc.rust-lang.org/stable/std/macro.vec.html"><code>vec![]</code> macro</a>.</p>
<p><a href="https://docs.rs/glsp/*/glsp/macro.arr.html"><code>arr!</code></a> constructs a new array, returning it as a <code>Root&lt;Arr&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>arr![];
arr![elem; n]; //elem, repeated n times
arr![100i32, 20u8, &quot;hello&quot;, arr![]]; //types are converted using the IntoVal trait
arr![a, ..src, b]; //splays the contents of src using the Splay trait
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/glsp/*/glsp/macro.str.html"><code>str!</code></a> has the same syntax as Rust's <a href="https://doc.rust-lang.org/std/fmt/"><code>format!</code></a> macro, but it returns a <code>Root&lt;Str&gt;</code>
rather than a <code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>str!(&quot;&quot;);
str!(&quot;hello, str&quot;);
str!(&quot;{}, {}&quot;, &quot;hello&quot;, glsp::sym(&quot;str&quot;)?);
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/glsp/*/glsp/macro.tab.html"><code>tab!</code></a> constructs a new table from a number of key-value pairs. Optionally, it can
clone another table and then insert each of the key-value pairs into it, similar to Rust's
<a href="https://doc.rust-lang.org/reference/expressions/struct-expr.html#functional-update-syntax">struct update syntax</a>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let empty_tab = tab! { };

let base_tab = tab! {
	(glsp::sym(&quot;a&quot;)?, 1),
	(glsp::sym(&quot;b&quot;)?, 2)
};

let extended_tab = tab! {
	(glsp::sym(&quot;b&quot;)?, 20),
	(glsp::sym(&quot;c&quot;)?, 30),
	..base_tab
};

assert!(extended_tab.len() == 3);
<span class="boring">}
</span></code></pre></pre>
<p>Conversion to a <a href="https://docs.rs/glsp/*/glsp/enum.Val.html"><code>Val</code></a> is fallible: the <a href="https://docs.rs/glsp/*/glsp/macro.arr.html"><code>arr!</code></a> and <a href="https://docs.rs/glsp/*/glsp/macro.tab.html"><code>tab!</code></a> macros will panic if you pass them 
something which can't be represented as a <a href="https://docs.rs/glsp/*/glsp/enum.Val.html"><code>Val</code></a>, like <code>std::u32::MAX</code>. In the unlikely event
that you need to catch this type of error, the <a href="https://docs.rs/glsp/*/glsp/macro.try_arr.html"><code>try_arr!</code></a> and <a href="https://docs.rs/glsp/*/glsp/macro.try_tab.html"><code>try_tab!</code></a> macros are 
identical to their counterparts, except that they return a <a href="https://docs.rs/glsp/*/glsp/type.GResult.html"><code>GResult&lt;Root&lt;_&gt;&gt;</code></a>.</p>
<h2><a class="header" href="#deques" id="deques">Deques</a></h2>
<p>Within GameLisp, arrays and strings both support the <code>deque</code> interface, so that it's possible to
write a function which is generic over both types. The same is true for their Rust API.</p>
<p>The relevant traits are <a href="https://docs.rs/glsp/*/glsp/trait.DequeOps.html"><code>DequeOps</code></a>, <a href="https://docs.rs/glsp/*/glsp/trait.DequeAccess.html"><code>DequeAccess</code></a> and <a href="https://docs.rs/glsp/*/glsp/trait.DequeAccessRange.html"><code>DequeAccessRange</code></a>. You'll need to 
make sure those traits are in scope (perhaps by importing the 
<a href="the-glsp-crate.html#the-prelude">prelude</a>) when working with arrays or strings.</p>
<p>The <a href="https://docs.rs/glsp/*/glsp/trait.DequeAccess.html"><code>DequeAccess</code></a> and <a href="https://docs.rs/glsp/*/glsp/trait.DequeAccessRange.html"><code>DequeAccessRange</code></a> implementations are generic over 
all of Rust's built-in integer types, so there's no need to convert indexes to <code>usize</code>. Negative 
indexes count backwards from the end of the deque.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let n: f32 = arr.get(30_u8)?;
arr.set(-1, n * 2.0)?;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#type-erasure" id="type-erasure">Type Erasure</a></h3>
<p>If you need to define a variable, field or non-generic function argument which can be either a
<code>Root&lt;Arr&gt;</code> or a <code>Root&lt;Str&gt;</code>, you can use the <a href="https://docs.rs/glsp/*/glsp/enum.Deque.html"><code>Deque</code></a> enum. It implements the <a href="https://docs.rs/glsp/*/glsp/trait.DequeOps.html"><code>DequeOps</code></a>,
<a href="https://docs.rs/glsp/*/glsp/trait.DequeAccess.html"><code>DequeAccess</code></a> and <a href="https://docs.rs/glsp/*/glsp/trait.DequeAccessRange.html"><code>DequeAccessRange</code></a> traits, so you don't need to unwrap it in order to 
manipulate its contents.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn push_one_pop_one(deq: Deque, to_push: Val) -&gt; GResult&lt;Val&gt; {
	deq.push(to_push)?;
	deq.pop_start()
}
<span class="boring">}
</span></code></pre></pre>
<p>There are similar enums for GameLisp's other <a href="syntax-and-types.html#abstract-types">abstract types</a>:</p>
<ul>
<li>
<p><a href="https://docs.rs/glsp/*/glsp/enum.Num.html"><code>Num</code></a> stores an <code>i32</code> or <code>f32</code>. It supports all of Rust's arithmetic operators, and
also a subset of Rust's standard API for integer types, like the <a href="https://doc.rust-lang.org/std/primitive.i32.html#method.div_euclid"><code>div_euclid()</code></a> method.</p>
</li>
<li>
<p><a href="https://docs.rs/glsp/*/glsp/enum.Callable.html"><code>Callable</code></a> stores those primitive types which can receive a GameLisp function call.</p>
</li>
<li>
<p><a href="https://docs.rs/glsp/*/glsp/enum.Expander.html"><code>Expander</code></a> stores those primitive types which can be used as a macro expander.</p>
</li>
<li>
<p><a href="https://docs.rs/glsp/*/glsp/enum.Iterable.html"><code>Iterable</code></a> stores those primitive types which can be used to construct a <a href="https://docs.rs/glsp/*/glsp/struct.GIter.html"><code>GIter</code></a>.</p>
</li>
</ul>
<h2><a class="header" href="#iteration-1" id="iteration-1">Iteration</a></h2>
<p>Collections provide three separate iteration methods. </p>
<p><code>iter()</code> is an infallible iterator which returns the collection's natural type: <code>Val</code> for <code>Arr</code>, 
<code>char</code> for <code>Str</code> and <code>(Val, Val)</code> for <code>Tab</code>.</p>
<p><code>iter_to&lt;T&gt;()</code> performs type conversion from its natural type to <code>T</code>. Because type conversion is
fallible, the iterator's <code>Item</code> type is <a href="https://docs.rs/glsp/*/glsp/type.GResult.html"><code>GResult&lt;T&gt;</code></a>, so each item will need to be individually
unwrapped.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut counter = 0u32;
for n in arr.iter_to::&lt;u32&gt;() {
	counter += n?;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>giter()</code> allocates and returns a new GameLisp iterator, <code>Root&lt;GIter&gt;</code>, over the collection.</p>
<p>Due to some limitations in Rust's type system, it's not possible to call iteration methods on a
<code>Tab</code> directly. Instead, you'll need to use the <a href="https://docs.rs/glsp/*/glsp/struct.Tab.html#method.entries"><code>entries()</code></a> adapter method: for example,
<a href="https://docs.rs/glsp/*/glsp/struct.TabEntries.html#method.iter"><code>tab.entries().iter()</code></a> or <a href="https://docs.rs/glsp/*/glsp/struct.TabEntries.html#method.keys_to"><code>tab.entries().keys_to::&lt;u32&gt;()</code></a>.</p>
<h2><a class="header" href="#cloning" id="cloning">Cloning</a></h2>
<p>The <code>clone()</code> method name has already been claimed by Rust. If you call <code>clone()</code> for a 
<code>Root&lt;Arr&gt;</code>, it will create a new <code>Root</code> which refers to the same array, rather than cloning the 
array itself.</p>
<p>When you need to clone the <em>contents</em> of a collection, the correct methods are <code>shallow_clone()</code> 
and <code>deep_clone()</code>.</p>
<h1><a class="header" href="#rust-bindings" id="rust-bindings">Rust Bindings</a></h1>
<p>In game development, scripting languages like GameLisp are used to provide a simple, convenient
interface to the game engine. If you need to change some small detail of your game, you'll have 
a much more pleasant experience editing a GameLisp or Lua script, rather than directly hacking 
on your engine's Rust or C++ code.</p>
<p>Most game engines will, therefore, include sprawling cross-language bindings which enable large
parts of the engine to be controlled by scripts. Scripts might need to construct native types, 
invoke native functions and methods, manipulate global data, and otherwise exert fine control 
over the engine.</p>
<p>Historically, this has been - not to put too fine a point on it - terrible. The APIs to bind
a native language to a scripting language usually feel like an afterthought. They're often
awkward to use, unsafe, and incomplete. This friction between the native language and the 
scripting language can act as a large, unnecessary maintenance burden.</p>
<p>Before discussing GameLisp's approach to this problem, let's take a tour of some existing
scripting language bindings. The task is simple: Define a global function which can be used to 
construct an empty OpenGL 2D texture, returning it as a scripting-language object. Then, attach 
two methods to that object so that the texture's width and height can be queried by scripts.</p>
<h2><a class="header" href="#lua" id="lua">Lua</a></h2>
<p><a href="https://lua.org/">Lua</a> is the most popular game scripting language in existence.</p>
<p>Because Lua is written in C, its built-in foreign function interface comes with some major 
ergonomic problems. Rather than being based around normal function calls, arguments and return 
values, it instead requires the user to indirectly manipulate an opaque &quot;stack&quot; of Lua values.</p>
<pre><code class="language-c">typedef struct Texture {
	GLuint tex_id;
	GLsizei width;
	GLsizei height;
} Texture;

static int create_texture(lua_State* L) {
	/* receive two integer arguments as &quot;width&quot; and &quot;height&quot; */
	int width = luaL_checkinteger(L, 1);
	int height = luaL_checkinteger(L, 2);

	/* generate the OpenGL texture object itself */
	GLuint tex_id = 0;
	glGenTextures(1, &amp;tex_id);
	glBindTexture(GL_TEXTURE_2D, tex_id);
	glTexImage2D(
		GL_TEXTURE_2D, 0, GL_RGBA, width, height, 
		0, GL_RGBA, GL_UNSIGNED_BYTE, NULL
	);
	assert(glGetError() == GL_NO_ERROR);

	/* allocate a Texture object as a Lua userdata, push
	   it to the stack, and initialize it */
	Texture* texture = (Texture*) lua_newuserdata(L, sizeof(Texture));
	texture-&gt;tex_id = tex_id;
	texture-&gt;width = width;
	texture-&gt;height = height;

	/* push the Texture metatable to the stack, then pop it and
	   attach it to the userdata */
	luaL_getmetatable(L, &quot;Texture&quot;);
	lua_setmetatable(L, -2);

	/* return the userdata to the caller, via the stack */
	return 1;
}

static int texture_get_width(lua_State* L) {
	/* receive a Texture userdata as the first argument */
	Texture* texture = (Texture*) luaL_checkudata(L, 1, &quot;Texture&quot;);

	/* push its width onto the stack and return it */
	lua_pushinteger(L, texture-&gt;width);
	return 1;
}

static int texture_get_height(lua_State* L) {
	/* receive a Texture userdata as the first argument */
	Texture* texture = (Texture*) luaL_checkudata(L, 1, &quot;Texture&quot;);

	/* push its height onto the stack and return it */
	lua_pushinteger(L, texture-&gt;height);
	return 1;
}

void init(lua_State* L) {
	/* construct the Texture metatable */
	luaL_newmetatable(L, &quot;Texture&quot;);

	/* push the string key &quot;__index&quot; to the stack */
	lua_pushstring(L, &quot;__index&quot;);

	/* construct a table which contains the width/height accessor
	   functions, bound to the string keys &quot;width&quot; and &quot;height&quot; */
	lua_createtable(L, 0, 2);

	lua_pushstring(L, &quot;width&quot;);
	lua_pushcfunction(L, texture_get_width);
	lua_settable(L, -3);

	lua_pushstring(L, &quot;height&quot;);
	lua_pushcfunction(L, texture_get_height);
	lua_settable(L, -3);

	/* bind that table to the Texture metatable's &quot;__index&quot; key */
	lua_settable(L, -3);

	/* remove the Texture metatable from the stack */
	lua_pop(L, 1);

	/* bind the create_texture function to a global variable */
	lua_register(L, &quot;create_texture&quot;, create_texture);
}
</code></pre>
<p>I believe this code speaks for itself! Let's move on...</p>
<h2><a class="header" href="#luabridge" id="luabridge">LuaBridge</a></h2>
<p><a href="https://github.com/vinniefalco/LuaBridge">LuaBridge</a> is an excellent third-party library which 
hides all of the above complexity by exploiting C++'s template system.</p>
<pre><code class="language-c++">class Texture {
  public:
	Texture(GLsizei width, GLsizei height)
	: mTexId(0), mWidth(width), mHeight(height)
	{
		//generate the OpenGL texture object itself
		glGenTextures(1, &amp;mTexId);
		glBindTexture(GL_TEXTURE_2D, mTexId);
		glTexImage2D(
			GL_TEXTURE_2D, 0, GL_RGBA, width, height, 
			0, GL_RGBA, GL_UNSIGNED_BYTE, NULL
		);
		assert(glGetError() == GL_NO_ERROR);
	}

	GLsizei width() { return mWidth; }
	GLsizei height() { return mHeight; }

  private:
	GLuint mTexId;
	GLsizei mWidth;
	GLsizei mHeight;
};

void init(lua_State* L) {
	luabridge::getGlobalNamespace(L)
		.beginClass&lt;Texture&gt;(&quot;Texture&quot;)
			.addConstructor&lt;void (*) (::GLsizei, ::GLsizei)&gt;()
			.addFunction(&quot;width&quot;, &amp;Texture::width)
			.addFunction(&quot;height&quot;, &amp;Texture::height)
		.endClass();
}
</code></pre>
<p>This is a huge improvement - LuaBridge has taken the dozens of lines of confusing glue code we 
saw above, and trimmed them down to only six lines!</p>
<p>Notice that LuaBridge is capable of binding <em>existing</em> C++ code to Lua, without requiring 
the user to rewrite any of their native code, or write wrapper functions to translate Lua 
data into C++ data. The constructor for the <code>Texture</code> class, and its <code>width()</code> and <code>height()</code> 
methods, are the sort of code you might write even if you weren't working with Lua at all. 
Arguments and return values are automatically translated, and so the glue code &quot;just works&quot;. 
This is about as good as it gets!</p>
<p>Unfortunately, LuaBridge is built on top of C++'s template system. Rust doesn't have
a template system - its trait system is much more safe and rigorous, but also much more
restrictive. In Rust, this kind of magic trick is more difficult to pull off.</p>
<h2><a class="header" href="#rlua" id="rlua"><code>rlua</code></a></h2>
<p><a href="https://github.com/amethyst/rlua"><code>rlua</code></a> is a high-level set of Lua bindings for Rust.
In my opinion, it's the best Lua-to-Rust binding currently available.</p>
<p>Here is the Rust code which we'll be trying to bind from here on:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use gl::types::{GLint, GLsizei, GLuint};
use std::ptr::{null};

struct Texture {
	tex_id: GLuint,
	width: GLsizei,
	height: GLsizei
}

impl Texture {
	fn empty(width: GLsizei, height: GLsizei) -&gt; Texture {
		let mut tex_id = 0;

		unsafe {
			//generate the OpenGL texture object itself
			gl::GenTextures(1, &amp;mut tex_id);
			gl::BindTexture(gl::TEXTURE_2D, tex_id);
			gl::TexImage2D(
				gl::TEXTURE_2D, 0, gl::RGBA as GLint, width, height,
				0, gl::RGBA, gl::UNSIGNED_BYTE, null()
			);
			assert!(gl::GetError() == gl::NO_ERROR);
		}

		//construct the Texture
		Texture { tex_id, width, height }
	}

	fn width(&amp;self) -&gt; GLsizei { self.width }
	fn height(&amp;self) -&gt; GLsizei { self.height }
}
<span class="boring">}
</span></code></pre></pre>
<p>And here's the <code>rlua</code> glue code:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use rlua::{Context, prelude::LuaResult, UserData, UserDataMethods};

impl UserData for Texture {
	fn add_methods&lt;'lua, M: UserDataMethods&lt;'lua, Self&gt;&gt;(methods: &amp;mut M) {
		methods.add_method(&quot;width&quot;, |_, this, _: ()| {
			Ok(this.width())
		});

		methods.add_method(&quot;height&quot;, |_, this, _: ()| {
			Ok(this.height())
		});
	}
}

fn init(lua_ctx: Context) -&gt; LuaResult&lt;()&gt; {
	let create_texture = lua_ctx.create_function(
		|_, (width, height): (GLsizei, GLsizei)| {
			Ok(Texture::empty(width, height))
		}
	)?;

	let globals = lua_ctx.globals();
	globals.set(&quot;create_texture&quot;, create_texture)?;

	Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><code>rlua</code> is a great library, but this glue code is definitely a backwards step, compared to 
LuaBridge. We're forced to write some impenetrable hieroglyphics every time we want to 
make a Rust function callable from Lua. Binding global variables isn't as straightforward
as it could be, and <code>UserData</code>'s method signature isn't exactly a thing of beauty. 
We can do better.</p>
<h2><a class="header" href="#pyo3" id="pyo3"><code>pyo3</code></a></h2>
<p><code>pyo3</code> is the leading set of Python bindings for Rust. Its glue code requires us to go back and
add some attribute macros to our <code>Texture</code> type:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use pyo3::prelude::*;

#[pyclass]
struct Texture {
	tex_id: GLuint,
	width: GLsizei,
	height: GLsizei
}

#[pymethods]
impl Texture {
	#[new]
	fn empty(width: GLsizei, height: GLsizei) -&gt; Texture {
		//...
	}

	fn width(&amp;self) -&gt; GLsizei { self.width }
	fn height(&amp;self) -&gt; GLsizei { self.height }
}
<span class="boring">}
</span></code></pre></pre>
<p>In some ways, this is the best approach we've seen so far. Argument and return-value conversions 
are handled automatically. There's no need to explicitly register any classes or methods; they're 
all registered automatically at startup, using the <a href="https://docs.rs/ctor/*/ctor/index.html"><code>ctor</code> crate</a>. This means that each method
only needs to be named once, rather than twice.</p>
<p>However, this macro-based approach comes with several downsides. Procedural macros require the
heavyweight dependencies <code>proc-macro2</code>, <code>quote</code> and <code>syn</code>. The <code>ctor</code> crate has poor availability
on some platforms, such as game consoles and WebAssembly. The <code>#[pysomething]</code> attributes 
use a <a href="https://pyo3.rs/v0.12.4/class.html#customizing-the-class">complex domain-specific language</a>, 
which can make them difficult to learn and difficult to customise. Those macros can only be used
to bind Rust code at its definition site; the macros can't be used to bind third-party code to
Python. In general, I'd describe this approach as &quot;convenient, but inflexible&quot;.</p>
<p>I did consider using macros for GameLisp, but I eventually decided to try a different tack.</p>
<h2><a class="header" href="#gamelisp" id="gamelisp">GameLisp</a></h2>
<p>GameLisp's glue code looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use glsp::prelude::*;

fn init() -&gt; GResult&lt;()&gt; {
	glsp::bind_rfn(&quot;create-texture&quot;, &amp;Texture::empty)?;

	RClassBuilder::&lt;Texture&gt;::new()
		.met(&quot;width&quot;, &amp;Texture::width)
		.met(&quot;height&quot;, &amp;Texture::height)
		.build();

	Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>By tying Rust's type system in knots, I've managed to devise a Rust API which has the same
flexibility and convenience as LuaBridge. It performs automatic conversions for function
arguments and return values; works well with Rust methods, closures and generic functions; permits 
arbitrary Rust data to be moved onto the garbage-collected heap; enables you to bind third-party 
crates so that they can be scripted by GameLisp code; and provides a very convenient way to store, 
and access, global Rust data.</p>
<p>Over the next four chapters, we'll go through each of these APIs in detail.</p>
<h1><a class="header" href="#rfn" id="rfn">RFn</a></h1>
<p>As we discussed <a href="syntax-and-types.html#type-summary">earlier</a>, one of the possible types for a
GameLisp value is <code>rfn</code>. This type stores a Rust function which can be called from GameLisp; 
<code>rfn</code> stands for &quot;Rust function&quot;.</p>
<p>In the Rust API, <code>rfn</code> is represented by the <a href="https://docs.rs/glsp/*/glsp/enum.Val.html"><code>Val::RFn</code> enum variant</a> and the <a href="https://docs.rs/glsp/*/glsp/struct.RFn.html"><code>RFn</code> struct</a>.
You'll normally access it through a pointer: <code>Root&lt;RFn&gt;</code>.</p>
<p>To construct a new <code>RFn</code>, simply call <a href="https://docs.rs/glsp/*/glsp/fn.rfn.html"><code>glsp::rfn</code></a>, passing in a reference to an appropriate
Rust function.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let swap_bytes: Root&lt;RFn&gt; = glsp::rfn(&amp;i32::swap_bytes);
glsp::bind_global(&quot;swap-bytes&quot;, swap_bytes)?;

//the standard Rust function i32::swap_bytes can now be called from 
//GameLisp code, by invoking the global rfn (swap-bytes)
<span class="boring">}
</span></code></pre></pre>
<pre><code>(prn (swap-bytes 32768)) ; prints 8388608
(prn (swap-bytes 8388608)) ; prints 32768
</code></pre>
<p>Because constructing an <code>RFn</code> and binding it to a global variable is such a common operation,
we provide <a href="https://docs.rs/glsp/*/glsp/fn.bind_rfn.html"><code>glsp::bind_rfn</code></a>, which performs both steps at once.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>glsp::bind_rfn(&quot;swap-bytes&quot;, &amp;i32::swap_bytes)?;
<span class="boring">}
</span></code></pre></pre>
<p><code>glsp::rfn</code> and <code>glsp::bind_rfn</code> don't just accept function pointers - they will also accept
Rust closures, even closures which capture Rust variables.</p>
<p>However, closures passed to <code>glsp::rfn</code> must be <code>'static</code> and immutable. This means that if the 
closure captures any variables, it must take ownership of those variables using the <code>move</code> keyword.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>//a non-capturing closure
glsp::rfn(&amp;|a: i32, b: i32| a.saturating_mul(b + 1));

//a capturing closure which uses interior mutability 
//to update its captured variable
let captured = Cell::new(0_i32);
let print_and_inc = move || {
	println!(&quot;{}&quot;, captured.get());
	captured.set(captured.get() + 1);
};

glsp::bind_rfn(&quot;print-and-inc&quot;, Box::new(print_and_inc))?;
<span class="boring">}
</span></code></pre></pre>
<pre><code>(print-and-inc) ; prints 0
(print-and-inc) ; prints 1
(print-and-inc) ; prints 2
</code></pre>
<p>Even generic Rust functions can be bound to GameLisp - you just need to explicitly select a single 
concrete type signature. For example, to bind the generic <a href="https://doc.rust-lang.org/std/fs/fn.rename.html"><code>fs::rename</code> function</a>, you might 
specify that both parameters are <code>Strings</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>glsp::bind_rfn(&quot;rename&quot;, &amp;fs::rename::&lt;String, String&gt;)?;
<span class="boring">}
</span></code></pre></pre>
<p>As demonstrated above, <code>glsp::rfn</code> will silently convert GameLisp values into Rust arguments,
as well as converting Rust return values into GameLisp values. This conversion is automatic
and invisible; the conversion code is automatically generated by Rust's trait system.</p>
<p>My intent is that it should be possible to write at least 90% of your scriptable functions 
and methods in a language-agnostic way, so that they can be called from either Rust or GameLisp 
without any modification. This should also make it easy for you to bind third-party functions, 
like <code>i32::swap_bytes</code> and <code>fs::rename</code>.</p>
<h2><a class="header" href="#return-value-conversions" id="return-value-conversions">Return Value Conversions</a></h2>
<p>For an <code>rfn</code>'s return value to be automatically converted into a GameLisp value, it must
implement the <a href="https://docs.rs/glsp/*/glsp/trait.IntoVal.html"><code>IntoVal</code> trait</a>.</p>
<p><code>IntoVal</code> is implemented for most of Rust's primitive types, many of the types in GameLisp's
prelude (such as <code>Root&lt;Arr&gt;</code>), and a number of Rust standard library types. See the <a href="https://docs.rs/glsp/*/glsp/trait.IntoVal.html">rustdoc</a> 
for the full run-down.</p>
<p>When a function returns <code>Option&lt;T&gt;</code>, GameLisp will convert the Rust value <code>None</code> into the 
GameLisp value <code>#n</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>//u8::checked_add consumes two u8 and 
//returns an Option&lt;u8&gt;
glsp::bind_rfn(&quot;checked-add&quot;, &amp;u8::checked_add)?;
<span class="boring">}
</span></code></pre></pre>
<pre><code>(prn (checked-add 150 50)) ; prints 200
(prn (checked-add 250 50)) ; prints #n
</code></pre>
<p>Functions which return <code>Result&lt;T&gt;</code> will correctly propagate errors to the caller, converting
non-GameLisp errors into GameLisp errors when necessary.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>//fs::read_to_string consumes a String by value and
//returns a Result&lt;String, std::io::Error&gt;
glsp::bind_rfn(&quot;read-to-string&quot;, &amp;fs::read_to_string::&lt;String&gt;)?;
<span class="boring">}
</span></code></pre></pre>
<pre><code>(ensure (str? (read-to-string &quot;Cargo.toml&quot;)))
(ensure (matches?
  (try (read-to-string &quot;does-not-exist.txt&quot;))
  ('err _)))
</code></pre>
<p>Functions which return various Rust collection types - including tuples, slices, arrays, 
string slices, and paths - will construct a new GameLisp array, string or table.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn count_chars(src: &amp;str) -&gt; HashMap&lt;char, usize&gt; {
	let mut char_counts = HashMap::&lt;char, usize&gt;::new();
	for ch in src.chars() {
		*char_counts.entry(ch).or_insert(0) += 1;
	}

	char_counts
}

glsp::bind_rfn(&quot;count-chars&quot;, &amp;count_chars)?;
<span class="boring">}
</span></code></pre></pre>
<pre><code>(let char-counts (count-chars &quot;consonance&quot;))
(ensure (tab? char-counts))
(prn (len char-counts)) ; prints 6
</code></pre>
<h2><a class="header" href="#argument-conversions" id="argument-conversions">Argument Conversions</a></h2>
<p>Arguments are a little more complicated than return values. The full set of automatic argument
conversions is listed in <a href="https://docs.rs/glsp/*/glsp/fn.rfn.html">the rustdoc</a>; we'll explore some of them in more detail over the
next three chapters.</p>
<p>For now, it's enough for you to know that there's a <a href="https://docs.rs/glsp/*/glsp/trait.FromVal.html"><code>FromVal</code> trait</a> which is implemented for 
many Rust and GameLisp types. GameLisp can automatically convert <code>rfn</code> arguments into any type 
which implements <code>FromVal</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn example(integer: u64, string: String, tuple: (i8, i8)) {
	println!(&quot;{:?} {:?} {:?}&quot;, integer, string, tuple);
}

glsp::bind_rfn(&quot;example&quot;, &amp;example)?;
<span class="boring">}
</span></code></pre></pre>
<pre><code>(example 1 &quot;two&quot; '(3 4)) ; prints 1 &quot;two&quot; (3, 4)
</code></pre>
<p>In addition, automatic argument conversions are provided for a handful of reference types, like 
<code>&amp;Arr</code>, <code>&amp;RData</code>, <code>&amp;str</code>, <code>&amp;Path</code> and <code>&amp;[T]</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn example(string: &amp;str, array: &amp;[Sym]) {
	println!(&quot;{:?} {:?}&quot;, string, array);
}

glsp::bind_rfn(&quot;example&quot;, &amp;example)?;
<span class="boring">}
</span></code></pre></pre>
<pre><code>(example &quot;hello&quot; '(game lisp)) ; prints &quot;hello&quot; [game, lisp]
</code></pre>
<h3><a class="header" href="#optional-and-rest-parameters" id="optional-and-rest-parameters">Optional and Rest Parameters</a></h3>
<p>Parameters of type <code>Option&lt;T&gt;</code> are optional. If no value is passed at that position in
the argument list, the argument will default to <code>None</code>. It will also be set to <code>None</code> if the 
caller passes in <code>#n</code>.</p>
<p>If an <code>rfn</code>'s final parameter has the type <a href="https://docs.rs/glsp/*/struct.Rest.html"><code>Rest&lt;T&gt;</code></a>, it will collect any number of 
trailing arguments.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn example(non_opt: u8, opt: Option&lt;u8&gt;, rest: Rest&lt;u8&gt;) {
	prn!(&quot;{:?} {:?} {:?}&quot;, non_opt, opt, &amp;*rest);
}

glsp::bind_rfn(&quot;example&quot;, &amp;example)?;
<span class="boring">}
</span></code></pre></pre>
<pre><code>(prn (min-args example)) ; prints 1
(prn (max-args example)) ; prints #n

(example)          ; error: too few arguments
(example 1)        ; prints 1 None []
(example 1 2)      ; prints 1 Some(2) []
(example 1 2 3)    ; prints 1 Some(2) [3]
(example 1 2 3 4)  ; prints 1 Some(2) [3, 4]
(example 1 #n 3 4) ; prints 1 None [3, 4]
</code></pre>
<h2><a class="header" href="#custom-conversions" id="custom-conversions">Custom Conversions</a></h2>
<p>It's possible to implement <code>IntoVal</code> and <code>FromVal</code> for your own Rust types. This will enable 
your Rust types to participate in automatic conversions when they're used as an argument or 
return value.</p>
<p>For example, it often makes sense to represent a Rust enum as a GameLisp symbol:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone)]
enum Activity {
	Rest,
	Walk,
	Fight
}

impl IntoVal for Activity {
	fn into_val(self) -&gt; GResult&lt;Val&gt; {
		let sym = match self {
			Activity::Rest =&gt; sym!(&quot;rest&quot;),
			Activity::Walk =&gt; sym!(&quot;walk&quot;),
			Activity::Fight =&gt; sym!(&quot;fight&quot;)
		};

		sym.into_val()
	}
}

impl FromVal for Activity {
	fn from_val(val: &amp;Val) -&gt; GResult&lt;Self&gt; {
		Ok(match *val {
			Val::Sym(s) if s == sym!(&quot;rest&quot;) =&gt; Activity::Rest,
			Val::Sym(s) if s == sym!(&quot;walk&quot;) =&gt; Activity::Walk,
			Val::Sym(s) if s == sym!(&quot;fight&quot;) =&gt; Activity::Fight,
			ref val =&gt; bail!(&quot;expected an Activity, received {}&quot;, val)
		})
	}
}

impl Activity {
	fn energy_cost(self) -&gt; i32 {
		match self {
			Activity::Rest =&gt; 1,
			Activity::Walk =&gt; 5,
			Activity::Fight =&gt; 25
		}
	}
}

glsp::bind_rfn(&quot;energy-cost&quot;, &amp;Activity::energy_cost)?;
<span class="boring">}
</span></code></pre></pre>
<pre><code>(prn (energy-cost 'rest)) ; prints 1
(prn (energy-cost 'fight)) ; prints 25
(prn (energy-cost 'sprint)) ; type conversion error
</code></pre>
<p>You might also consider representing tuple structs as GameLisp arrays. For example, the
tuple struct <code>Rgb(128, 64, 32)</code> could be represented in GameLisp as an array of three
integers, <code>(128 64 32)</code>.</p>
<h2><a class="header" href="#errors-2" id="errors-2">Errors</a></h2>
<p>To return a GameLisp error from an <code>rfn</code>, you can simply set the function's return type to 
<a href="https://docs.rs/glsp/*/glsp/type.GResult.html"><code>GResult&lt;T&gt;</code></a>, which is an alias for <code>Result&lt;T, GError&gt;</code>.</p>
<p>The usual way to trigger a GameLisp error is using the macros <a href="https://docs.rs/glsp/*/glsp/macro.bail.html"><code>bail!()</code></a> and <a href="https://docs.rs/glsp/*/glsp/macro.ensure.html"><code>ensure!()</code></a>.
<code>bail</code> constructs a new <code>GError</code> and returns it. <code>ensure</code> tests a condition and calls <code>bail</code> 
when the condition is false. (The names of these macros are conventional in Rust error-handling
libraries, such as <a href="https://docs.rs/error-chain/0.12.2/error_chain/"><code>error-chain</code></a> and <a href="https://docs.rs/failure/0.1.8/failure/"><code>failure</code></a>.)</p>
<p>If you need to create an error manually, you can use the <a href="https://docs.rs/glsp/*/glsp/macro.error.html"><code>error!()</code></a> macro, or one of 
<a href="https://docs.rs/glsp/*/glsp/struct.GError.html"><code>GError</code></a>'s constructors. An arbitrary <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> type can be reported as the cause of 
an error using the <a href="https://docs.rs/glsp/*/glsp/struct.GError.html#method.with_source"><code>with_source</code></a> method.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn file_to_nonempty_string(path: &amp;Path) -&gt; GResult&lt;String&gt; {
	match std::fs::read_to_string(path) {
		Ok(st) =&gt; {
			ensure!(st.len() &gt; 0, &quot;empty string in file {}&quot;, path);
			Ok(st)
		}
		Err(io_error) =&gt; {
			let glsp_error = error!(&quot;failed to open the file {}&quot;, path);
			Err(glsp_error.with_source(io_error))
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>If a panic occurs within an <code>rfn</code>'s dynamic scope, the panic will be <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html">caught</a> by the innermost 
<code>rfn</code> call and converted into a <code>GResult</code>. The panic will still print its usual message to stderr. 
If this is undesirable, you can override the default printing behaviour with a <a href="https://doc.rust-lang.org/std/panic/fn.set_hook.html">custom panic hook</a>.</p>
<h2><a class="header" href="#rfn-macros" id="rfn-macros"><code>RFn</code> Macros</a></h2>
<p>Both Rust functions and GameLisp functions can be used as macros (although GameLisp functions 
are usually the preferred choice).</p>
<p>Within a Rust function, <a href="https://docs.rs/glsp/*/glsp/macro.macro_no_op.html"><code>macro_no_op!()</code></a> will create and return a special kind of <code>GError</code> 
which suppresses further expansion of the current macro. (Incidentally, this is also how the
<a href="../std/macro-no-op"><code>macro-no-op</code></a> built-in function works.)</p>
<p>This means that you can only use <a href="https://docs.rs/glsp/*/glsp/macro.macro_no_op.html"><code>macro_no_op!()</code></a> in a function which returns <a href="https://docs.rs/glsp/*/glsp/type.GResult.html"><code>GResult</code></a>.</p>
<h2><a class="header" href="#limitations" id="limitations">Limitations</a></h2>
<p>GameLisp's automatic function-binding machinery pushes Rust's type system to its limit. To make
it work, I've had to explore some obscure corners of the trait system. Unfortunately, this has led 
to a few tricky limitations.</p>
<p>Due to <a href="https://github.com/rust-lang/rust/issues/79207"><code>rustc</code> bug #79207</a>, it's not
possible to pass a function pointer or closure to <code>glsp::rfn</code> by value; it will cause a
type-inference error. Instead, functions should be passed by reference, and capturing
closures should be wrapped in a call to <code>Box::new</code>.</p>
<p>Due to <a href="https://github.com/rust-lang/rust/issues/70263"><code>rustc</code> bug #70263</a>, some functions
which return non-<code>'static</code> references can't be passed to <code>glsp::rfn</code>, even when the function's 
return type implements <code>IntoVal</code>. This usually occurs with function signatures which both
consume and return a reference, like <code>fn(&amp;str) -&gt; &amp;str</code>.</p>
<p><code>glsp::rfn</code> won't accept Rust functions with more than eight parameters. If necessary, you can 
work around this by capturing any number of trailing arguments as a <code>Rest&lt;T&gt;</code>, and unpacking 
those arguments manually:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn process_ten_integers(
	arg0: i32,
	arg1: i32,
	arg2: i32,
	arg3: i32,
	arg4: i32,
	arg5: i32,
	arg6: i32,
	rest: Rest&lt;i32&gt;
) -&gt; GResult&lt;()&gt; {

	ensure!(
		rest.len() == 3,
		&quot;expected exactly 10 arguments, but received {}&quot;,
		7 + rest.len()
	);

	let [arg7, arg8, arg9] = [rest[0], rest[1], rest[2]];

	//...
}
<span class="boring">}
</span></code></pre></pre>
<p>We use <a href="https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md">specialization</a> internally. To implement the <code>IntoVal</code>, <code>FromVal</code> or <code>RGlobal</code> traits for 
your own types, you'll need to enable the nightly feature <code>min_specialization</code>, by placing this 
attribute towards the top of your <code>main.rs</code> or <code>lib.rs</code> file:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>#![feature(min_specialization)]
<span class="boring">fn main() {
</span><span class="boring">}
</span></code></pre></pre>
<p>Finally, many <code>rfn</code> parameter types which are accepted by value can't be accepted by reference.
<code>String</code> and <code>i32</code> are fine, but <code>&amp;String</code> and <code>&amp;mut i32</code> aren't.</p>
<h1><a class="header" href="#rdata" id="rdata">RData</a></h1>
<p>So far, so good! With the information from the previous chapter, we can handle most Rust 
functions which deal with primitive types, standard-library types and built-in GameLisp 
types, binding those functions to GameLisp with very little boilerplate.</p>
<p>We've also learned how to provide automatic argument and return-value conversions for our own 
Rust types - perhaps representing a tuple struct as an array, or representing an enum as a symbol.</p>
<p>The next step is to start dealing with Rust types which <em>can't</em> be represented as a GameLisp
primitive. Many Rust types, such as the standard <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code> struct</a>, can't really be converted into
any of the GameLisp primitive types. Some other types would be too expensive to convert back and 
forth on every function call - for example, Rust's standard <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html"><code>IpAddr</code> struct</a> could be represented 
as a GameLisp string, but it wouldn't be a very efficient choice.</p>
<p>In those cases, we can use the <a href="syntax-and-types.html#type-summary"><code>rdata</code> primitive type</a>. <code>rdata</code> stands for &quot;Rust data&quot;.
An <code>rdata</code> is a reference to an arbitrary Rust value which has been moved onto the GameLisp heap. 
It's represented in the Rust API using the <a href="https://docs.rs/glsp/*/glsp/enum.Val.html"><code>Val::RData</code> enum variant</a> and the <a href="https://docs.rs/glsp/*/glsp/struct.RData.html"><code>RData</code> struct</a>.</p>
<p>There are no special conditions for constructing an <code>rdata</code>; GameLisp can take ownership
of any <code>'static</code> type. Simply pass your Rust value to the <a href="https://docs.rs/glsp/*/glsp/fn.rdata.html"><code>glsp::rdata</code> function</a>, which will 
consume the value, wrap it in an <code>RData</code>, move it onto the garbage-collected heap, and 
return a <code>Root&lt;RData&gt;</code> which points to its new memory location.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let file: File = File::open(&quot;example.txt&quot;)?;
let rdata: Root&lt;RData&gt; = glsp::rdata(file);
<span class="boring">}
</span></code></pre></pre>
<p>The <code>RData</code> wrapper is dynamically typed, like <a href="https://doc.rust-lang.org/std/any/index.html"><code>Any</code></a>, and dynamically borrowed, like 
<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>. You can query an <code>RData</code>'s type by calling <code>is()</code>, and you can dynamically borrow 
its payload by calling <code>borrow()</code> or <code>borrow_mut()</code>. If you get the type wrong, or dynamically
borrow the payload in a way that violates <a href="https://doc.rust-lang.org/std/cell/">Rust's aliasing rules</a>, those methods will gracefully
fail.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>ensure!(rdata.is::&lt;File&gt;());

let file = rdata.borrow::&lt;File&gt;();
prn!(&quot;{} bytes&quot;, file.metadata()?.len());

let wrong_type = rdata.borrow::&lt;PathBuf&gt;(); //an error
let aliasing_mut = rdata.borrow_mut::&lt;File&gt;(); //an error
<span class="boring">}
</span></code></pre></pre>
<p>When you call <code>glsp::rdata</code>, you're transferring ownership of your Rust data to the garbage 
collector. If the <code>rdata</code> becomes unreachable for any reason, it will automatically be deallocated.
This will drop the <code>rdata</code>'s payload, invoking its destructor.</p>
<p>Being at the mercy of the garbage collector isn't always desirable, so you can manually take 
back ownership of an <code>RData</code>'s payload using the <a href="https://docs.rs/glsp/*/glsp/struct.RData.html#method.take"><code>RData::take</code> method</a>. If you attempt to 
borrow an <code>RData</code> after calling its <code>take()</code> method, the <code>borrow()</code> call will panic.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let file: File = rdata.take::&lt;File&gt;()?;

let already_taken = rdata.borrow::&lt;File&gt;(); //an error
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#rdata-as-return-values" id="rdata-as-return-values"><code>RData</code> as Return Values</a></h2>
<p>In the previous chapter, we described how <code>rfn</code>s can return any Rust type which implements the
<a href="https://docs.rs/glsp/*/glsp/trait.IntoVal.html"><code>IntoVal</code> trait</a>. That trait is used to automatically convert the function's return value
into a GameLisp value.</p>
<p>We provide a default implementation of <code>IntoVal</code> for any <code>'static</code> type. This implementation
simply passes its <code>self</code> argument to the <code>glsp::rdata</code> function, converting it into an <code>rdata</code>.
This means that if you return one of your own types from an <code>rfn</code>, it will &quot;just work&quot;, even if
you haven't provided an explicit implementation of <code>IntoVal</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Sprite {
	//...
}

impl Sprite {
	fn new(path: &amp;str) -&gt; Sprite {
		//...
	}
}

glsp::bind_rfn(&quot;Sprite&quot;, &amp;Sprite::new)?;
<span class="boring">}
</span></code></pre></pre>
<pre><code>(let goblin (Sprite &quot;goblin.png&quot;))

(prn (rdata? goblin)) ; prints #t
</code></pre>
<h2><a class="header" href="#rdata-as-arguments" id="rdata-as-arguments"><code>RData</code> as Arguments</a></h2>
<p>To receive an <code>rdata</code> as an argument to an <code>rfn</code>, you could use the type <code>Root&lt;RData&gt;</code> and
borrow it manually.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn sprite_size(rdata: Root&lt;RData&gt;) -&gt; GResult&lt;(u32, u32)&gt; {
	let sprite = rdata.try_borrow::&lt;Sprite&gt;()?;
	Ok((sprite.width, sprite.height))
}
<span class="boring">}
</span></code></pre></pre>
<p>However, this isn't very convenient. We provide a better alternative. When processing <code>rfn</code> 
parameters, if GameLisp encounters a reference to an unknown <code>'static</code> type, it will accept 
an <code>rdata</code> argument and attempt to borrow it as that type for the duration of the function call.</p>
<p>In other words, GameLisp will automatically write the above code on your behalf!</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn sprite_size(sprite: &amp;Sprite) -&gt; (u32, u32) {
	(sprite.width, sprite.height)
}
<span class="boring">}
</span></code></pre></pre>
<p>This means that you can write a normal Rust method with a <code>&amp;self</code> or <code>&amp;mut self</code> parameter, and 
then bind it as an <code>rfn</code> without needing to modify it at all.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Sprite {
	pub fn size(&amp;self) -&gt; (u32, u32) {
		(self.width, self.height)
	}
}

glsp::bind_rfn(&quot;sprite-size&quot;, &amp;Sprite::size)?;
<span class="boring">}
</span></code></pre></pre>
<p>As you might expect, a <code>&amp;mut</code> reference will attempt to mutably borrow an <code>rdata</code>, obeying
Rust's usual aliasing rules.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn copy_pixels(dst: &amp;mut Sprite, src: &amp;Sprite, x: u32, y: u32) {
	//...
}

glsp::bind_rfn(&quot;copy-pixels&quot;, &amp;copy_pixels)?;
<span class="boring">}
</span></code></pre></pre>
<pre><code>(let goblin (Sprite &quot;goblin.png&quot;))
(let changeling (Sprite &quot;human.png&quot;))

; this call succeeds
(copy-pixels changeling goblin 0 0)

; this call fails - the Sprite can't be both mutably and 
; immutably borrowed at the same time
(copy-pixels goblin goblin 0 0)
</code></pre>
<p>By default, it's not possible for an arbitrary Rust type to be passed into an <code>rfn</code> by value; 
only shared and mutable references are supported. You can override this default by implementing 
<code>FromVal</code> for your type. This usually works best for <code>Copy</code> types.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl FromVal for Point {
	fn from_val(val: &amp;Val) -&gt; GResult&lt;Point&gt; {
		match val {
			Val::RData(rdata) if rdata.is::&lt;Point&gt;() =&gt; {
				Ok(*rdata.try_borrow::&lt;Point&gt;()?)
			}
			val =&gt; bail!(&quot;expected a Point, received {}&quot;, val)
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#rroot" id="rroot"><code>RRoot</code></a></h2>
<p>You'll sometimes need to store references to <code>RData</code>. For example, you might need to build
a hash table which you can use to look up <code>Sprites</code> by name.</p>
<p>You could consider storing <code>Root&lt;RData&gt;</code> in the hash table, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Sprites {
	by_name: HashMap&lt;String, Root&lt;RData&gt;&gt;
}

let rdata = sprites.by_name.get(&quot;angry-sun&quot;).unwrap();
let sprite = rdata.borrow::&lt;Sprite&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>However, <code>Root&lt;RData&gt;</code> can be a little awkward to use, because it's dynamically typed. Every 
time you call <code>is()</code>, <code>take()</code>, <code>borrow()</code> or <code>borrow_mut()</code>, you'll need to specify that 
you're dealing with a <code>Sprite</code>, rather than a non-specific <code>RData</code>. You might also accidentally 
store a non-<code>Sprite</code> in the hash table.</p>
<p>Instead, consider using the <a href="https://docs.rs/glsp/*/glsp/struct.RRoot.html"><code>RRoot</code> smart pointer</a>, which behaves like a <code>Root&lt;RData&gt;</code> but 
doesn't erase the <code>RData</code>'s actual type:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Sprites {
	by_name: HashMap&lt;String, RRoot&lt;Sprite&gt;&gt;
}

let rdata = sprites.by_name.get(&quot;angry-sun&quot;).unwrap();
let sprite = rdata.borrow();
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#rclass" id="rclass">RClass</a></h1>
<p>By default, from the perspective of GameLisp scripts, each <code>rdata</code> is a black box. GameLisp code
can query whether a particular value is an <code>rdata</code>, receive <code>rdata</code> from function calls,
pass <code>rdata</code> as function arguments... and that's about it!</p>
<p>If you prefer your scripting APIs to be a little more object-oriented, you can register an 
<code>RClass</code> (&quot;Rust class&quot;) for any Rust type. When an <code>rdata</code> has an associated <code>RClass</code>,
this will cause the <code>rdata</code> to behave like a GameLisp <a href="object-oriented-programming.html">object</a>.
It can have methods and properties; its type can be queried using the 
<a href="../std/is-p"><code>is?</code> function</a>; and it has full support for <a href="structs.html#operator-overloading">operator 
overloading</a>.</p>
<p>To register an <code>RClass</code>, use the <a href="https://docs.rs/glsp/*/glsp/struct.RClassBuilder.html"><code>RClassBuilder</code> struct</a>. The builder's api is designed to
vaguely resemble a <a href="object-oriented-programming.html#fundamentals"><code>defclass</code> form</a>. We saw this API used <a href="rust-bindings.html#gamelisp">earlier</a>, 
for our <code>Texture</code> struct:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>RClassBuilder::&lt;Texture&gt;::new()
	.met(&quot;width&quot;, &amp;Texture::width)
	.met(&quot;height&quot;, &amp;Texture::height)
	.build();
<span class="boring">}
</span></code></pre></pre>
<p>You can register an <code>RClass</code> for any <code>'static</code> Rust type, including types defined by external 
crates. The only restriction is that each <code>RClass</code> must have a unique name. If you have two 
types, one named <code>audio::Clip</code> and one named <code>video::Clip</code>, they can't both be named <code>Clip</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>glsp::bind_rfn(&quot;Command&quot;, &amp;Command::new::&lt;String&gt;)?;

RClassBuilder::&lt;Command&gt;::new()
	.met(&quot;args&quot;, &amp;|command: &amp;mut Command, rest: Rest&lt;String&gt;| {
		command.args(rest);
	})
	.met(&quot;status&quot;, &amp;Command::status)
	.build();
<span class="boring">}
</span></code></pre></pre>
<pre><code>(let command (Command &quot;ls&quot;))
(ensure (is? command 'Command))
(.args command &quot;-l&quot; &quot;-a&quot;)

; spawn the process and wait for it to complete
(.status command)
</code></pre>
<h2><a class="header" href="#weak-roots" id="weak-roots">Weak Roots</a></h2>
<p>Generally speaking, it's fine to move any <code>'static</code> type onto the GameLisp heap. However, 
there's one exception.</p>
<p>When a <code>Root</code> smart pointer is pointing to an object, it will entirely prevent that object from 
being deallocated. This means that if any <code>Root</code> pointers are moved onto the garbage-collected heap
(for example, by storing a <code>Root</code> in a struct which is passed to <code>glsp::rdata</code>), memory leaks 
will occur. The <code>Val</code> and <code>RRoot</code> types may contain <code>Roots</code>, so those types should also be kept 
off the heap.</p>
<p>If you need a pointer from one heap allocation to another, you should use <a href="https://docs.rs/glsp/*/glsp/struct.Gc.html"><code>Gc</code></a> instead.
<code>Gc</code> is a weak reference; it doesn't prevent its pointee from being deallocated, and so it
won't cause any memory leaks.</p>
<p>Unfortunately, <code>Gc</code> does require a little bit of supervision. Because <code>Gc</code> pointers are
weakly-rooted, this means that the object they're pointing to could be deallocated at any
time! To prevent this from happening, you'll need to:</p>
<ul>
<li>
<p>Use <a href="https://docs.rs/glsp/*/glsp/struct.RClassBuilder.html#method.trace"><code>RClassBuilder::trace</code></a> to specify how the garbage collector should visit each of the 
<code>Gc</code> pointers owned by your Rust type.</p>
</li>
<li>
<p>Call <a href="https://docs.rs/glsp/*/glsp/fn.write_barrier.html"><code>glsp::write_barrier</code></a> when an instance of your Rust type has been mutated, so that
the garbage collector can check whether any new <code>Gc</code> pointers have been added to it.</p>
</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>//don't do this! 
struct Colliders {
	array: Root&lt;Arr&gt;
}

impl Colliders {
	fn get(&amp;self) -&gt; Root&lt;Arr&gt; {
		Root::clone(&amp;self.array)
	}

	fn replace(&amp;mut self, new_array: Root&lt;Arr&gt;) {
		self.array = new_array;
	}
}

RClassBuilder::&lt;Colliders&gt;::new()
	.met(&quot;get&quot;, &amp;Colliders::get)
	.met(&quot;replace!&quot;, &amp;Colliders::replace)
	.build();
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>//instead, do this...
struct Colliders {
	array: Gc&lt;Arr&gt;
}

impl Colliders {
	fn get(&amp;self) -&gt; Root&lt;Arr&gt; {
		self.array.upgrade().unwrap()
	}

	fn replace(&amp;mut self, new_array: Root&lt;Arr&gt;) {
		self.array = new_array.downgrade();
	}

	fn trace(&amp;self, visitor: &amp;mut GcVisitor) {
		visitor.visit(&amp;self.array);
	}
}

RClassBuilder::&lt;Colliders&gt;::new()
	.met(&quot;get&quot;, &amp;Colliders::get)
	.met(
		&quot;replace!&quot;,
		&amp;|colliders: RRoot&lt;Colliders&gt;, new_array: Root&lt;Arr&gt;| {
			colliders.borrow_mut().replace(new_array);
			glsp::write_barrier(&amp;colliders.into_root());
		}
	)
	.trace(Colliders::trace)
	.build();
<span class="boring">}
</span></code></pre></pre>
<p>We also provide <a href="https://docs.rs/glsp/*/glsp/struct.GcVal.html"><code>GcVal</code></a> as a weakly-rooted alternative to <code>Val</code>, and <a href="https://docs.rs/glsp/*/glsp/struct.RGc.html"><code>RGc</code></a> as a
weakly-rooted alternative to <code>RRoot</code>.</p>
<p>Make sure you don't get caught out when constructing an <code>rfn</code>! If your <code>rfn</code> is a Rust closure
which captures a <code>Root</code>, <code>Val</code> or <code>RRoot</code>, then you're effectively moving a <code>Root</code>
onto the GameLisp heap, which will cause the captured data to leak. (Of course, for an <code>rfn</code> 
which is bound to a global variable, a memory leak might be acceptable.)</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let primes: Root&lt;Arr&gt; = arr![2, 3, 5, 7, 11];
primes.freeze();
let closure = move || { Root::clone(&amp;primes) };

glsp::bind_rfn(&quot;primes&quot;, Box::new(closure))?;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#rglobal" id="rglobal">RGlobal</a></h1>
<p>As a Rust game developer, you're probably already aware of Rust's stern and disapproving 
attitude towards global variables.</p>
<p>In order to prevent unsafe mutation and unsafe multithreading, safe Rust is forced to completely
forbid global mutable variables. They need to be wrapped in a <a href="https://doc.rust-lang.org/std/macro.thread_local.html"><code>thread_local!</code></a>, a <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>, a 
<a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>, a <a href="https://docs.rs/lazy_static/"><code>lazy_static!</code></a>, or something else to shield you from the shared mutable data.</p>
<p>This is strictly necessary to uphold Rust's invariants, but it always makes global variables
much less convenient to use. Typical use of a <a href="https://doc.rust-lang.org/std/macro.thread_local.html"><code>thread_local!</code></a> variable is not a pretty sight:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>thread_local! {
	pub(crate) static LOG_FILE: RefCell&lt;Option&lt;File&gt;&gt; = RefCell::new(None);
}

fn log_str(text: &amp;str) {
	LOG_FILE.with(|ref_cell| {
		let mut option = ref_cell.borrow_mut();
		if let Some(ref mut file) = *option {
			file.write_all(text.as_bytes()).ok();
		}
	})
}
<span class="boring">}
</span></code></pre></pre>
<p>Contrast the equivalent C code:</p>
<pre><code class="language-c">thread_local FILE* log_file;

void log_str(const char* text) {
	if (log_file) {
		assert(fputs(text, log_file));
	}
}
</code></pre>
<p>When programming a game, you'll sometimes encounter a part of your engine which seems &quot;naturally
global&quot; - a texture manager, an audio mixer, a log file, an entity database. There's only ever 
going to be one of it, and it's only ever going to be accessed from a single thread, but Rust 
still forces you to keep it at arm's length.</p>
<p>You're given two options:</p>
<ul>
<li>
<p>Use something like a <a href="https://docs.rs/lazy_static/"><code>lazy_static!</code></a> <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a>. At minimum, this requires you to recite the
incantation <code>NAME.read().unwrap()</code> every time you access the global object. This is 
inconvenient, it makes the order of initialization/destruction less predictable, and it 
carries a non‑trivial performance cost.</p>
</li>
<li>
<p>Allocate your &quot;global&quot; object on the stack when your program starts up, and pass borrowed
references down the callstack to any function which needs to access it. I would consider this 
an anti‑pattern in Rust game development - passing a context reference into most 
function calls adds a lot of visual noise, and it sometimes causes borrow‑checker 
headaches.</p>
<ul>
<li>This is why functions like <a href="https://docs.rs/glsp/*/glsp/fn.sym.html"><code>glsp::sym</code></a> are free functions, rather than being invoked
as methods on some <code>&amp;mut Glsp</code> &quot;God object&quot;. An earlier version of the <code>glsp</code> crate
did work that way, but it made the library much less pleasant to use.</li>
</ul>
</li>
</ul>
<p>If neither of these options seem appealing, GameLisp offers an alternative.</p>
<h2><a class="header" href="#rglobal-1" id="rglobal-1"><code>RGlobal</code></a></h2>
<p>An rglobal is a Rust object which is owned by the GameLisp <a href="https://docs.rs/glsp/*/glsp/struct.Runtime.html"><code>Runtime</code></a>. Predictably, the name 
stands for &quot;Rust global&quot;. </p>
<p>Unlike <a href="https://docs.rs/glsp/*/glsp/struct.RData.html"><code>RData</code></a>, rglobals are singletons: for a given rglobal type, you can only store one 
instance of that type in each <code>Runtime</code>.</p>
<p>To define an rglobal, implement the <a href="https://docs.rs/glsp/*/glsp/trait.RGlobal.html"><code>RGlobal</code> trait</a> for one of your types, and then pass
an instance of that type to the <a href="https://docs.rs/glsp/*/glsp/fn.add_rglobal.html"><code>glsp::add_rglobal</code></a> function. Ownership will be transferred
to the active <code>Runtime</code>. If you later decide that you'd like to remove the rglobal from the
<code>Runtime</code> and take back ownership (perhaps because you're finished with the rglobal and you
want to drop it), you can call <a href="https://docs.rs/glsp/*/glsp/fn.take_rglobal.html"><code>glsp::take_rglobal</code></a>.</p>
<p>While an rglobal of type <code>T</code> is registered with the active <code>Runtime</code>, you can temporarily
borrow it by calling <a href="https://docs.rs/glsp/*/glsp/trait.RGlobal.html#method.borrow"><code>T::borrow()</code></a> or <a href="https://docs.rs/glsp/*/glsp/trait.RGlobal.html#method.borrow_mut"><code>T::borrow_mut()</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Textures {
	by_name: HashMap&lt;Sym, RRoot&lt;Texture&gt;&gt;
}

impl RGlobal for Textures { }

fn init() {
	glsp::add_rglobal(Textures::new());
}

fn get_texture(name: Sym) -&gt; GResult&lt;RRoot&lt;Texture&gt;&gt; {
	let textures = Textures::borrow();

	match textures.by_name.get(&amp;name) {
		Some(texture) =&gt; Ok(RRoot::clone(texture)),
		None =&gt; bail!(&quot;texture {} does not exist&quot;, name)
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Notice that, unlike <code>RData</code>, we're able to store an <code>RRoot</code> in our rglobal without causing a
memory leak.</p>
<p>Dynamic checks are used to uphold Rust's aliasing rules - for example, it's an error to call 
<a href="https://docs.rs/glsp/*/glsp/fn.take_rglobal.html"><code>glsp::take_rglobal</code></a> or <a href="https://docs.rs/glsp/*/glsp/trait.RGlobal.html#method.borrow_mut"><code>T::borrow_mut()</code></a> for an rglobal which is currently borrowed. When the
<a href="https://docs.rs/glsp/*/glsp/struct.Runtime.html"><code>Runtime</code></a> is dropped, all of its rglobals will be dropped in the reverse order that they
were registered.</p>
<p>This is already a big improvement compared to <a href="https://docs.rs/lazy_static/"><code>lazy_static!</code></a>, but the real magic comes from
<a href="rfn.html#argument-conversions">argument type conversions</a>. When a function parameter is a
shared or mutable reference to a type which implements <code>RGlobal</code>, calling the function from 
GameLisp will automatically borrow that rglobal for the duration of the function call. If the 
<code>get_texture</code> function above was intended to be called from GameLisp, we could rewrite it like 
this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Textures {
	fn get_texture(&amp;self, name: Sym) -&gt; GResult&lt;RRoot&lt;Texture&gt;&gt; {
		match self.by_name.get(&amp;name) {
			Some(texture) =&gt; Ok(RRoot::clone(texture)),
			None =&gt; bail!(&quot;texture {} does not exist&quot;, name)
		}
	}
}

glsp::bind_rfn(&quot;get-texture&quot;, &amp;Textures::get_texture)?;
<span class="boring">}
</span></code></pre></pre>
<p>Because the type of <code>&amp;self</code> is <code>&amp;Textures</code>, and the <code>Textures</code> type implements <code>RGlobal</code>, 
GameLisp will call <code>Textures::borrow()</code> to immutably borrow the <code>Textures</code> rglobal for the 
duration of each call to <code>get-texture</code>.</p>
<p>When an <code>rfn</code> parameter is borrowed from an rglobal, it doesn't consume an argument. You would
invoke this function from GameLisp by calling <code>(get-texture name)</code>, with only one argument.</p>
<p>A function may have multiple library parameters:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Textures {
	fn draw_texture(
		&amp;self,
		renderer: &amp;mut Renderer,
		name: Sym,
		x: i32,
		y: i32
	) -&gt; GResult&lt;()&gt; {

		let texture = self.get_texture(name)?;
		renderer.draw(&amp;texture.borrow(), x, y)
	}
}

glsp::bind_rfn(&quot;draw-texture&quot;, &amp;Textures::draw_texture)?;
<span class="boring">}
</span></code></pre></pre>
<p>Assuming <code>Renderer</code> implements <code>RGlobal</code>, you would invoke the above function from GameLisp as 
<code>(draw-texture id x y)</code>.</p>
<p>This auto-borrowing is very convenient. It provides a pool of global variables which are 
&quot;always available&quot; to GameLisp and Rust code, with a minimum of fuss. </p>
<h2><a class="header" href="#symbol-caching" id="symbol-caching">Symbol Caching</a></h2>
<p>If you're finicky about performance, function calls like <code>glsp::global(&quot;texture-count&quot;)</code>
might make you nervous. That function will invoke <code>glsp::sym(&quot;texture-count&quot;)</code> every
time it's called, performing a hash-table lookup to convert the string into a symbol. Surely it
would be better to cache the symbol somewhere, and call <code>glsp::global(TEXTURE_COUNT_SYM)</code>
instead?</p>
<p>(In 90% of cases, the answer to that question is &quot;no, it doesn't matter&quot;... but the last 10% can 
be quite important!)</p>
<p>If you want to cache a symbol, the most convenient option is usually to store it in an rglobal.
This will ensure that you don't accidentally share symbols between one <code>Runtime</code> and another.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Textures {
	//...

	pub nearest_neighbour_sym: Sym,
	pub bilinear_sym: Sym,
	pub trilinear_sym: Sym
}

impl Textures {
	fn new() -&gt; Textures {
		Textures {
			//...

			nearest_neighbour_sym: sym!(&quot;nearest-neighbour&quot;),
			bilinear_sym: sym!(&quot;bilinear&quot;),
			trilinear_sym: sym!(&quot;trilinear&quot;)
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>We provide the <a href="https://docs.rs/glsp/*/glsp/macro.syms.html"><code>syms!</code></a> macro to make this more straightforward. The macro defines a struct
for which every field is a Sym, with a constructor function named <code>new()</code> which initializes each
field by calling <a href="https://docs.rs/glsp/*/glsp/fn.sym.html"><code>glsp::sym</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>syms! {
	pub (crate) struct Syms {
		pub(crate) nearest_neighbour: &quot;nearest-neighbour&quot;,
		pub(crate) bilinear: &quot;bilinear&quot;,
		pub(crate) trilinear: &quot;trilinear&quot;
	}
}

struct Textures {
	syms: Syms,

	//...
}

impl Textures {
	fn new() -&gt; Textures {
		Textures {
			syms: Syms::new(),

			//...
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#multithreading" id="multithreading">Multithreading</a></h2>
<p>GameLisp is single-threaded, because multithreading is primarily a performance optimization. 
Nobody is writing multithreaded game code for its beauty or its convenience! GameLisp code simply 
<a href="performance-figures.html">isn't fast enough</a> for multithreading to be worth the extra complexity it
would add to the language, so it's not supported.</p>
<p>That being said, GameLisp is designed to be cleanly embedded into a multithreaded Rust program.
You can spin up a separate isolated <a href="https://docs.rs/glsp/*/glsp/struct.Runtime.html"><code>Runtime</code></a> for each thread if you like (similar to a 
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">Web Worker</a>), but it would be more typical to have one <a href="https://docs.rs/glsp/*/glsp/struct.Runtime.html"><code>Runtime</code></a> which lives on the main 
thread, with a few worker threads which only run Rust code.</p>
<p>Let's imagine you have a <code>Clip</code> which stores a few seconds of PCM audio data, and a worker thread
which performs audio mixing in software. You want to load and manipulate <code>Clips</code> from your GameLisp
scripts, while still allowing the worker thread to access their PCM samples. A naive attempt 
would look something like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Clip {
	name: Sym,
	channels: Channels,
	samples: Vec&lt;i16&gt;
}

let clip = glsp::rdata(Clip::load(&quot;door-opening.wav&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>You'll run into a problem when you try to pass your <code>Clip</code> to your worker thread. Because the
<code>Clip</code> is owned by a GameLisp <code>Runtime</code>, you can only refer to it indirectly, using the types 
<a href="https://docs.rs/glsp/*/glsp/struct.RData.html"><code>Root&lt;RData&gt;</code></a>, <a href="https://docs.rs/glsp/*/glsp/struct.RRoot.html"><code>RRoot&lt;Clip&gt;</code></a>, <code>&amp;Clip</code>, and <code>&amp;mut Clip</code>. None of these types implement
<a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> or <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>, so there's no way for you to access your <code>Clip</code>'s samples from another 
thread.</p>
<p>Thanks to fearless concurrency, there's an easy workaround. Simply wrap the shared parts of 
your struct in an <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Clip {
	name: Sym,
	samples: Arc&lt;Samples&gt;
}

struct Samples {
	channels: Channels,
	samples: Vec&lt;i16&gt;
}

impl Clip {
	fn play(&amp;self, mixer: &amp;Mixer) {
		mixer.play_samples(Arc::clone(&amp;self.samples));
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Ideally, when writing a multithreaded game with GameLisp, your worker threads shouldn't know that 
GameLisp exists at all. Think of each worker thread's code as a small library written in pure Rust, 
for which your main thread is a client. In the example above, the <code>Mixer</code> could be thought of as
a library which mixes raw sample buffers, <em>not</em> a library which mixes <code>Clip</code>s specifically.</p>
<h2><a class="header" href="#using-gamelisp-with-ecs" id="using-gamelisp-with-ecs">Using GameLisp with ECS</a></h2>
<p>Although GameLisp has some <a href="code-reuse.html#aside-why-not-ecs">philosophical differences</a> with the
Entity-Component-System pattern (ECS), it's still possible for GameLisp and ECS to comfortably 
coexist in the same game.</p>
<p>The main obstacle is that most ECS libraries are pervasively multithreaded, but each GameLisp 
<code>Runtime</code> is strictly single-threaded. This means that GameLisp data can't be stored in 
components, and GameLisp scripts can't be executed by systems.</p>
<p>Thankfully, ECS libraries usually have a low-level API which can be used to look up an entity's
components dynamically, as long as no systems are currently executing. This can be used to 
implement a &quot;pseudo-system&quot; which runs GameLisp scripts once per frame, after all other entity 
processing is complete.</p>
<p>For example, with <a href="https://bevyengine.org/"><code>bevy</code></a> 0.4:</p>
<pre><code>(defmixin Entity
  (field id) ; an rdata

  (prop position
    (get
      (ecs:position @id))
    (set (new-position)
      (ecs:position= @id new-position))))
</code></pre>
<pre><pre class="playpen"><code class="language-rust">#![feature(min_specialization)]

use bevy::{app::App, ecs::Entity};
use glsp::prelude::*;

struct Bevy(App);
impl RGlobal for Bevy { }

//a component
struct Position(f32, f32);

//the (ecs:position) function: access a Position from a glsp script
fn ecs_position(
	bevy: &amp;Bevy,
	entity: &amp;Entity
) -&gt; (f32, f32) {

	let position = bevy.0.world.get::&lt;Position&gt;(*entity_id).unwrap();
	(position.0, position.1)
}

//the (ecs:position=) function: mutate a Position from a glsp script
fn ecs_set_position(
	bevy: &amp;mut Bevy,
	entity_id: &amp;Entity,
	(x, y): (f32, f32)
) {

	let mut position = bevy.0.world.get_mut::&lt;Position&gt;(*entity_id).unwrap();
	*position = Position(x, y);
}

fn main() {
	let runtime = Runtime::new();
	runtime.run(|| {

		//register accessor/mutator functions with glsp
		glsp::bind_rfn(&quot;ecs:position&quot;, &amp;ecs_position)?;
		glsp::bind_rfn(&quot;ecs:position=&quot;, &amp;ecs_set_position)?;

		//construct the ECS
		let mut app_builder = App::build();

		//...register your usual systems, and so on...

		//store the bevy App as an rglobal
		glsp::add_rglobal(Bevy(app_builder.app));

		//the main loop
		loop {
			//run bevy for a single step
			Bevy::borrow_mut().0.update();

			//now, you can execute glsp code for this step. global
			//functions like (ecs:position=) will automatically access a
			//particular Entity's components, stored within the bevy App
		}

		Ok(())
	}).unwrap();
}
</code></pre></pre>
<p>I believe this approach would also be compatible with <code>specs</code>, the ECS used by the Amethyst
game engine.</p>
<p>With a little experimentation (and a little unsafe code!), it should also be possible to run 
GameLisp scripts from a thread-local system. For some games, this might be more the more 
ergonomic option.</p>
<h1><a class="header" href="#garbage-collection" id="garbage-collection">Garbage Collection</a></h1>
<p>GameLisp provides automatic memory management, in the form of a tracing garbage collector (GC). 
This means that there's no need to worry about cyclic references - orphaned reference cycles 
will be collected automatically.</p>
<p>Traditional tracing GCs wait until a certain amount of memory has been allocated, 
and then attempt to scan or deallocate a large amount of memory all at once. Even incremental 
or concurrent GCs tend to wait for memory pressure to reach a certain level, switch 
themselves on for a while, and then switch themselves off - examples include <a href="https://blogs.unity3d.com/2018/11/26/feature-preview-incremental-garbage-collection/">Unity's upcoming 
incremental collector</a>, and the garbage collector currently provided by Lua and LuaJIT.</p>
<p>None of these options are the right choice for game development. In order for a fast-paced game to 
avoid feeling &quot;choppy&quot;, it <em>must</em> meet the deadline set by the monitor's refresh rate, or an 
integer fraction of that refresh rate (say, 72 Hz for a 144 Hz monitor). A swap chain can allow 
the game to accumulate one or two frames of &quot;borrowed time&quot; without being detectable to the 
user, but whenever the cumulative delay exceeds those one or two frames, the debt is cashed in 
and the user will experience a frameskip.</p>
<p>(This is a simple thing to test - in your main loop, just sleep for 15ms every 40th frame,
which is equivalent to exceeding a 60 Hz frame budget by about 0.3ms per frame. If your game 
involves any fast movement, you'll find that it suddenly &quot;feels wrong&quot;, even if you can't pinpoint 
exactly which frames are being skipped.)</p>
<p>When a game's GC is allowed to stop and start, and it takes up one millisecond per frame while
it's running, then the time budget is effectively one millisecond lower for <em>every</em> frame. If a 
particular scene normally runs at 16 milliseconds per frame, then when the garbage collector 
switches on it will suddenly take up 17 milliseconds and start skipping frames. In this scenario,
you'd be forced to set aside 6% of your entire time budget just for the GC!</p>
<p>The status quo is usually even worse - when a GC is allowed to &quot;stop the world&quot;, it might pause
your game for 50 milliseconds or more. I've heard anecdotal reports of games experiencing GC 
pauses of several hundred milliseconds. This would be clearly noticeable even in a slow, casual 
game.</p>
<h2><a class="header" href="#gamelisps-gc" id="gamelisps-gc">GameLisp's GC</a></h2>
<p>GameLisp's solution is a custom incremental GC algorithm which runs once per frame, every frame. 
The amount of work it performs increases in lockstep with the amount of new memory allocated 
during the previous frame (which, for a typical game, should be very consistent).</p>
<p>It turns out that when you spread out the work like this, garbage collection is extremely cheap.
<a href="performance-figures.html">Appendix A</a> has some concrete performance numbers, but the headline figure
is that for a 2D sidescroller running on a mid-range laptop, the GC uses about 0.1 milliseconds
per frame, or 0.2 milliseconds for a really busy scene.</p>
<p>GameLisp will never invoke the GC behind your back. You need to do it explicitly, either by
calling the <a href="https://docs.rs/glsp/*/glsp/fn.gc.html"><code>glsp::gc</code></a> function from Rust, or the <a href="../std/gc"><code>gc</code></a> function from GameLisp. </p>
<p>For a typical main loop, you should simply invoke the GC once per frame. If you're scripting a
program with an unusual main loop (say, a GUI event loop for your level editor), then you
should aim to invoke the GC about sixty times per second, although it's fine to temporarily stop
when your program isn't executing any GameLisp code.</p>
<p>There's currently only one way to tune the GC's behaviour: calling <a href="https://docs.rs/glsp/*/glsp/fn.gc_set_ratio.html"><code>glsp::gc_set_ratio</code></a> or 
<code>(= (gc-value 'ratio) r)</code> to assign a &quot;heap ratio&quot;. This is the ratio between the average size of 
the GC heap, and the amount of long-lived memory which it stores. The <a href="https://docs.rs/glsp/*/glsp/constant.GC_DEFAULT_RATIO.html">default value</a> is 
<code>1.5</code>, so if you store 10mb of useful long-lived data on the heap, it will also contain about 5mb 
of garbage.</p>
<p>When you set the ratio to a lower value, the GC will need to perform an exponentially higher
amount of work to keep up. The <a href="https://docs.rs/glsp/*/glsp/constant.GC_MIN_RATIO.html">minimum ratio</a> is currently <code>1.2</code>.</p>
<h1><a class="header" href="#procedural-macros" id="procedural-macros">Procedural Macros</a></h1>
<p>The <code>glsp</code> crate defines a handful of procedural macros. In general, their purpose is to blur the 
line between GameLisp code and Rust code.</p>
<h2><a class="header" href="#eval" id="eval"><code>eval</code></a></h2>
<p>The <a href="https://docs.rs/glsp/*/glsp/macro.eval.html"><code>eval!</code></a> procedural macro takes a string literal which contains GameLisp source code, and 
executes it. You can interleave local variables into the evaluation by unquoting them with <code>~</code>.
Local variables are converted to and from GameLisp values using the <a href="https://docs.rs/glsp/*/glsp/trait.IntoVal.html"><code>IntoVal</code></a> and <a href="https://docs.rs/glsp/*/glsp/trait.FromVal.html"><code>FromVal</code></a> 
traits.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let width: i32 = 100;
let height: i32 = 200;
let mut area: i32 = 0;

let _: Val = eval!(&quot;(= ~area (* ~width ~height))&quot;)?;
<span class="boring">}
</span></code></pre></pre>
<p>You can split the string literal over several lines, and include embedded strings, using a
<a href="https://doc.rust-lang.org/reference/tokens.html#raw-string-literals">raw string literal</a>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let y: usize = 20;
let _: Val = eval!(r#&quot;
  (let x (* ~y 10))
  (prn &quot;the value of y is {(/ x 10)}&quot;)
&quot;#)?;
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/glsp/*/glsp/macro.eval.html"><code>eval!</code></a> is much faster than the <a href="../std/eval"><code>eval</code></a> and <a href="https://docs.rs/glsp/*/glsp/fn.eval.html"><code>glsp::eval</code></a> functions. While your 
crate is compiling, it fires up a GameLisp <a href="https://docs.rs/glsp/*/glsp/struct.Runtime.html"><code>Runtime</code></a> and uses it to compile the the literal 
string into GameLisp bytecode, which is lazily loaded into your own <a href="https://docs.rs/glsp/*/glsp/struct.Runtime.html"><code>Runtime</code></a> when the 
<a href="https://docs.rs/glsp/*/glsp/macro.eval.html"><code>eval!</code></a> is first executed. This means that, unlike the alternatives, <a href="https://docs.rs/glsp/*/glsp/macro.eval.html"><code>eval!</code></a> does not
need to compile any code when it's executed.</p>
<p>One small downside is that, because the code is expanded and compiled using a generic, empty 
<a href="https://docs.rs/glsp/*/glsp/struct.Runtime.html"><code>Runtime</code></a>, it can't make use of any macros except those defined in the GameLisp standard 
library. However, it can still access your custom GameLisp functions, Rust functions and global 
variables as normal.</p>
<p>Because it performs bytecode serialization, the <a href="https://docs.rs/glsp/*/glsp/macro.eval.html"><code>eval!</code></a> macro is only available when the 
<code>&quot;compiler&quot;</code> <a href="feature-flags.html">feature flag</a> is enabled.</p>
<h2><a class="header" href="#quote" id="quote"><code>quote</code></a></h2>
<p>The <a href="https://docs.rs/glsp/*/glsp/macro.quote.html"><code>quote!</code></a> macro is equivalent to the <a href="../std/quote"><code>quote</code></a> form. It takes a text description
of some GameLisp data, parses it at compile time, lazily allocates and deep-freezes it the first
time the <a href="https://docs.rs/glsp/*/glsp/macro.quote.html"><code>quote!</code></a> is executed, and then repeatedly returns the same data every time it's 
executed. This is sometimes more efficient than recreating the data from scratch.</p>
<p>Its return type is generic, so you should usually assign it to a variable with a concrete type,
such as <a href="https://docs.rs/glsp/*/glsp/enum.Val.html"><code>Val</code></a> or <a href="https://docs.rs/glsp/*/glsp/struct.Arr.html"><code>Root&lt;Arr&gt;</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let ai_priorities: Root&lt;Arr&gt; = quote!(r#&quot;
	(harvest-materials defend-self guard-allies build-structures)
&quot;#);
creature.set(&quot;ai-priorities&quot;, ai_priorities)?;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#backquote" id="backquote"><code>backquote</code></a></h2>
<p><a href="https://docs.rs/glsp/*/glsp/macro.backquote.html"><code>backquote!</code></a> is equivalent to the <a href="../std/backquote"><code>backquote</code></a> form. It emits code to 
allocate a fresh, mutable copy of the specified GameLisp value, perhaps interleaving local 
variables into the output. It can be useful when implementing a GameLisp macro as a Rust 
function.</p>
<p>Local variables can be splayed, but otherwise it's not yet possible to evaluate arbitrary
Rust code within a <a href="https://docs.rs/glsp/*/glsp/macro.backquote.html"><code>backquote!</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn test_numbers_macro(attempt: Val) -&gt; Val {
	let numbers: [i32; 4] = [36, -10, 59, 97];
	backquote!(r#&quot;
		(cond 
		  ((eq? ~attempt '(~..numbers))
		    (prn &quot;I have a bad feeling about this...&quot;))
		  (else
		    (prn &quot;Hint: one of the numbers is &quot; (rand-pick ~..numbers))))
	&quot;#)
}
<span class="boring">}
</span></code></pre></pre>
<p>Unquoted local variables are converted into GameLisp values using the <a href="https://docs.rs/glsp/*/glsp/trait.IntoVal.html"><code>IntoVal</code></a> macro, which
has the potential to fail. <a href="https://docs.rs/glsp/*/glsp/macro.backquote.html"><code>backquote!</code></a> will panic if the conversion fails. <a href="https://docs.rs/glsp/*/glsp/macro.try_backquote.html"><code>try_backquote!</code></a>
is the non-panicking equivalent; it returns a <a href="https://docs.rs/glsp/*/glsp/type.GResult.html"><code>GResult&lt;T&gt;</code></a>.</p>
<h1><a class="header" href="#compilation" id="compilation">Compilation</a></h1>
<p>GameLisp code is quite fast to load. <a href="../tcof/">The Castle on Fire</a>'s codebase is currently around 
800 kilobytes of idiomatic GameLisp code (15 KLoC plus comments), which is completely loaded in 550 
milliseconds. For most games, it should be fine to simply call <a href="https://docs.rs/glsp/*/glsp/fn.load.html"><code>glsp::load</code></a> at startup.</p>
<p>However, if you're keen to improve startup performance, GameLisp supports pre-compilation of
its source code into a binary format, similar to Lua's binary chunks or Python's <code>py_compile</code>
module. Because this skips macro-expansion, it's much faster than <a href="https://docs.rs/glsp/*/glsp/fn.load.html"><code>glsp::load</code></a>: The Castle
on Fire's source, when pre-compiled, loads in less than 100 milliseconds.</p>
<p>Compiling your source code can also help to obfuscate it. When you use compiled code, there's no 
need to distribute the original source files alongside your executable. Reverse-engineering the 
GameLisp binary format into readable GameLisp code would be a challenge, to say the least. </p>
<p>Note that compiled GameLisp code does not run faster than uncompiled code. The final result is
the same - the only difference is how the code is loaded into memory.</p>
<p>Because compilation relies on the <a href="https://serde.rs/"><code>serde</code></a> and 
<a href="https://docs.rs/bincode"><code>bincode</code></a> crates, it's hidden behind the 
<a href="feature-flags.html">feature flag</a> <code>&quot;compiler&quot;</code>, which is disabled by default.</p>
<h2><a class="header" href="#the-compile-macro" id="the-compile-macro">The <code>compile!</code> macro</a></h2>
<p>The easiest way to precompile GameLisp code is using the <code>compile!</code> macro.</p>
<p>This is a procedural macro, so it runs while <code>rustc</code> is executing. It starts up a generic, empty
GameLisp runtime, uses it to compile all of the GameLisp source files which you specify, and
embeds the result directly into the Rust executable (like <a href="https://doc.rust-lang.org/std/macro.include_bytes.html"><code>include_bytes!</code></a>), returning it as a
<code>&amp;'static [u8]</code>.</p>
<p>That byte slice can then be passed to <a href="https://docs.rs/glsp/*/glsp/fn.load_compiled.html"><code>glsp::load_compiled</code></a> to run it.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>//these two calls are roughly equivalent
glsp::load_compiled(compile![&quot;scripts/main.glsp&quot;])?;
glsp::load(&quot;scripts/main.glsp&quot;)?;
<span class="boring">}
</span></code></pre></pre>
<p>The main downside of using <a href="https://docs.rs/glsp/*/glsp/macro.compile.html"><code>compile!</code></a> is that, because your scripts are no longer being loaded
from the filesystem, the only way to change them is to run <code>rustc</code> again, which is slow and
inconvenient. Therefore, you should generally only use <a href="https://docs.rs/glsp/*/glsp/macro.compile.html"><code>compile!</code></a> when producing your final
binary for distribution:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;compiler&quot;)]
glsp::load_compiled(compile![&quot;scripts/main.glsp&quot;])?;

#[cfg(not(feature = &quot;compiler&quot;))]
glsp::load(&quot;scripts/main.glsp&quot;)?;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#the-glspload_and_compile-function" id="the-glspload_and_compile-function">The <code>glsp::load_and_compile</code> function</a></h2>
<p><a href="https://docs.rs/glsp/*/glsp/macro.compile.html"><code>compile!</code></a> is very convenient, but it always compiles your source files using an empty,
generic GameLisp runtime. This runtime will have access to the GameLisp standard library and any
macros you define using <a href="../std/bind-macro-mut"><code>bind-macro!</code></a> or <a href="../std/defmacro"><code>defmacro</code></a>, 
but it won't run any of your Rust initialization code, so it won't have access to any libraries, 
any Rust functions, any assignments you've made to global variables from within Rust code, and 
so on.</p>
<p>This will only matter if you rely on one of your libraries, or call one of your Rust functions, 
in either of the following circumstances:</p>
<ul>
<li>When evaluating a toplevel form (see <a href="evaluation.html">Evaluation</a>)</li>
<li>When running a macro expander</li>
</ul>
<p>In the unlikely event that this is the case, your Rust program can perform its usual setup,
then compile GameLisp code manually by calling <a href="https://docs.rs/glsp/*/glsp/fn.load_and_compile.html"><code>glsp::load_and_compile</code></a>. This 
will return a <code>GResult&lt;(Val, Vec&lt;u8&gt;)&gt;</code>, where the <code>Val</code> is the result of loading and running 
the file, and the <code>Vec&lt;u8&gt;</code> is the result of compiling it.</p>
<p>It's straightforward to serialize a <code>Vec&lt;u8&gt;</code> to a file. The next time your program runs, you 
can read that <code>Vec&lt;u8&gt;</code> back in, and pass it to <a href="https://docs.rs/glsp/*/glsp/fn.load_compiled.html"><code>glsp::load_compiled</code></a> as a byte slice.</p>
<p>The GameLisp binary format has absolutely no stability guarantees. If you recompile your 
executable, then you must also recompile any GameLisp binaries which that executable has produced 
in the past. Consider writing a <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build script</a> which deletes any saved binaries.</p>
<h2><a class="header" href="#corner-cases" id="corner-cases">Corner Cases</a></h2>
<p>GameLisp code is different from Lua or Python code, because it has a macro-expansion pass. It's
also different from Scheme and Rust, because those macros are defined <em>dynamically</em> - the set
of bound macros can change between one toplevel form and the next.</p>
<p>Macro-expansion is expensive, so the only way to efficiently compile GameLisp code is to expand
it before compiling it. This means that when you call <a href="https://docs.rs/glsp/*/glsp/fn.load_compiled.html"><code>glsp::load_compiled</code></a>, any macros
in the current GameLisp runtime will be ignored. All that matters is which macros were present in
the runtime which compiled the code.</p>
<p>Unfortunately, because of the dynamic binding mentioned above, the only way to macro-expand
GameLisp code is to run it. This is why the function is <a href="https://docs.rs/glsp/*/glsp/fn.load_and_compile.html"><code>glsp::load_and_compile</code></a> rather than 
just <code>glsp::compile</code>; one way of thinking about it is that we're loading the file (and all of the
files which it loads in turn), running it, and &quot;recording&quot; the execution in a format which can
be &quot;played back&quot; in the future.</p>
<p>99% of the time, you won't have to think about this. It's only relevant if the GameLisp environment
which calls <a href="https://docs.rs/glsp/*/glsp/fn.load_and_compile.html"><code>glsp::load_and_compile</code></a> somehow differs from the GameLisp environment which calls
<a href="https://docs.rs/glsp/*/glsp/fn.load_compiled.html"><code>glsp::load_compiled</code></a> - because then the expected &quot;playback&quot; will differ from the actual 
&quot;recording&quot;, and panics or logic bugs may occur.</p>
<pre><code>; because you're loading different files on different run-throughs, an 
; error will occur if you compile this form on a linux machine and then 
; run it on a non-linux machine.
(cond
  (on-linux?
    (load &quot;linux.glsp&quot;))
  (else
    (load &quot;non-linux.glsp&quot;)))

; this macro expands to a constant value representing the screen width 
; *at the time of macro expansion*. if this happens to be different between 
; your own machine and the user's machine, the value will be incorrect.
(defmacro screen-w ()
  (my-window-library:screen-width))

; because you're calling an rfn, this form will trigger an error if you pass
; it to the compile![] macro, rather than glsp::load_and_compile.
(my-sound-library:init)
</code></pre>
<p>The simplest way to protect yourself against this is to use <a href="https://docs.rs/glsp/*/glsp/macro.compile.html"><code>compile!</code></a> rather than
<a href="https://docs.rs/glsp/*/glsp/fn.load_and_compile.html"><code>glsp::load_and_compile</code></a>, and perform all of your loading immediately after calling 
<a href="https://docs.rs/glsp/*/glsp/struct.Runtime.html#method.new"><code>Runtime::new</code></a>, before binding libraries or doing anything else which might modify the 
<a href="https://docs.rs/glsp/*/glsp/struct.Runtime.html"><code>Runtime</code></a>. This means that you won't be able to access libraries or Rust functions from the 
toplevel or from macro expanders - but you will still be able to access them from within normal 
GameLisp functions.</p>
<pre><code>; this is fine, because it's a fn rather than a macro
(defn screen-w ()
  (my-window-library:screen-width))

; this is fine, as long as (init-sound) isn't called from the toplevel or 
; from a macro expander
(defn init-sound ()
  (my-sound-library:init))
</code></pre>
<h1><a class="header" href="#feature-flags" id="feature-flags">Feature Flags</a></h1>
<p>By default, the <code>glsp</code> crate's only transitive dependencies are <a href="https://docs.rs/smallvec"><code>smallvec</code></a>, <a href="https://docs.rs/owning_ref"><code>owning_ref</code></a>, 
<a href="https://docs.rs/stable_deref_trait"><code>stable_deref_trait</code></a>, <a href="https://docs.rs/fnv"><code>fnv</code></a>, and the Rust standard library.</p>
<pre><code>$ cargo tree
glsp v0.2.0
+-- glsp-engine v0.2.0
|   +-- fnv v1.0.7
|   +-- owning_ref v0.4.1
|   |   +-- stable_deref_trait v1.1.1
|   +-- smallvec v1.4.0
+-- glsp-proc-macros v0.2.0
|   +-- glsp-engine v0.2.0 (*)
+-- glsp-stdlib v0.2.0
	+-- glsp-engine v0.2.0 (*)
	+-- glsp-proc-macros v0.2.0 (*)
	+-- smallvec v1.4.0 (*)
</code></pre>
<p>All large or non-essential dependencies are feature-gated, and all features are disabled by
default.</p>
<h2><a class="header" href="#unsafe-internals" id="unsafe-internals">&quot;unsafe-internals&quot;</a></h2>
<p>By default, <code>glsp</code>'s implementation doesn't use any <code>unsafe</code> code at all. This is guaranteed 
using <code>#![forbid(unsafe_code)]</code>.</p>
<p>With the <code>&quot;unsafe-internals&quot;</code> feature enabled, a small amount of unsafe code is switched on in
the <code>glsp-engine</code> crate. This makes the interpreter run roughly <a href="performance-figures.html">twice as 
fast</a>.</p>
<p>Note that <code>glsp</code>'s public API is always intended to be safe, even when the <code>&quot;unsafe-internals&quot;</code>
feature is enabled. The purpose of this feature flag is to mitigate the safety impact of any 
undetected bugs which are internal to the <code>glsp</code> crate.</p>
<p>Even with <code>&quot;unsafe-internals&quot;</code> disabled, <code>glsp</code> may depend on crates which themselves use <code>unsafe</code> 
internally - currently <a href="https://docs.rs/smallvec"><code>smallvec</code></a>, <a href="https://docs.rs/owning_ref"><code>owning_ref</code></a> and optionally <a href="https://docs.rs/bincode"><code>bincode</code></a>. As usual, 
you shouldn't trust this crate's safety unless you also trust its dependencies.</p>
<h2><a class="header" href="#serde" id="serde">&quot;serde&quot;</a></h2>
<p>Introduces a dependency on the <a href="https://docs.rs/serde"><code>serde</code></a> crate, but not <a href="https://docs.rs/serde_derive"><code>serde_derive</code></a>.</p>
<p>Implements <a href="https://docs.serde.rs/serde/ser/trait.Serialize.html"><code>Serialize</code></a> and <a href="https://docs.serde.rs/serde/de/trait.Deserialize.html"><code>Deserialize</code></a> for <a href="https://docs.rs/glsp/*/glsp/enum.Val.html"><code>Val</code></a>, <a href="https://docs.rs/glsp/*/glsp/struct.Root.html"><code>Root</code></a>, <a href="https://docs.rs/glsp/*/glsp/struct.Arr.html"><code>Arr</code></a>, <a href="https://docs.rs/glsp/*/glsp/struct.Tab.html"><code>Tab</code></a>, <a href="https://docs.rs/glsp/*/glsp/struct.Str.html"><code>Str</code></a> and 
<a href="https://docs.rs/glsp/*/glsp/struct.Sym.html"><code>Sym</code></a>. Note that the serializer will gracefully fail if it encounters a <a href="strings-and-text.html#parsing-and-unparsing">non-representable</a> 
type, or a type which contains reference cycles. <a href="../std/gensym">Gensyms</a> and textually-ambiguous 
symbols can be serialized and deserialized, even though they're not representable.</p>
<h2><a class="header" href="#compiler" id="compiler">&quot;compiler&quot;</a></h2>
<p>Introduces a dependency on the <code>&quot;serde&quot;</code> feature, as well as the crates <a href="https://docs.rs/bincode"><code>bincode</code></a>, <a href="https://docs.rs/flate2"><code>flate2</code></a>, 
<a href="https://docs.rs/syn"><code>syn</code></a>, <a href="https://docs.rs/quote"><code>quote</code></a>, <a href="https://docs.rs/proc_macro2"><code>proc_macro2</code></a> and <a href="https://docs.rs/serde_derive"><code>serde_derive</code></a>.</p>
<p>This feature flag enables GameLisp source code to be pre-compiled into an efficient binary 
format. Provides the <a href="https://docs.rs/glsp/*/glsp/macro.compile.html"><code>compile!</code></a> and <a href="https://docs.rs/glsp/*/glsp/macro.eval.html"><code>eval!</code></a> macros, and the <a href="https://docs.rs/glsp/*/glsp/fn.load_and_compile.html"><code>glsp::load_and_compile</code></a> 
and <a href="https://docs.rs/glsp/*/glsp/fn.load_compiled.html"><code>glsp::load_compiled</code></a> functions. See the <a href="compilation.html">Compilation</a> chapter for
more information.</p>
<h1><a class="header" href="#performance-figures" id="performance-figures">Performance Figures</a></h1>
<p>All performance timings on this page were obtained using a mid-range laptop from 2016 with
an Intel Core i7-6500U CPU (2.5 GHz). Rust code was compiled with <code>opt-level = 3</code>, <code>lto = true</code>,
<code>codegen-units = 1</code>. The <code>&quot;unsafe-internals&quot;</code> feature was enabled unless noted otherwise.</p>
<h2><a class="header" href="#specimen-project" id="specimen-project">Specimen Project</a></h2>
<p>GameLisp's specimen project is <a href="https://gamelisp.rs/tcof/">The Castle on Fire</a>, a 2D sidescroller
which is still under development. We can use this project to provide some representative
performance figures for a real-world game which uses GameLisp.</p>
<p>The project has around 15,000 non-empty, non-comment lines of GameLisp code, which are loaded 
into the GameLisp runtime in about 550 milliseconds (or less than 100 milliseconds when 
<a href="compilation.html">pre‑compiled</a>).</p>
<p>The entity system, main loop and parts of the physics system are implemented in GameLisp. Each
entity receives a minimum of two method calls per frame. In a scene with 292 (mostly trivial)
entities, the total execution time spent running GameLisp code is ~2.0 milliseconds per frame, the 
memory pressure is 180 kilobytes of small allocations per frame, and the GC time is around 0.10 
milliseconds per frame, maintaining a 7 megabyte heap.</p>
<p>When we switch to a very busy scene (30 physics-enabled on-screen enemies with behaviour scripting 
and rendering, all controlled from GameLisp), the GameLisp execution time climbs to ~4.0 
milliseconds, the memory pressure to 350 kilobytes, and the GC time to 0.20 milliseconds. 
Most of this execution time is spent on the physics simulation - moving the hottest parts of the 
physics engine to Rust would be an easy optimization, if necessary.</p>
<p>If the heap size seems small, note that the game's total memory usage is a few dozen
megabytes. The 7 megabyte heap only contains memory managed directly by GameLisp, not including 
<code>rdata</code>.</p>
<p>When the game is run on a low-end laptop from 2011 (with a Pentium P6100), all GameLisp code
execution (including source-file loading and garbage-collection) experiences a constant-factor 
slowdown of around 2x to 4x relative to the i7-6500U. The game remains very playable.</p>
<h2><a class="header" href="#benchmarks" id="benchmarks">Benchmarks</a></h2>
<p>GameLisp uses a bytecode interpreter, so I've benchmarked it against other interpreted languages -
specifically, the reference implementations of Lua and Python. Please note that JITted scripting 
language implementations, like LuaJIT, PyPy, V8, and SpiderMonkey, would be significantly faster. 
(However, integrating those libraries into a Rust game project would not be straightforward.)</p>
<p>The &quot;GameLisp (SI)&quot; column was compiled with the <a href="feature-flags.html">default feature flags</a>, and the 
&quot;GameLisp (UI)&quot; column was compiled with the <code>&quot;unsafe-internals&quot;</code> flag enabled.</p>
<p>The <code>primitive-x</code> benchmarks perform a basic operation (like addition or array indexing)
in an unrolled loop, while the remaining benchmarks try to imitate actual game code.</p>
<table><thead><tr><th>Benchmark</th><th align="center">Lua 5.3</th><th align="center">GameLisp (UI)</th><th align="center">Python 3.7.7</th><th align="center">GameLisp (SI)</th></tr></thead><tbody>
<tr><td><code>primitive-inc</code></td><td align="center">432.2ms</td><td align="center">672.1ms</td><td align="center">3710.3ms</td><td align="center">1079.8ms</td></tr>
<tr><td><code>primitive-arith</code></td><td align="center">534.0ms</td><td align="center">535.1ms</td><td align="center">2298.7ms</td><td align="center">828.4ms</td></tr>
<tr><td><code>primitive-call0</code></td><td align="center">258.3ms</td><td align="center">631.9ms</td><td align="center">740.2ms</td><td align="center">1036.1ms</td></tr>
<tr><td><code>primitive-call3</code></td><td align="center">592.3ms</td><td align="center">994.0ms</td><td align="center">955.7ms</td><td align="center">1891.2ms</td></tr>
<tr><td><code>primitive-array</code></td><td align="center">76.1ms</td><td align="center">204.5ms</td><td align="center">247.4ms</td><td align="center">390.5ms</td></tr>
<tr><td><code>primitive-table</code></td><td align="center">85.8ms</td><td align="center">395.9ms</td><td align="center">269.6ms</td><td align="center">679.2ms</td></tr>
<tr><td><code>primitive-field</code></td><td align="center">82.9ms</td><td align="center">217.6ms</td><td align="center">333.2ms</td><td align="center">633.6ms</td></tr>
<tr><td><code>primitive-method</code></td><td align="center">489.1ms</td><td align="center">1275.1ms</td><td align="center">838.7ms</td><td align="center">2093.0ms</td></tr>
<tr><td><code>rects</code></td><td align="center">384.0ms</td><td align="center">1142.5ms</td><td align="center">1234.7ms</td><td align="center">2664.8ms</td></tr>
<tr><td><code>flood-fill</code></td><td align="center">400.1ms</td><td align="center">632.2ms</td><td align="center">664.3ms</td><td align="center">976.9ms</td></tr>
<tr><td><code>rotation</code></td><td align="center">657.4ms</td><td align="center">1015.3ms</td><td align="center">1325.6ms</td><td align="center">1843.9ms</td></tr>
</tbody></table>
<p>By default, GameLisp's performance is inferior to Python. If you've benchmarked your
GameLisp scripts and established that they're a performance bottleneck, switching on the
<code>&quot;unsafe-internals&quot;</code> flag will roughly double their performance. With that flag switched
on, GameLisp's performance currently hovers somewhere between Lua and Python.</p>
<h2><a class="header" href="#optimizing-gamelisp-code" id="optimizing-gamelisp-code">Optimizing GameLisp Code</a></h2>
<p>Don't.</p>
<p>I really mean it. Other than occasionally thinking about the big-O complexity of your algorithms, 
you shouldn't waste any effort at all trying to make GameLisp run fast. Please don't be tempted.</p>
<p>The primary reason is that, as described in <a href="the-rust-api.html">Section 2</a>, GameLisp is very closely 
integrated with Rust. Here's the punchline to those benchmark figures above:</p>
<table><thead><tr><th>Benchmark</th><th align="center">Rust</th><th align="center">GameLisp (UI)</th><th align="center">GameLisp (SI)</th></tr></thead><tbody>
<tr><td><code>primitive-inc</code></td><td align="center">44.1ms</td><td align="center">672.1ms</td><td align="center">1079.8ms</td></tr>
<tr><td><code>primitive-arith</code></td><td align="center">126.7ms</td><td align="center">535.1ms</td><td align="center">828.4ms</td></tr>
<tr><td><code>primitive-call0</code></td><td align="center">14.1ms</td><td align="center">631.9ms</td><td align="center">1036.1ms</td></tr>
<tr><td><code>primitive-call3</code></td><td align="center">34.5ms</td><td align="center">994.0ms</td><td align="center">1891.2ms</td></tr>
<tr><td><code>primitive-array</code></td><td align="center">12.1ms</td><td align="center">204.5ms</td><td align="center">390.5ms</td></tr>
<tr><td><code>primitive-table</code></td><td align="center">259.5ms</td><td align="center">395.9ms</td><td align="center">679.2ms</td></tr>
<tr><td><code>primitive-field</code></td><td align="center">10.3ms</td><td align="center">217.6ms</td><td align="center">633.6ms</td></tr>
<tr><td><code>primitive-method</code></td><td align="center">10.4ms</td><td align="center">1275.1ms</td><td align="center">2093.0ms</td></tr>
<tr><td><code>rects</code></td><td align="center">9.6ms</td><td align="center">1142.5ms</td><td align="center">2664.8ms</td></tr>
<tr><td><code>flood-fill</code></td><td align="center">2.7ms</td><td align="center">632.2ms</td><td align="center">976.9ms</td></tr>
<tr><td><code>rotation</code></td><td align="center">59.4ms</td><td align="center">1015.3ms</td><td align="center">1843.9ms</td></tr>
</tbody></table>
<p>Idiomatic Rust code will often be more than a hundred times faster than idiomatic GameLisp code. 
Even hand-optimized GameLisp code is usually dozens of times slower than a naive Rust 
implementation. Rust is incredibly fast.</p>
<p>As I mentioned at the <a href="introduction-for-rust-programmers.html">very beginning</a>, GameLisp is 
intended to be used for the messy, exploratory, frequently-changing parts of your codebase. 
Whenever I've been faced with a dilemma between making GameLisp fast and making it convenient, 
I've almost always chosen convenience.</p>
<p>This is why I've put so much effort into giving GameLisp a really nice Rust API. If some part of 
your GameLisp codebase has unacceptably poor performance, it's usually an easy task to &quot;rewrite
it in Rust&quot;, in which case you'll immediately reap huge performance gains.</p>
<p>Here's a quick breakdown of the parts of a game codebase which are likely to be better-suited 
for either Rust or GameLisp, speaking from experience:</p>
<ul>
<li>
<p>For binary file-format parsing, rendering, audio mixing, image processing, vertex processing, 
spatial data structures, collisions, physics simulation, and particle effects, Rust is the 
obvious winner.</p>
<ul>
<li>
<p>That being said, you can definitely manage those parts of your engine using GameLisp. 
Your <code>.zip</code> file parser might be implemented in Rust, but your resource manager could be 
implemented in GameLisp. Your physics simulator might be implemented in Rust, but you 
could also have a <code>PhysicsRect</code> mixin which hooks an entity into the physics system.</p>
</li>
<li>
<p>GameLisp can also be useful for prototyping. For example, if your game procedurally generates
its levels, you could use GameLisp to freely experiment with different algorithms, and then 
reimplement the final algorithm in Rust.</p>
</li>
</ul>
</li>
<li>
<p>Your main loop might belong in Rust, depending on how complicated it is.</p>
<ul>
<li>In particular, one way to achieve good performance would be to combine a Rust ECS 
library with more traditional, object-oriented GameLisp scripting. We discussed some 
specifics in <a href="rglobal.html#using-gamelisp-with-ecs">Section 2</a>.</li>
</ul>
</li>
<li>
<p>For entity behaviour scripting and cutscene scripting, GameLisp is the obvious choice.</p>
</li>
</ul>
<h1><a class="header" href="#naming-conventions-1" id="naming-conventions-1">Naming Conventions</a></h1>
<p>This appendix describes some of the naming conventions I've developed while working on
The Castle on Fire. Improvisation and experimentation are encouraged, but you might find
these guidelines to be a useful starting point.</p>
<h2><a class="header" href="#guidelines" id="guidelines">Guidelines</a></h2>
<p>Prefer brevity.</p>
<p>The <code>=</code> suffix is for functions/methods which perform an assignment, the <code>!</code> suffix is for 
functions/methods which perform any other kind of destructive mutation, and the <code>?</code> suffix is for 
boolean variables and for functions/methods which return booleans. For conversions, consider
using <code>src-&gt;dst</code> for a function or <code>-&gt;dst</code> for a method.</p>
<p>The <code>+</code> suffix should be used for functions/methods which yield. In the unlikely event that
a yielding method performs an assignment or a destructive mutation, the <code>=</code> or <code>!</code> suffix
should be omitted.</p>
<p><code>lower-kebab-case</code> is used for local variables, <code>let-fn</code> functions, <code>let-macro</code> macros, built-in 
functions, built-in macros, class fields, class clauses, and keyword symbols like <code>'ok</code>. If you're 
defining a function or macro which is intended to be very global, such as a new control-flow macro 
or a new numeric function, you should similarly use unprefixed <code>lower-kebab-case</code>.</p>
<p><code>UpperCamelCase</code> is used for classes, states and <code>RData</code> types. This includes mixins, structs,<br />
local classes defined with <code>let-class</code>, and variables which store classes. Class names should
avoid prefixes where possible: <code>Sprite</code> rather than <code>GfxSprite</code> or <code>gfx:Sprite</code>. Capitalization 
follows the same rules as for a Rust struct, e.g. <code>HudPopup</code> rather than <code>HUDPopup</code>. </p>
<p>An <code>RData</code>'s constructor function should be a global variable, named to resemble a class constructor: 
<code>(Sprite rgb w h)</code>, <code>(PhysicsRect coords)</code>. If an <code>RData</code> or a class has multiple possible 
constructors, globally bind a function to the type name, plus a suffix: <code>(Sprite:load path)</code>, 
<code>(TileLayer:from-arr tiles)</code>. In general, when manipulating <code>RData</code> and objects, prefer methods over 
free functions.</p>
<p>Global functions and global variables are categorized into de-facto modules with very short 
names, like <code>img</code>, <code>phys</code> or <code>res</code>. Global names are prefixed with their &quot;module&quot;: 
<code>img:draw</code>, <code>res:load-resources</code>. Toplevel <code>let</code> variables and <code>let-fn</code> functions are similarly 
prefixed, mostly to differentiate them from local variables.</p>
<pre><code>(defn phys:step ()
  ...)

(let-fn phys:box-coords (box)
  ...)
</code></pre>
<p>A small number of ubiquitous global variables are prefixed with <code>:</code>, purely to make them more 
brief. For example, <code>:clock</code> for the current game-time, <code>:dt</code> for the &quot;delta time&quot; since the last 
tick, and <code>:screen-w</code> for the pixel width of the back buffer.</p>
<h1><a class="header" href="#implementation-limits" id="implementation-limits">Implementation Limits</a></h1>
<p>There are several hard limits built in to GameLisp.</p>
<p>There cannot be more than 16,777,216 (<code>2^24</code>) distinct symbols. Running out of symbols is treated
as an unrecoverable error, similar to an out-of-memory condition: attempting to allocate additional
symbols will trigger a panic.</p>
<p>There can't be more than 256 simultaneous GameLisp function calls on the callstack. Attempting
to call the 257th function will trigger an error instead. This is because: </p>
<ul>
<li>GameLisp implements recursion using Rust's callstack.</li>
<li>A Rust stack overflow would abort the process.</li>
<li>GameLisp function calls use up quite a lot of stack space.</li>
<li>The default stack size for <code>*-pc-windows-msvc</code> targets is only one megabyte.</li>
</ul>
<p>Rust currently seems to use up a very large amount of stack space in debug builds. If you try to 
run the <code>glsp</code> crate at <code>opt-level = 0</code>, you may still encounter stack overflows, even when there
are only a few dozen GameLisp function calls on the callstack.</p>
<p>Each &quot;frame&quot; (<code>fn</code> body or single toplevel form) may only contain 256 &quot;registers&quot; (parameters,
local variables, scratch registers or literals). Exceeding this limit will trigger an error.
This will usually only happen if you use macros to code-generate an extremely long function.
In that case, you can break up the function into multiple frames by wrapping each part of
its body in a separate <code>fn</code> form.</p>
<p>A <code>class</code> form may not contain more than 31 <code>state</code> or <code>state*</code> forms, including nested
states and states defined by mixins.</p>
<p>When a function call has more than 32 arguments, the 33rd and later arguments can't be splayed.</p>
<p>No more than 256 <code>Runtimes</code> may simultaneously exist within a single thread.</p>
<p>Each <code>Runtime</code> may not contain more than 8,388,606 (<code>2^23 - 2</code>) rooted objects. (This is the
combined total of objects which have been strongly rooted, with <code>Root</code>, and those which have been
weakly rooted, with <code>Gc</code>). There's also a soft limit on strongly-rooted objects, because they each 
consume a few nanoseconds of time whenever the garbage collector is invoked. If you're likely to 
require more than 100,000 strongly-rooted objects, consider storing that data in Rust rather than 
GameLisp.</p>
<p>There are a small number of ways that a <code>Root</code> or <code>Gc</code> may outlive its parent <code>Runtime</code>, or be 
assigned to a different <code>Runtime</code>. In either scenario, the only way that GameLisp can uphold 
memory safety is by immediately aborting the process! The most likely way you might do this 
accidentally is by either leaking a <code>Root</code> (using a function like <code>Box::leak</code> or <code>Rc::new</code>), 
or storing a <code>Root</code> in a <code>thread_local!</code> variable.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="glsp-highlight.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
