<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Coroutines - GameLisp Reference Manual</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded affix "><a href="introduction-for-rust-programmers.html">Introduction for Rust Programmers</a></li><li class="chapter-item expanded affix "><a href="introduction-for-lisp-programmers.html">Introduction for Lisp Programmers</a></li><li class="chapter-item expanded "><a href="the-language.html"><strong aria-hidden="true">1.</strong> The Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="syntax-and-types.html"><strong aria-hidden="true">1.1.</strong> Syntax and Types</a></li><li class="chapter-item expanded "><a href="evaluation.html"><strong aria-hidden="true">1.2.</strong> Evaluation</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">1.3.</strong> Macros</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="built-in-macros.html"><strong aria-hidden="true">1.3.1.</strong> Built-in Macros</a></li></ol></li><li class="chapter-item expanded "><a href="numbers.html"><strong aria-hidden="true">1.4.</strong> Numbers</a></li><li class="chapter-item expanded "><a href="arrays.html"><strong aria-hidden="true">1.5.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="strings-and-text.html"><strong aria-hidden="true">1.6.</strong> Strings and Text</a></li><li class="chapter-item expanded "><a href="tables.html"><strong aria-hidden="true">1.7.</strong> Tables</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">1.8.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="coroutines.html" class="active"><strong aria-hidden="true">1.9.</strong> Coroutines</a></li><li class="chapter-item expanded "><a href="patterns.html"><strong aria-hidden="true">1.10.</strong> Patterns</a></li><li class="chapter-item expanded "><a href="object-oriented-programming.html"><strong aria-hidden="true">1.11.</strong> Object-Oriented Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="state-machines.html"><strong aria-hidden="true">1.11.1.</strong> State Machines</a></li><li class="chapter-item expanded "><a href="code-reuse.html"><strong aria-hidden="true">1.11.2.</strong> Code Reuse</a></li><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">1.11.3.</strong> Structs</a></li></ol></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">1.12.</strong> Errors</a></li><li class="chapter-item expanded "><a href="miscellaneous.html"><strong aria-hidden="true">1.13.</strong> Miscellaneous</a></li></ol></li><li class="chapter-item expanded "><a href="the-rust-api.html"><strong aria-hidden="true">2.</strong> The Rust API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="the-glsp-crate.html"><strong aria-hidden="true">2.1.</strong> The glsp Crate</a></li><li class="chapter-item expanded "><a href="collection-types.html"><strong aria-hidden="true">2.2.</strong> Collection Types</a></li><li class="chapter-item expanded "><a href="rust-functions.html"><strong aria-hidden="true">2.3.</strong> Rust Functions</a></li><li class="chapter-item expanded "><a href="rust-data.html"><strong aria-hidden="true">2.4.</strong> Rust Data</a></li><li class="chapter-item expanded "><a href="libraries.html"><strong aria-hidden="true">2.5.</strong> Libraries</a></li><li class="chapter-item expanded "><a href="garbage-collection.html"><strong aria-hidden="true">2.6.</strong> Garbage Collection</a></li><li class="chapter-item expanded "><a href="procedural-macros.html"><strong aria-hidden="true">2.7.</strong> Procedural Macros</a></li><li class="chapter-item expanded "><a href="compilation.html"><strong aria-hidden="true">2.8.</strong> Compilation</a></li><li class="chapter-item expanded "><a href="feature-flags.html"><strong aria-hidden="true">2.9.</strong> Feature Flags</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="performance-figures.html">Appendix A: Performance Figures</a></li><li class="chapter-item expanded affix "><a href="naming-conventions.html">Appendix B: Naming Conventions</a></li><li class="chapter-item expanded affix "><a href="implementation-limits.html">Appendix C: Implementation Limits</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">GameLisp Reference Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#coroutines" id="coroutines">Coroutines</a></h1>
<p>A coroutine is a function which can be paused, and later on resumed from where it left off.</p>
<p>Coroutines are defined using the <a href="../std/yield"><code>yield</code></a> special form. When <code>yield</code> is encountered 
within a function, that function pauses its execution, and control flow returns to the caller. 
Later, <a href="../std/coro-run"><code>coro-run</code></a> can be used to resume the coroutine, which causes execution 
to restart from the <code>yield</code> form.</p>
<pre><code>(defn example ()
  (pr &quot;first &quot;)
  (yield)
  (prn &quot;third&quot;))

; invoking a function which contains a (yield) does not start its execution.
; instead, it returns a coroutine which is paused at the start of the
; function's body.
(let coroutine (example))

(coro-run coroutine) ; executes up until the yield
(pr &quot;second &quot;)
(coro-run coroutine) ; executes from the yield to the end of the function

; the above code prints: first second third
</code></pre>
<p>Coroutines can pass values back and forth to their caller when they are paused and resumed.
<code>(yield x)</code> causes the value <code>x</code> to be returned from the <code>(coro-run ...)</code> call. 
<code>(coro-run coroutine y)</code> causes the value <code>y</code> to be returned from the <code>(yield)</code> call. In both 
cases, when no value is specified it defaults to <code>#n</code>.</p>
<pre><code>; this coroutine returns values to its caller. note that coroutines can
; receive arguments, just like a normal function call
(defn increment-forever (n)
  (loop
    (yield n)
    (inc! n)))

(let co (increment-forever 100))

(prn (coro-run co)) ; prints 100
(prn (coro-run co)) ; prints 101
(prn (coro-run co)) ; prints 102

; this coroutine receives values from its caller
(defn overly-elaborate-prn ()
  (loop
    (prn (yield))))

(let co (overly-elaborate-prn))
(coro-run co) ; run until the first (yield)...

(coro-run co 'alpha) ; the coroutine prints alpha
(coro-run co 'beta) ; the coroutine prints beta
(coro-run co 'gamma) ; the coroutine prints gamma
</code></pre>
<p><a href="../std/fn-yields-p"><code>fn-yields?</code></a> will tell you whether or not a function will create a
coroutine when called.</p>
<h2><a class="header" href="#life-cycle-of-a-coroutine" id="life-cycle-of-a-coroutine">Life-Cycle of a Coroutine</a></h2>
<p>The <a href="../std/coro-state"><code>coro-state</code> function</a> returns a symbol describing the current state of a 
coroutine: <code>newborn</code>, <code>running</code>, <code>paused</code>, <code>finished</code> or <code>poisoned</code>.</p>
<p><img src="coroutine-lifecycle.svg" alt="Coroutine life-cycle diagram" /></p>
<p>When you call a function which has at least one <code>yield</code> form somewhere in its body, it will return
a <code>newborn</code> coroutine. You can execute it with <code>coro-run</code>; a currently-executing coroutine is
in the <code>running</code> state. When it encounters a <code>yield</code> form, it will become <code>paused</code>, meaning it 
can be resumed again with <code>coro-run</code>. When a <code>running</code> coroutine returns, it will transition to 
the <code>finished</code> state, which is the end of its life-cycle.</p>
<p>If an <a href="errors.html">error</a> bubbles through a coroutine while it's executing, we assume that it's
been left in a disorderly state. Its state is set to <code>poisoned</code>, and any attempt to resume it
will trigger an error. This is analogous to how Rust's <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code> type</a> works.</p>
<h2><a class="header" href="#coroutines-and-iteration" id="coroutines-and-iteration">Coroutines and Iteration</a></h2>
<p>Coroutines are <code>iterable</code>. A coroutine iterator will repeatedly call <code>(coro-run the-coro)</code> and 
produce each value which the coroutine yields.</p>
<p>This can be used to implement custom iterators:</p>
<pre><code>; a coroutine-based implementation of the `lines` function. copies 
; a string and then splits it into individual lines, yielding one 
; line at a time. once there are no lines left, it returns.
(defn lines (source-str)
  (let st (clone source-str))
  (while (&gt; (len st) 0)
    (let pos (position st \newline))
    (cond
      ((nil? pos)
        (yield st)
        (break))
      (else
      	(let line (remove! st : pos))
      	(pop-start! st)
        (yield line)))))

(prn (arr ..(lines &quot;aaa\nbbb\nccc&quot;))) ; prints (&quot;aaa&quot; &quot;bbb&quot; &quot;ccc&quot;)
</code></pre>
<h2><a class="header" href="#stackful-and-stackless-coroutines" id="stackful-and-stackless-coroutines">Stackful and Stackless Coroutines</a></h2>
<p>In languages like Lua and Ruby, coroutines are &quot;stackful&quot;. Each coroutine allocates its own 
call-stack, and it can yield from arbitrarily deep within that call-stack.</p>
<p>On the other hand, GameLisp's coroutines follow the model set by Rust, Python, C# and C++. Our
coroutines are &quot;stackless&quot;: they only store enough data to pause a single call-frame, so it's
not possible for a coroutine to call a non-coroutine function and <code>yield</code> from inside it. You 
can only <code>yield</code> from the body of the coroutine function itself.</p>
<p>The primary reason for this is that it's much more efficient. Each and every Ruby coroutine 
(known as a <a href="https://ruby-doc.org/core-2.7.1/Fiber.html"><code>Fiber</code></a>) allocates a four-kilobyte, fixed-size callstack. In contrast, a typical
GameLisp coroutine will only allocate 100 to 300 bytes of data - about one-twentieth of the memory 
burden!</p>
<p>The other reason to prefer stackless coroutines is that they can be nested almost as
straightforwardly as stackful coroutines. The <a href="../std/yield-from"><code>yield-from</code> macro</a> will loop 
through an <code>iterable</code>, repeatedly yielding each of its results until it's finished. When the 
<code>iterable</code> is a coroutine, this is roughly equivalent to calling a function and yielding from 
inside it.</p>
<pre><code>; a coroutine which keeps yielding until some event is triggered,
; and then returns
(defn wait-until-trigger (trigger-name)
  (until (trigger-set? trigger-name)
    (yield)))

; a coroutine which controls the behaviour of an entity. the coroutine is
; resumed once per frame. it will do nothing until the 'can-move event 
; has been triggered, and then it will horizontally slide towards the 
; target x coordinate, bit by bit, until it has been reached.
(defn move-to (self x-target)
  (yield-from (wait-until-trigger 'can-move))

  (until (= [self 'x] x-target)
    (seek! [self 'x] x-target 1.5)
    (yield)))
</code></pre>
<h2><a class="header" href="#why-coroutines" id="why-coroutines">Why Coroutines?</a></h2>
<p>Coroutines can be thought of as a form of cooperative multitasking. They behave like 
operating-system threads, but rather than being interrupted at unpredictable intervals by the 
scheduler, they're allowed to execute for as long as they please. The coroutine itself decides 
when to manually end its time-slice and yield control back to the &quot;scheduler&quot; (in this case,
the function which invoked <code>coro-run</code>).</p>
<p>This type of control flow is a natural fit for game programming. Game worlds tend to be filled
with entities which perform complicated behaviours, splitting their actions into tiny incremental
&quot;steps&quot;. When the entity isn't doing anything too elaborate, it's easy to model their behaviour
as a simple function which is called once per frame - but when you want to do a few different
things in sequence, &quot;action A followed by action B followed by action C&quot;, then coroutines are
usually a much better choice.</p>
<p>Consider a cutscene script controller. We want this cutscene to show a dialogue bubble until the
player dismisses it, then have the main character walk to the right until they reach a
waypoint, then pause dramatically for three seconds, then show another dialogue bubble. 
Cramming all of this state into a single event-handler function is a real challenge:</p>
<pre><code>(defn step-handler (self)
  (match [self 'current-state]
    ('start
      (= [self 'bubble] (speak self &quot;You don't understand! I just have...&quot;))
      (= [self 'current-state] 'bubble-0))

    ('bubble-0
      (when (bubble-finished? [self 'bubble])
        (= [self 'current-state] 'walking-to-waypoint)))

    ('walking-to-waypoint
      (step-towards-point self (waypoint 'dramatic-pause))
      (when (at-waypoint? self (waypoint 'dramatic-pause))
        (start-sound 'howling-wind)
        (= [self 'pause-timer] 3.0)
        (= [self 'current-state] 'pausing)))

    ('pausing
      (dec! [self 'pause-timer] :dt)
      (when (&lt;= [self 'pause-timer] 0.0)
        (= [self 'bubble] (speak self &quot;...too many Incredibly Deep Feelings.&quot;))
        (= [self 'current-state] 'bubble-1)))

    ('bubble-1
      (when (bubble-finished? [self 'bubble])
        ; leave the viewer to process the scene's breathtaking emotional pathos
        (= [self 'current-state] 'finished)))))
</code></pre>
<p>The equivalent coroutine is a beauty:</p>
<pre><code>(defn run-cutscene (self)
  (yield-from (speak self &quot;You don't understand! I just have...&quot;))
  (yield-from (walk-to-point self (waypoint 'dramatic-pause)))
  (start-sound 'howling-wind)
  (yield-from (wait-secs 3.0))
  (yield-from (speak self &quot;...too many Incredibly Deep Feelings.&quot;)))
</code></pre>
<p>All of that state which we had to manually store elsewhere is now implicit in the coroutine.
The child functions would be simpler, too: the coroutine <code>walk-to-point</code> is likely to be much
easier to implement, compared to the function <code>step-towards-point</code>. Our coroutine even has 
slightly better performance! Previously we were calling <code>(waypoint)</code> every frame because it would 
have been too much effort to cache it, but the coroutine makes it obvious that rechecking the 
waypoint every frame is actually the more-expensive option.</p>
<p>Cutscene scripting is usually such a nightmare that many smaller game projects either give up
hope of doing anything interesting with it, or come up with some hacky, limited, data-driven 
cutscene control library. But with the incredible power of coroutines, it's all just code, and you 
can make your cutscenes as complicated and emotional as you like! Try not to make your players 
cry too much.</p>
<p>Coroutines are particularly powerful when combined with explicit state machines. We'll explore 
the possibilities in more depth when we discuss <a href="object-oriented-programming.html">object-oriented 
programming</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="iterators.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="iterators.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="glsp-highlight.js"></script>
        

        

    </body>
</html>
